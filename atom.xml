<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术男的后花园</title>
  <subtitle>专注技术分享</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://baronzhang.com/"/>
  <updated>2017-06-12T15:39:45.000Z</updated>
  <id>http://baronzhang.com/</id>
  
  <author>
    <name>张磊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>为 Retrofit2 提供的 FastJson 转换库</title>
    <link href="http://baronzhang.com//blog/Android/%E4%B8%BA-Retrofit2-%E6%8F%90%E4%BE%9B%E7%9A%84-FastJson-%E8%BD%AC%E6%8D%A2%E5%BA%93/"/>
    <id>http://baronzhang.com//blog/Android/为-Retrofit2-提供的-FastJson-转换库/</id>
    <published>2017-05-17T05:15:49.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>为 Retrofit2 提供的 FastJson 转换器（Retrofit2-FastJson-Converter）</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Retrofit 是 Android 和 Java 平台上一款优秀且被广泛使用的 Http 客户端，GitHub 上 21K+ 的 Star 和 4.3K+ 的 Fork 充分证明了 Retrofit 的风靡程度。</p>
<p>Retrofit 在 Android 平台如此流行与它及其简洁的调用方式和优秀的可扩展、可配置性是分不开的。我们客户端在和服务端交互的时候通常采用 Json 格式来传递数据，客户端拿到服务端传递过来的 Json 格式的数据后需要对它进行解析；Retrofit2 并未提供 Json 解析功能，但可提供接口让客户端程序员配置 Json Converter以选择自己喜欢的 Json 解析库。</p>
<a id="more"></a>
<p>Json 解析库有很多：Gson、Jackson、FastJson等等。Retrofit 优秀的可配置性可以让我们客户端程序员随意选择心怡的 Json 解析库，Retrofit 针对 Gson 和 Jackson 都提供相应的 Converter；可能由于 FastJson 是国内程序员开发的原因，Retrofit 对于 FastJson 并没有提供对应的 Converter ，这对于使用 FastJson 的开发者是不友好的。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>好在 Retrofit 提供了接口来让开发者实现自己的 Json Converter 。实现 Converter 虽然简单，但每次使用 Retrofit2 + FastJson 组合时都实现一套显然是没必要的。我使用 FastJson 实现了一个 Converter: <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a> ，有同样需求的同学只需要使用我这个 Converter 库就好啦，不必再去自定义。使用方式如下：</p>
<h3 id="1、添加依赖配置"><a href="#1、添加依赖配置" class="headerlink" title="1、添加依赖配置"></a>1、添加依赖配置</h3><p><strong>Step 1</strong>. 由于 <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a>  是发布到 JitPack 的，因此首先需要在项目根目录的 build.gradle 中加入 JitPack 的仓库地址，具体配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">	repositories &#123;</div><div class="line">		...</div><div class="line">		maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Step 2</strong>. 在具体使用 <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a> 的 module 中加入依赖配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">	compile <span class="string">'com.github.BaronZ88:Retrofit2-FastJson-Converter:lastVersion'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、配置-Retrofit-Converter"><a href="#2、配置-Retrofit-Converter" class="headerlink" title="2、配置 Retrofit Converter"></a>2、配置 Retrofit Converter</h3><p>在 Retrofit.Builder 的 addConverterFactory 方法中传入 <code>FastJsonConverterFactory.create()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">      .baseUrl(baseUrl)</div><div class="line">      .addConverterFactory(FastJsonConverterFactory.create())</div><div class="line">      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">      .client(client)</div><div class="line">      .build();</div></pre></td></tr></table></figure>
<p>最后贴上 Retrofit2-FastJson-Converter 源码地址 ：<a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">https://github.com/BaronZ88/Retrofit2-FastJson-Converter</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>一直不满意各博客平台上的阅读体验，排版糟糕、布局混乱、字体丑陋、各种广告及杂七杂八的组件分散了读者宝贵的注意力；最最重要的是这年头竟然找不到一个优雅、简介、有美感的博客平台！！！我不能忍！为了赏脸阅读我文章的读者！为了我这仅剩的一点点审美！我采用 GitHub Pages + Hexo + NexT 搭建了个人博客 <a href="http://baronzhang.com">http://baronzhang.com</a> ，不过身为拖延症晚期患者的我，直到最近才将博客系统的各项功能陆续完善起来。之前的文章均已同步，之后所有的文章也会第一时间在个人博客上发布，追求更好阅读体验的同学可以移步 <a href="http://baronzhang.com">baronzhang.com</a> 。</strong></p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的<strong>知乎专栏</strong>或者在 GitHub 上添个 Star 吧！</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为 Retrofit2 提供的 FastJson 转换器（Retrofit2-FastJson-Converter）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Retrofit 是 Android 和 Java 平台上一款优秀且被广泛使用的 Http 客户端，GitHub 上 21K+ 的 Star 和 4.3K+ 的 Fork 充分证明了 Retrofit 的风靡程度。&lt;/p&gt;
&lt;p&gt;Retrofit 在 Android 平台如此流行与它及其简洁的调用方式和优秀的可扩展、可配置性是分不开的。我们客户端在和服务端交互的时候通常采用 Json 格式来传递数据，客户端拿到服务端传递过来的 Json 格式的数据后需要对它进行解析；Retrofit2 并未提供 Json 解析功能，但可提供接口让客户端程序员配置 Json Converter以选择自己喜欢的 Json 解析库。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://baronzhang.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 模块化探索与实践</title>
    <link href="http://baronzhang.com//blog/Framework/Android-%E6%A8%A1%E5%9D%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://baronzhang.com//blog/Framework/Android-模块化探索与实践/</id>
    <published>2017-05-08T06:04:12.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ocjtywvav.bkt.clouddn.com/blog/framework/android/2/header.jpg" alt=""></p>
<blockquote>
<p>首发于《程序员》杂志五月刊</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>万维网发明人 Tim Berners-Lee 谈到设计原理时说过：“简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。” 由此可见模块化之于软件工程领域的重要性。</p>
<p>从 2016 年开始，模块化在 Android 社区越来越多的被提及。随着移动平台的不断发展，移动平台上的软件慢慢走向复杂化，体积也变得臃肿庞大；为了降低大型软件复杂性和耦合度，同时也为了适应模块重用、多团队并行开发测试等等需求，模块化在 Android 平台上变得势在必行。阿里 Android 团队在年初开源了他们的容器化框架 Atlas 就很大程度说明了当前 Android 平台开发大型商业项目所面临的问题。</p>
<a id="more"></a>
<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>那么什么是模块化呢？《 Java 应用架构设计：模块化模式与 OSGi 》一书中对它的定义是：模块化是一种处理复杂系统分解为更好的可管理模块的方式。</p>
<p>上面这种描述太过生涩难懂，不够直观。下面这种类比的方式则可能加容易理解。</p>
<p>我们可以把软件看做是一辆汽车，开发一款软件的过程就是生产一辆汽车的过程。一辆汽车由车架、发动机、变数箱、车轮等一系列模块组成；同样，一款大型商业软件也是由各个不同的模块组成的。</p>
<p>汽车的这些模块是由不同的工厂生产的，一辆 BMW 的发动机可能是由位于德国的工厂生产的，它的自动变数箱可能是 Jatco（世界三大变速箱厂商之一）位于日本的工厂生产的，车轮可能是中国的工厂生产的，最后交给华晨宝马的工厂统一组装成一辆完整的汽车。这就类似于我们在软件工程领域里说的多团队并行开发，最后将各个团队开发的模块统一打包成我们可使用的 App 。</p>
<p>一款发动机、一款变数箱都不可能只应用于一个车型，比如同一款 Jatco 的 6AT 自动变速箱既可能被安装在 BMW 的车型上，也可能被安装在 Mazda 的车型上。这就如同软件开发领域里的模块重用。</p>
<p>到了冬天，特别是在北方我们可能需要开着车走雪路，为了安全起见往往我们会将汽车的公路胎升级为雪地胎；轮胎可以很轻易的更换，这就是我们在软件开发领域谈到的低耦合。一个模块的升级替换不会影响到其它模块，也不会受其它模块的限制；同时这也类似于我们在软件开发领域提到的可插拔。</p>
<h2 id="模块化分层设计"><a href="#模块化分层设计" class="headerlink" title="模块化分层设计"></a>模块化分层设计</h2><p>上面的类比很清晰的说明的模块化带来的好处：</p>
<ul>
<li>多团队并行开发测试；</li>
<li>模块间解耦、重用；</li>
<li>可单独编译打包某一模块，提升开发效率。</li>
</ul>
<p>在<a href="https://zhuanlan.zhihu.com/p/25420181" target="_blank" rel="external">《安居客 Android 项目架构演进》</a>这篇文章中，我介绍了安居客 Android 端的模块化设计方案，这里我还是拿它来举例。但首先要对本文中的<strong>组件</strong>和<strong>模块</strong>做个区别定义</p>
<ul>
<li><p><strong>组件</strong>：指的是单一的功能组件，如地图组件（MapSDK）、支付组件（AnjukePay）、路由组件（Router）等等；</p>
</li>
<li><p><strong>模块</strong>：指的是独立的业务模块，如新房模块（NewHouseModule）、二手房模块（SecondHouseModule）、即时通讯模块（InstantMessagingModule）等等；模块相对于组件来说粒度更大。</p>
</li>
</ul>
<p>具体设计方案如下图：</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/blog/framework/android/2/modularization.png" alt="Android 模块化设计方案"></p>
<p>整个项目分为三层，从下至上分别是：</p>
<ul>
<li>Basic Component Layer: 基础组件层，顾名思义就是一些基础组件，包含了各种开源库以及和业务无关的各种自研工具库；</li>
<li>Business Component Layer: 业务组件层，这一层的所有组件都是业务相关的，例如上图中的支付组件 AnjukePay、数据模拟组件 DataSimulator 等等；</li>
<li>Business Module Layer: 业务 Module 层，在 Android Studio 中每块业务对应一个单独的 Module。例如安居客用户 App 我们就可以拆分成新房 Module、二手房 Module、IM Module 等等，每个单独的 Business Module 都必须准遵守我们自己的 MVP 架构。</li>
</ul>
<p>我们在谈模块化的时候，其实就是将业务模块层的各个功能业务拆分层独立的业务模块。所以我们进行模块化的第一步就是业务模块划分，但是模块划分并没有一个业界通用的标准，因此划分的粒度需要根据项目情况进行合理把控，这就需要对业务和项目有较为透彻的理解。拿安居客来举例，我们会将项目划分为新房模块、二手房模块、IM 模块等等。</p>
<p>每个业务模块在 Android Studio 中的都是一个 Module ,因此在命名方面我们要求每个业务模块都以 Module 为后缀。如下图所示：<div align="left"><img src="http://ocjtywvav.bkt.clouddn.com/blog/framework/android/2/modules.png" width="40%" alt="图片名称" align="center"></div></p>
<p>对于模块化项目，每个单独的 Business Module 都可以单独编译成 APK。在开发阶段需要单独打包编译，项目发布的时候又需要它作为项目的一个 Module 来整体编译打包。简单的说就是开发时是 Application，发布时是 Library。因此需要在 Business Module 的 build.gradle 中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isBuildModule.toBoolean())&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>isBuildModule 在项目根目录的 gradle.properties 中定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; isBuildModule=<span class="keyword">false</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>同样 Manifest.xml 也需要有两套：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sourceSets &#123;</div><div class="line">   main &#123;</div><div class="line">       <span class="keyword">if</span> (isBuildModule.toBoolean()) &#123;</div><div class="line">           manifest.srcFile <span class="string">'src/main/debug/AndroidManifest.xml'</span></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           manifest.srcFile <span class="string">'src/main/release/AndroidManifest.xml'</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如图：<div align="left"><img src="http://ocjtywvav.bkt.clouddn.com/blog/framework/android/2/manifest.png" width="45%" alt="图片名称" align="center"></div></p>
<p>debug 模式下的 AndroidManifest.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span></span></div><div class="line">   <span class="attr">...</span></div><div class="line">   &gt;</div><div class="line">   <span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">       <span class="attr">android:name</span>=<span class="string">"com.baronzhang.android.newhouse.NewHouseMainActivity"</span></div><div class="line">       <span class="attr">android:label</span>=<span class="string">"@string/new_house_label_home_page"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></div></pre></td></tr></table></figure>
<p>realease 模式下的 AndroidManifest.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span></span></div><div class="line">   <span class="attr">...</span></div><div class="line">   &gt;</div><div class="line">   <span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">       <span class="attr">android:name</span>=<span class="string">"com.baronzhang.android.newhouse.NewHouseMainActivity"</span></div><div class="line">       <span class="attr">android:label</span>=<span class="string">"@string/new_house_label_home_page"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">"com.baronzhang.android.newhouse"</span></span></div><div class="line">               <span class="attr">android:scheme</span>=<span class="string">"router"</span> /&gt;</div><div class="line">       <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></div></pre></td></tr></table></figure>
<p>同时针对模块化我们也定义了一些自己的游戏规则:</p>
<ul>
<li>对于 Business Module Layer，各业务模块之间不允许存在相互依赖关系，它们之间的跳转通讯采用路由框架 Router 来实现（后面会介绍 Router 框架的实现）;</li>
<li>对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，个性化需求对外部提供接口让调用方定制;</li>
<li>合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分;</li>
<li>上层的公有业务或者功能模块可以逐步下放到下层，合理把握好度就好；</li>
<li>各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。</li>
</ul>
<h2 id="模块间跳转通讯（Router）"><a href="#模块间跳转通讯（Router）" class="headerlink" title="模块间跳转通讯（Router）"></a>模块间跳转通讯（Router）</h2><p>对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个 Bussiness Module 都是独立的模块，它们之间是没有依赖关系。那么各个模块间的跳转通讯如何实现呢？</p>
<p>比如业务上要求从<strong>新房的列表页</strong>跳转到<strong>二手房的列表页</strong>，那么由于是 NewHouseModule 和 SecondHouseModule 之间并不相互依赖，我们通过想如下这种显式跳转的方式来实现 Activity 跳转显然是不可能的实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(NewHouseListActivity.<span class="keyword">this</span>, SecondHouseListActivity.class);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>有的同学可能会想到用隐式跳转，通过 Intent 匹配规则来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, <span class="string">"&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;"</span>);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>但是这种代码写起来比较繁琐，且容易出错，出错也不太容易定位问题。因此一个简单易用、解放开发的路由框架是必须的了。<div align="left"><img src="http://ocjtywvav.bkt.clouddn.com/blog/framework/android/2/router2.png" width="45%" alt="图片名称" align="center"></div></p>
<p>我自己实现的路由框架分为<b>路由（Router）</b> 和<b>参数注入器（Injector）</b> 两部分：<div align="left"><img src="http://ocjtywvav.bkt.clouddn.com/blog/framework/android/2/router.png" width="45%" alt="图片名称" align="center"></div></p>
<blockquote>
<p>Router 提供 Activity 跳转传参的功能；Injector 提供参数注入功能，通过编译时生成代码的方式在 Activity 获取获取传递过来的参数，简化开发。</p>
</blockquote>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>路由（Router）部分通过 Java 注解结合动态代理来实现，这一点和 Retrofit 的实现原理是一样的。</p>
<p>首先需要定义我们自己的注解（篇幅有限，这里只列出少部分源码）。</p>
<p>用于定义跳转 URI 的注解 FullUri：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FullUri &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于定义跳转传参的 UriParam（ UriParam 注解的参数用于拼接到 URI 后面）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UriParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于定义跳转传参的 IntentExtrasParam（ IntentExtrasParam 注解的参数最终通过 Intent 来传递）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IntentExtrasParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实现 Router ,内部通过动态代理的方式来实现 Activity 跳转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class[]&#123;service&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"></div><div class="line">                FullUri fullUri = method.getAnnotation(FullUri.class);</div><div class="line">                StringBuilder urlBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">                urlBuilder.append(fullUri.value());</div><div class="line">                <span class="comment">//获取注解参数</span></div><div class="line">                Annotation[][] parameterAnnotations = method.getParameterAnnotations();</div><div class="line">                HashMap&lt;String, Object&gt; serializedParams = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">			    <span class="comment">//拼接跳转 URI</span></div><div class="line">                <span class="keyword">int</span> position = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</div><div class="line">                    Annotation[] annotations = parameterAnnotations[i];</div><div class="line">                    <span class="keyword">if</span> (annotations == <span class="keyword">null</span> || annotations.length == <span class="number">0</span>)</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    Annotation annotation = annotations[<span class="number">0</span>];</div><div class="line">                    <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> UriParam) &#123;</div><div class="line">                        <span class="comment">//拼接 URI 后的参数</span></div><div class="line">                        ...</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> IntentExtrasParam) &#123;</div><div class="line">                        <span class="comment">//Intent 传参处理</span></div><div class="line">                        ...</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//执行Activity跳转操作</span></div><div class="line">                performJump(urlBuilder.toString(), serializedParams);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是 Router 实现的部分代码，在使用 Router 来跳转的时候，首先需要定义一个 Interface（类似于 Retrofit 的使用方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouterService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@FullUri</span>(<span class="string">"router://com.baronzhang.android.router.FourthActivity"</span>)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startUserActivity</span><span class="params">(@UriParam(<span class="string">"cityName"</span>)</span></span></div><div class="line">    		String cityName, @<span class="title">IntentExtrasParam</span><span class="params">(<span class="string">"user"</span>)</span> User user);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们就可以通过如下方式实现 Activity 的跳转传参了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RouterService routerService = <span class="keyword">new</span> Router(<span class="keyword">this</span>).create(RouterService.class);</div><div class="line"></div><div class="line">User user = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">17</span>, <span class="number">165</span>, <span class="number">88</span>);</div><div class="line">routerService.startUserActivity(<span class="string">"上海"</span>, user);</div></pre></td></tr></table></figure>
<h3 id="Injector"><a href="#Injector" class="headerlink" title="Injector"></a>Injector</h3><p>通过 Router 跳转到目标 Activity 后，我们需要在目标 Activity 中获取通过 Intent 传过来的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getIntent().getIntExtra(<span class="string">"intParam"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">getIntent().getData().getQueryParameter(<span class="string">"preActivity"</span>);</div></pre></td></tr></table></figure>
<p>为了简化这部分工作，路由框架 Router 中提供了 Injector 模块在编译时生成上述代码。参数注入器（Injector）部分通过 Java 编译时注解来实现，实现思路和 ButterKnife 这类编译时注解框架类似。</p>
<p>首先定义我们的参数注解 InjectUriParam ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectUriParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实现一个注解处理器 InjectProcessor ，在编译阶段生成获取参数的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line">    ...</div><div class="line">   <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//解析注解</span></div><div class="line">        Map&lt;TypeElement, TargetClass&gt; targetClassMap = findAndParseTargets(roundEnvironment);</div><div class="line"></div><div class="line">        <span class="comment">//解析完成后，生成的代码的结构已经有了，它们存在InjectingClass中</span></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;TypeElement, TargetClass&gt; entry : targetClassMap.entrySet()) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方式类似于 ButterKnife ，在 Activity 中我们使用 Inject 来注解一个全局变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inject</span> User user;</div></pre></td></tr></table></figure>
<p>然后 onCreate 方法中需要调用 inject(Activity activity) 方法实现注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RouterInjector.inject(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>这样我们就可以获取到前面通过 Router 跳转的传参了。</p>
<blockquote>
<p>由于篇幅限制，加上为了便于理解，这里只贴出了极少部分 <a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 框架的源码。希望进一步了解 Router 实现原理的可以到 GiuHub 去翻阅源码，<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 的实现还比较简陋，后面会进一步完善功能和文档，之后也会有单独的文章详细介绍。源码地址：<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">https://github.com/BaronZ88/Router</a></p>
</blockquote>
<h2 id="问题及建议"><a href="#问题及建议" class="headerlink" title="问题及建议"></a>问题及建议</h2><h3 id="资源名冲突"><a href="#资源名冲突" class="headerlink" title="资源名冲突"></a>资源名冲突</h3><p>对于多个 Bussines Module 中资源名冲突的问题，可以通过在 build.gradle 定义前缀的方式解决：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">   ...</div><div class="line">   resourcePrefix <span class="string">"new_house_"</span></div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于 Module 中有些资源不想被外部访问的，我们可以创建 res/values/public.xml，添加到 public.xml 中的 resource 则可被外部访问，未添加的则视为私有：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">"new_house_settings"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="重复依赖"><a href="#重复依赖" class="headerlink" title="重复依赖"></a>重复依赖</h3><p>模块化的过程中我们常常会遇到重复依赖的问题，如果是通过 aar 依赖， gradle 会自动帮我们找出新版本，而抛弃老版本的重复依赖。如果是以 project 的方式依赖，则在打包的时候会出现重复类。对于这种情况我们可以在 build.gradle 中将 compile 改为 provided，只在最终的项目中 compile 对应的 library ；</p>
<p>其实从前面的安居客模块化设计图上能看出来，我们的设计方案能一定程度上规避重复依赖的问题。比如我们所有的第三方库的依赖都会放到 OpenSoureLibraries 中，其他需要用到相关类库的项目，只需要依赖 OpenSoureLibraries 就好了。</p>
<h3 id="模块化过程中的建议"><a href="#模块化过程中的建议" class="headerlink" title="模块化过程中的建议"></a>模块化过程中的建议</h3><p>对于大型的商业项目，在重构过程中可能会遇到业务耦合严重，难以拆分的问题。<strong>我们需要先理清业务，再动手拆分业务模块</strong>。比如可以先在原先的项目中根据业务分包，在一定程度上将各业务解耦后拆分到不同的 package 中。比如之前新房和二手房由于同属于 app module，因此他们之前是通过隐式的 intent 跳转的，现在可以先将他们改为通过 Router 来实现跳转。又比如新房和二手房中公用的模块可以先下放到 Business Component Layer 或者 Basic Component Layer 中。在这一系列工作完成后再将各个业务拆分成多个 module 。</p>
<p>模块化重构需要渐进式的展开，不可一触而就，不要想着将整个项目推翻重写。线上成熟稳定的业务代码，是经过了时间和大量用户考验的；全部推翻重写往往费时费力，实际的效果通常也很不理想，各种问题层出不穷得不偿失。对于这种项目的模块化重构，我们需要一点点的改进重构，可以分散到每次的业务迭代中去，逐步淘汰掉陈旧的代码。</p>
<p>各业务模块间肯定会有公用的部分，按照我前面的设计图，公用的部分我们会根据业务相关性下放到业务组件层（Business Component Layer）或者基础组件层（Common Component Layer）。对于太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分。过程中完美主义可以有，切记不可过度。</p>
<p>以上就是我在模块化探索实践方面的一些经验，不住之处还望大家指出。</p>
<ul>
<li>模块化示例项目 <a href="https://github.com/BaronZ88/ModularizationProject" target="_blank" rel="external">ModularizationProject</a> 源码地址：<a href="https://github.com/BaronZ88/ModularizationProject" target="_blank" rel="external">https://github.com/BaronZ88/ModularizationProject</a></li>
<li>路由框架 <a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 源码地址：<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">https://github.com/BaronZ88/Router</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/blog/framework/android/2/header.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首发于《程序员》杂志五月刊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;万维网发明人 Tim Berners-Lee 谈到设计原理时说过：“简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。” 由此可见模块化之于软件工程领域的重要性。&lt;/p&gt;
&lt;p&gt;从 2016 年开始，模块化在 Android 社区越来越多的被提及。随着移动平台的不断发展，移动平台上的软件慢慢走向复杂化，体积也变得臃肿庞大；为了降低大型软件复杂性和耦合度，同时也为了适应模块重用、多团队并行开发测试等等需求，模块化在 Android 平台上变得势在必行。阿里 Android 团队在年初开源了他们的容器化框架 Atlas 就很大程度说明了当前 Android 平台开发大型商业项目所面临的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://baronzhang.com/categories/Framework/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://baronzhang.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>安居客 Android 项目架构演进</title>
    <link href="http://baronzhang.com//blog/Framework/%E5%AE%89%E5%B1%85%E5%AE%A2Android%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
    <id>http://baronzhang.com//blog/Framework/安居客Android项目架构演进/</id>
    <published>2017-02-24T09:59:16.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/header.jpg" alt=""></p>
<blockquote>
<p>本文已授权微信公众号 AndroidDeveloper 独家发布。</p>
</blockquote>
<p>入职安居客三年从工程师到 Team Leader，见证了 Android 团队一路走来的发展历程。因此有心将这些记录下来与大家分享，也算是对自己三年来一部分工作的总结。希望对大家有所帮助，更希望能得到大家宝贵的建议。<br><a id="more"></a></p>
<h2 id="三网合并"><a href="#三网合并" class="headerlink" title="三网合并"></a>三网合并</h2><p>三年前入职时安居客在业务上刚完成了三网合并（新房、二手房、好租和商业地产多个平台多个网站合成现在的 anjuke.com，这在公司的历史上称之为三网合并）,因此移动端也将原先的新房、二手房、好租和商业地产多个 App 合并成为了现在的安居客 App。所谓的合并也差不多就是将多个项目的代码拷贝到了一起组成了新的 Anjuke Project。下面这张图能更加直观的呈现当时的状况：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/merge1.1.png" width="70%" alt="图片名称" align="center"></div></p>
<p>这一时期代码结构混乱、层次不清，各业务技术方案不统一，冗余代码充斥项目的各个角落；甚至连基本的包结构也是胡乱不堪，项目架构更是无从谈起。大家只不过是不停地往上堆砌代码添加新功能罢了。于是我进入公司的第一件事就是向 Leader 申请梳理了整个项目的结构。</p>
<p>而后随着项目的迭代，我们不断引入了 Retrofit、UniversalImageLoader、OKHttp、ButterKnife 等一系列成熟的开源库，同时我们也开发了自己的 UI 组件库 UIComponent、基础工具库 CommonUtils、基于第三方地图封装的 MapSDK、即时聊天模块 ChatLibrary 等等。这之后安居客项目架构大致演变成了由基础组件层、业务组件层和业务层组成的三层架构。如下图：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/merge2.1.png" width="50%" alt="图片名称" align="center"></div></p>
<p>其中业务层是一种非标准的 MVC 架构，Activity 和 Fragment 承担了 View 和 Controller 的职责：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/merge3.1.png" width="85%" alt="图片名称" align="center"></div></p>
<p>前面这种分层的架构本身是没太大问题的，即使到了现在我们的业务项目也已然是基于这种分层的架构来构建的，只不过在不断的迭代中我们做了些许调整（分层架构后面在介绍组件化和模块化的时候会详细介绍）。但是随着业务的不断迭代,我们慢慢发现业务层这种非标准的MVC架构带来了种种影响团队开发效率的问题：</p>
<ul>
<li>Activity 和 Fragment 越来越多的同时承担了 Controller 和 View 的职责，导致他们变得及其臃肿且难以维护；</li>
<li>由于 Controller 和 View 的揉合，导致单元测试起来很困难；</li>
<li>回调嵌套太多，面对负责业务时的代码逻辑不清晰，难以理解且不利于后期维护；</li>
<li>各层次模块之间职责不清晰等等</li>
</ul>
<blockquote>
<p>鉴于三网合并时期我还未加入安居客，所以对这一块的理解难免有偏差，如果有安居客的老同事发现文章中的描述有不对的地方还望批评指正。</p>
</blockquote>
<h2 id="由-RxJava-驱动的-MVP-架构"><a href="#由-RxJava-驱动的-MVP-架构" class="headerlink" title="由 RxJava 驱动的 MVP 架构"></a>由 RxJava 驱动的 MVP 架构</h2><p>一种技术架构无法满足所有的业务项目，更不可能有一种架构方案能够一劳永逸。正如上一节中提到的随着业务的不断迭代，现有架构的缺陷逐渐浮出水面，项目架构必需不断升级迭代才能更好地服务于业务。</p>
<h3 id="MVP-的设计与实现"><a href="#MVP-的设计与实现" class="headerlink" title="MVP 的设计与实现"></a>MVP 的设计与实现</h3><p>在研究了 Google 推出的基于 MVP 架构的 Demo 后，我们发现 MVP 架构能解决现在所面临过的很多问题，于是我们学习并引入到了我们的项目中来，并针对性的做了部分调整。下图呈现的是安居客 MVP 方案：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/mvp1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>以前面提到的三层架构的方案来看是这样的：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/mvp2.1.png" width="50%" alt="图片名称" align="center"></div></p>
<blockquote>
<p>基于此架构我在 GitHub 上开源了一个项目<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>，有兴趣的小伙伴可以去 Clone 下来看看，如果觉得对你有帮助就给个 Star 吧。  :)</p>
</blockquote>
<ul>
<li><strong>View Layer</strong>: 只负责 UI 的绘制呈现，包含 Fragment 和一些自定义的 UI 组件，View 层需要实现 ViewInterface 接口。Activity 在项目中不再负责 View 的职责，仅仅是一个全局的控制者，负责创建 View 和 Presenter 的实例；</li>
<li><strong>Model Layer</strong>: 负责检索、存储、操作数据，包括来自网络、数据库、磁盘文件和SharedPreferences的数据；</li>
<li><strong>Presenter Layer</strong>: 作为 View Layer 和 Module Layer 的之间的纽带，它从 Model 层中获取数据，然后调用 View 的接口去控制 View；</li>
<li><strong>Contract</strong>: 我们参照 Google 的 Demo 加入契约类 Contract 来统一管理 View 和 Presenter 的接口，使得某一功能模块的接口能更加直观的呈现出来，这样做是有利于后期维护的。</li>
</ul>
<p>另外这套MVP架构还为我们带来了一个额外的好处：<strong>我们有了足够明确的开发规范和标准</strong>。细致到了每一个类应该放到哪个包下，哪个类具体应该负责什么职责等等。这对于我们的 Code Review、接手他人的功能模块等都提供了极大的便利。前面提到的 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 就是为了定规范定标准而开发的。</p>
<p>这一时期我们还在项目中引入了 RxJava，很好的解决了前面提到的嵌套回调的问题，同时能够帮助我们简化复杂业务场景下的代码逻辑（当然 RxJava 的好处远远不止这么一点，对 RxJava 不了解的同学可以去翻翻我之前<a href="https://zhuanlan.zhihu.com/p/20687178?refer=baron" target="_blank" rel="external">一系列关于 RxJava 的文章</a>）。我们也将网络库升级到了 Retrofit2 + OKHttp3，它们和 RxJava 之间能更好的配合。</p>
<h3 id="MVP-带来的新问题及解决方案"><a href="#MVP-带来的新问题及解决方案" class="headerlink" title="MVP 带来的新问题及解决方案"></a>MVP 带来的新问题及解决方案</h3><p>是不是升级到了 MVP 架构就高枕无忧了呢？很明显不是这样！MVP 架构也会带来以下新的问题：</p>
<ul>
<li>由于大量的业务逻辑处理转移到了 Presenter 层，在一些复杂的业务场景中 Presenter 同样会变得臃肿难懂。细心的同学可能注意到了前面的架构图中的 Model 层有个 Data Repository 模块，Data Repository 在这里有两个作用：一是可以将原本由 Presenter 处理的部分逻辑转移到这里来处理，包括数据的校验、部分单纯只与数据相关的逻辑等等，向 Presenter 屏蔽数据处理细节，比如作为 Presenter 就不必关心 Model 层传递过来的数据到底是来至网络还是来至数据库还是来至本地文件等等；二是我们引入了 RxJava，但是只有网络层中的 Retrofit 能返回 Observable 对象，其他模块都是返回的还是一些非 Observable 的 Java 对象，为了能在整个 Presenter 层中都体验 RxJava 带来的美妙之处，因此可以通过 Data Repository 做一层转换；</li>
<li>现在的 MVP 架构中最重的部分就是 Model Layer 了，这一点从前面的架构图中就能体现。因此这就要求我们在 Model 层的设计过程中职责划分要足够清晰，分包更明确，耦合度更低。至于分包大家可以参考 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 的方案：db 包为数据库模块、http 包为网络模块、preference 包是对 SharedPreferences 的一些封装、repository 包就是前面提到的 Data Repository 模块；</li>
<li>同时还有一点需要注意，很多人在使用 RxJava 的过程中往往忘记了对生命周期的管理，这很容易造成内存泄露。<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 中采用了 CompositeSubscription 来管理，你也可以使用 RxLifecycle 这类开源库来管理生命周期。</li>
</ul>
<h2 id="组件化与模块化"><a href="#组件化与模块化" class="headerlink" title="组件化与模块化"></a>组件化与模块化</h2><p>去年下半年我们 Android 团队内部成立了技术小组，基础组件的开发是技术小组很重要的一部分工作，所以组件化是我们正在做的事；模块化更多的是现有的方案受到来自业务上的挑战以及受到了 Oasis Feng 在 MDCC 上的分享和整个大环境的启发，现在正处于设计规划和 Demo 开发的阶段。</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件化不是个新概念，通俗的讲组件化就是基于可重用的目的，将一个大的软件系统拆分成一个个独立组件。</p>
<p>组件化的带来的好处不言而喻：</p>
<ul>
<li>避免重复造轮子，节省开发维护成本；</li>
<li>降低项目复杂性，提升开发效率；</li>
<li>多个团队公用同一个组件，在一定层度上确保了技术方案的统一性。</li>
</ul>
<p>现在的安居客有是三个业务团队：安居客用户 App、经纪人 App、集客家 App。为了避免各个业务团队重复造轮子，团队中也需要有一定的技术沉淀，因此组件化是必须的。从本篇的第一节大家就能看到组件化的影子，只不过在这之前我们做的并不好。现在我们需要提供更多的、职能单一、性能更优的组件供业务团队使用。根据业务相关性，我们将这些组件分为：基础组件和业务组件。后面在介绍模块化的时候会有进一步的描述。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>自从 Oasis Feng 在去年的 MDCC2016 上分享了模块化的经验后，模块化在 Android 社区越来越多的被提起。我们自然也不落俗的去做了一些研究和探索。安居客现在面临很多问题：例如全量编译时间太长（我这台13款的 MacBook Pro 上打一次包得花十多分钟）；例如新房、二手房、租房等等模块间耦合严重，不利于多团队并行开发测试；另外在17年初公司重新将租房 App 捡起推广，单独让人来开发维护一个三年前的项目并不划算，所以我们希望能直接从现在的安居客用户端中拆分出租房模块作为一个单独的 App 发布上线。这样看来模块化似乎是一个不错的选择。</p>
<p>所以我们做模块化的目的大致是这样的：</p>
<ul>
<li>业务模块间解耦</li>
<li>单个业务模块单独编译打包，加快编译速度</li>
<li>多团队间并行开发、测试</li>
<li>解决好租App需要单独维护的问题，降低研发成本</li>
</ul>
<blockquote>
<p>15年 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 还在安居客的时候开发了一套插件化框架，但受限于当时的团队规模并且插件化对整个项目的改造太大，因此在安居客团队中插件化并未实施下来。而模块化其实是个很好的过渡方案，将项目按照模块拆分后各业务模块间解耦的问题不存在了，后续如有必要，再进行插件化改造只不过是水到渠成的事。</p>
</blockquote>
<p>来看看安居客用户 App 的模块化设计图：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/modularization1.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>整个项目分为三层，从下往上分别是：</p>
<ul>
<li>Basic Component Layer: 基础组件层，顾名思义就是一些基础组件，包含了各种开源库以及和业务无关的各种自研工具库；</li>
<li>Business Component Layer: 业务组件层，这一层的所有组件都是业务相关的，例如上图中的支付组件 AnjukePay、数据模拟组件 DataSimulator 等等；</li>
<li>Business Module Layer: 业务 Module 层，在 Android Studio 中每块业务对应一个单独的 Module。例如安居客用户 App 我们就可以拆分成新房 Module、二手房 Module、IM Module 等等，每个单独的 Business Module 都必须准遵守前面提到的 MVP 架构。</li>
</ul>
<p>同时针对模块化我们也需要定义一些自己的游戏规则:</p>
<ul>
<li>对于 Business Module Layer，各业务模块之间的通讯跳转采用路由框架 Router 来实现（可能会采用成熟的开源库，也可能会选择重复造轮子）;</li>
<li>对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，对于有个性化需求的对外部提供接口让调用方定制;</li>
<li>合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分（这一点的灵感来源于 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 的文章）;</li>
<li>上层的公有的业务或者功能模块可以逐步下放到下层，合理把握好度就好；</li>
<li>各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。</li>
</ul>
<p>对于模块化项目，每个单独的 Business Module 都可以单独编译成 APK。在开发阶段需要单独打包编译，项目发布的时候又需要它作为项目的一个 Module 来整体编译打包。简单的说就是开发时是 Application，发布时是 Library。因此需要你在 Business Module 的 Gradle 配置文件中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isBuildModule.toBoolean())&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们需要把租房模块打包成一个单独的租房 App，像下面这样就好：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/modularization2.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>我们可以把 Basic Component Layer 和 Business Component Layer 放在一起看做是 Anjuke SDK，新的业务或者项目只需要依赖 Anjuke SDK 就好（这一点同样是受到了 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 文章的启发）。甚至我们可以做得更极致一些，开发一套自己的组件管理平台，业务方可以根据自己的需求选择自己需要的组件，定制业务专属的 Anjuke SDK。业务端和 Anjuke SDK 的关系如下图所示：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/modularization3.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>最后看看安居客模块化的整体设计图：<div align="center"><img src="http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/modularization4.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>模块化拆分对于安居客这种比较大型的商业项目而言，由于历史比较久远很多代码都运行五六年了；各个业务相互交叉耦合严重，所以实施起来还是有很大难度的。过程中难免会有预料不到的坑，这就需要我们对各个业务有较深的理解同时也要足够的耐心和细致。虽然辛苦，但是一旦完成模块化拆分对整个团队及公司业务上的帮助是很大的。</p>
<p>以上是我的简单总结以及对模块化的一些思考，不足之处还望大家批评指正。后面模块化的 Demo 完善后我会把它放到 GitHub，并再出一篇文章详细介绍模块化的设计实现细节。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://www.csdn.net/article/2015-12-16/2826499-android-app-architecture?locationNum=7&amp;fps=1" target="_blank" rel="external">http://www.csdn.net/article/2015-12-16/2826499-android-app-architecture?locationNum=7&amp;fps=1</a></li>
<li><a href="http://www.trinea.cn/android/didi-internationalization-android-evolution/" target="_blank" rel="external">http://www.trinea.cn/android/didi-internationalization-android-evolution/</a></li>
<li><a href="https://www.tianmaying.com/tutorial/AndroidMVC" target="_blank" rel="external">https://www.tianmaying.com/tutorial/AndroidMVC</a></li>
<li><a href="https://www.diycode.cc/topics/362" target="_blank" rel="external">https://www.diycode.cc/topics/362</a></li>
<li><a href="https://github.com/MDCC2016/Android-Session-Slides/blob/master/02-From.Containerization.To.Modularity.pdf" target="_blank" rel="external">https://github.com/MDCC2016/Android-Session-Slides/blob/master/02-From.Containerization.To.Modularity.pdf</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的<strong>知乎专栏</strong>或者在 GitHub 上添个 Star 吧！</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://ocjtywvav.bkt.clouddn.com/Blog/Framework/Android/header.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文已授权微信公众号 AndroidDeveloper 独家发布。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;入职安居客三年从工程师到 Team Leader，见证了 Android 团队一路走来的发展历程。因此有心将这些记录下来与大家分享，也算是对自己三年来一部分工作的总结。希望对大家有所帮助，更希望能得到大家宝贵的建议。&lt;br&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://baronzhang.com/categories/Framework/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://baronzhang.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>神兵利器Dagger2</title>
    <link href="http://baronzhang.com//blog/OpenSource/Java/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8Dagger2/"/>
    <id>http://baronzhang.com//blog/OpenSource/Java/神兵利器Dagger2/</id>
    <published>2017-02-06T10:58:18.000Z</published>
    <updated>2017-12-26T06:53:29.801Z</updated>
    
    <content type="html"><![CDATA[<p>Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。</p>
<p>Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。</p>
<p>起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。</p>
<a id="more"></a>
<h2 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h2><p>那么什么是依赖注入呢？在解释这个概念前我们先看一小段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</div><div class="line">		engine = <span class="keyword">new</span> Engine();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段Java代码中Car类持有了对Engine实例的引用，我们称之为Car类对Engine类有一个依赖。而依赖注入则是指通过注入的方式实现类与类之间的依赖，下面是常见的三种依赖注入的方式：</p>
<h3 id="1-构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。"><a href="#1-构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。" class="headerlink" title="1. 构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。"></a>1. 构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-接口注入：实现接口方法，同样以传参的方式实现注入。"><a href="#2-接口注入：实现接口方法，同样以传参的方式实现注入。" class="headerlink" title="2. 接口注入：实现接口方法，同样以传参的方式实现注入。"></a>2. 接口注入：实现接口方法，同样以传参的方式实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Injection</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Injection</span>&lt;<span class="title">Engine</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Engine engine)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。"><a href="#3-注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。" class="headerlink" title="3. 注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。"></a>3. 注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Inject</span></div><div class="line">	Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前两种注入方式需要我们编写大量的模板代码，而机智的Dagger2则是通过Java注解在编译期来实现依赖注入的。</p>
<h2 id="为什么需要依赖注入"><a href="#为什么需要依赖注入" class="headerlink" title="为什么需要依赖注入"></a>为什么需要依赖注入</h2><p>我们之所是要依赖注入，最重要的就是为了解耦，达到高内聚低耦合的目的，保证代码的健壮性、灵活性和可维护性。</p>
<p>下面我们看看同一个业务的两种实现方案：</p>
<h3 id="1-方案A"><a href="#1-方案A" class="headerlink" title="1. 方案A"></a>1. 方案A</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line">	<span class="keyword">private</span> List&lt;Wheel&gt; wheels;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</div><div class="line">		engine = <span class="keyword">new</span> Engine();</div><div class="line">		wheels = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</div><div class="line">			wheels.add(<span class="keyword">new</span> Wheel());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> start&#123;</div><div class="line">		System.out.println(<span class="string">"启动汽车"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarTest</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		Car car = <span class="keyword">new</span> Car();</div><div class="line">		car.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-方案B"><a href="#2-方案B" class="headerlink" title="2. 方案B"></a>2. 方案B</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line">	<span class="keyword">private</span> List&lt;Wheel&gt; wheels;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine, List&lt;Wheel&gt; wheels)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">		<span class="keyword">this</span>.wheels = wheels;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> start&#123;</div><div class="line">		System.out.println(<span class="string">"启动汽车"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarTest</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">		Engine engine = <span class="keyword">new</span> Engine();</div><div class="line">		List&lt;Wheel&gt; wheels = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</div><div class="line">			wheels.add(<span class="keyword">new</span> Wheel());</div><div class="line">		&#125;</div><div class="line">		Car car = <span class="keyword">new</span> Car(engine, wheels);</div><div class="line">		car.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方案A：由于没有依赖注入，因此需要我们自己是在Car的构造函数中创建Engine和Wheel对象。</p>
<p>方案B：我们手动以构造函数的方式注入依赖，将engine和wheels作为参数传入而不是在Car的构造函数中去显示的创建。</p>
<p>方案A明显丧失了灵活性，一切依赖都是在Car类的内部创建，Car与Engine和Wheel严重耦合。一旦Engine或者Wheel的创建方式发生了改变，我们就必须要去修改Car类的构造函数（比如说现在创建Wheel实例的构造函数改变了，需要传入Rubber（橡胶）了）；另外我们也没办法替换动态的替换依赖实例（比如我们想把Car的Wheel（轮胎）从邓禄普（轮胎品牌）换成米其林（轮胎品牌）的）。这类问题在大型的商业项目中则更加严重，往往A依赖B、B依赖C、C依赖D、D依赖E；一旦稍有改动便牵一发而动全身，想想都可怕！而依赖注入则很好的帮我们解决了这一问题。</p>
<h2 id="为什么是Dagger2"><a href="#为什么是Dagger2" class="headerlink" title="为什么是Dagger2"></a>为什么是Dagger2</h2><p>无论是构造函数注入还是接口注入，都避免不了要编写大量的模板代码。机智的猿猿们当然不开心做这些重复性的工作，于是各种依赖注入框架应用而生。但是这么多的依赖注入框架为什么我们却偏爱Dagger2呢？我们先从Spring中的控制反转（IOC）说起。</p>
<p>谈起依赖注入，做过J2EE开发的同学一定会想起Spring IOC，那通过迷之XML来配置依赖的方式真的很让人讨厌；而且XML与Java代码分离也导致代码链难以追踪。之后更加先进的Guice（Android端也有个RoboGuice）出现了，我们不再需要通过XML来配置依赖，但其运行时实现注入的方式让我们在追踪和定位错误的时候却又万分痛苦。开篇提到过Dagger就是受Guice的启发而开发出来的；Dagger继承了前辈的思想，在性能又碾压了它的前辈Guice，可谓是长江后浪推前浪，前浪死在沙滩上。</p>
<p>又如开篇我在简介中说到的，Dagger是一种半静态半运行时的DI框架，虽说依赖注入是完全静态的，但是生成有向无环图(DAG)还是基于反射来实现，这无论在大型的服务端应用还是在Android应用上都不是最优方案。升级版的Dagger2解决了这一问题，从半静态变为完全静态，从Map式的API变成申明式API（@Module），生成的代码更优雅高效；而且一旦出错我们在编译期间就能发现。所以Dagger2对开发者的更加友好了，当然Dagger2也因此丧失了一些灵活性，但总体来说利还是远远大于弊的。</p>
<p>前面提到这种A B C D E连续依赖的问题，一旦E的创建方式发生了改变就会引发连锁反应，可能会导致A B C D都需要做针对性的修改；但是骚年，你以为为这仅仅是工作量的问题吗？更可怕的是我们创建A时需要按顺序先创建E D C B四个对象，而且必须保证顺序上是正确的。Dagger2就很好的解决了这一问题（不只是Dagger2，在其他DI框架中开发者同样不需要关注这些问题）。</p>
<h2 id="Dagger2注解"><a href="#Dagger2注解" class="headerlink" title="Dagger2注解"></a>Dagger2注解</h2><p>开篇我们就提到Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。</p>
<ul>
<li><p>@Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；</p>
</li>
<li><p>@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。</p>
</li>
<li><p>@Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；</p>
</li>
<li><p>@Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入；</p>
</li>
<li><p>@Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。—-一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；</p>
</li>
<li><p>@Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例；</p>
</li>
<li><p>@Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。</p>
</li>
</ul>
<p>我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下：</p>
<ul>
<li>步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。</li>
<li>步骤2：若存在提供依赖的方法，查看该方法是否存在参数。<ul>
<li>a：若存在参数，则按从步骤1开始依次初始化每个参数；</li>
<li>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
</ul>
</li>
<li>步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。<ul>
<li>a：若存在参数，则从步骤1开始依次初始化每一个参数</li>
<li>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
</ul>
</li>
</ul>
<h2 id="Dagger2使用入门"><a href="#Dagger2使用入门" class="headerlink" title="Dagger2使用入门"></a>Dagger2使用入门</h2><p>前面长篇大论的基本都在介绍概念，下面我们看看Dagger2的基本应用。关于Dagger2的依赖配置就不在这里占用篇幅去描述了，大家可以到它的github主页下去查看官方教程<a href="https://github.com/google/dagger" target="_blank" rel="external">https://github.com/google/dagger</a>。接下来我们还是拿前面的Car和Engine来举例。</p>
<h3 id="1-案例A"><a href="#1-案例A" class="headerlink" title="1. 案例A"></a>1. 案例A</h3><p>Car类是需求依赖方，依赖了Engine类；因此我们需要在类变量Engine上添加@Inject来告诉Dagger2来为自己提供依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine engine;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engine;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Engine类是依赖提供方，因此我们需要在它的构造函数上添加@Inject</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine()&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"引擎转起来了~~~"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们需要创建一个用@Component标注的接口CarComponent，这个CarComponent其实就是一个注入器，这里用来将Engine注入到Car中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成这些之后我们需要Build下项目，让Dagger2帮我们生成相关的Java类。接着我们就可以在Car的构造函数中调用Dagger2生成的DaggerCarComponent来实现注入（这其实在前面Car类的代码中已经有了体现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">    DaggerCarComponent.builder().build().inject(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-案例B"><a href="#2-案例B" class="headerlink" title="2. 案例B"></a>2. 案例B</h3><p><strong>如果创建Engine的构造函数是带参数的呢？比如说制造一台引擎是需要齿轮(Gear)的。或者Eggine类是我们无法修改的呢？这时候就需要@Module和@Provide上场了。</strong></p>
<p>同样我们需要在Car类的成员变量Engine上加上@Inject表示自己需要Dagger2为自己提供依赖；Engine类的构造函数上的@Inject也需要去掉，应为现在不需要通过构造函数上的@Inject来提供依赖了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine engine;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engine;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们需要一个Module类来生成依赖对象。前面介绍的@Module就是用来标准这个类的，而@Provide则是用来标注具体提供依赖对象的方法（这里有个不成文的规定，被@Provide标注的方法命名我们一般以provide开头，这并不是强制的但有益于提升代码的可读性）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span> <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们还需要对CarComponent进行一点点修改，之前的@Component注解是不带参数的，现在我们需要加上<code>modules = {MarkCarModule.class}</code>，用来告诉Dagger2提供依赖的是<code>MarkCarModule</code>这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Car类的构造函数我们也需要修改，相比之前多了个<code>markCarModule(new MarkCarModule())</code>方法，这就相当于告诉了注入器<code>DaggerCarComponent</code>把<code>MarkCarModule</code>提供的依赖注入到了Car类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">   DaggerCarComponent.builder()</div><div class="line">           .markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">           .build().inject(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一个最最基本的依赖注入就完成了，接下来我们测试下我们的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line">    car.getEngine().run();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">引擎转起来了~~~</div></pre></td></tr></table></figure>
<h3 id="3-案例C"><a href="#3-案例C" class="headerlink" title="3. 案例C"></a>3. 案例C</h3><p>那么如果一台汽车有两个引擎（也就是说Car类中有两个Engine变量）怎么办呢？没关系，我们还有@Qulifier！首先我们需要使用Qulifier定义两个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> QualifierA &#123; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> QualifierB &#123; &#125;</div></pre></td></tr></table></figure>
<p>同时我们需要对依赖提供方做出修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierA</span></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngineA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gearA"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierB</span></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngineB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gearB"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来依赖需求方Car类同样需要修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierA</span> <span class="meta">@Inject</span> Engine engineA;</div><div class="line">    <span class="meta">@QualifierB</span> <span class="meta">@Inject</span> Engine engineB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineA;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineB;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们再对Engine类做些调整方便测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String gear;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String gear)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.gear = gear;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGearName</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"GearName:"</span> + gear);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line">    car.getEngineA().printGearName();</div><div class="line">    car.getEngineB().printGearName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GearName:gearA</div><div class="line">GearName:gearB</div></pre></td></tr></table></figure>
<h3 id="4-案例D"><a href="#4-案例D" class="headerlink" title="4. 案例D"></a>4. 案例D</h3><p>接下来我们看看@Scope是如何限定作用域，实现局部单例的。</p>
<p>首先我们需要通过@Scope定义一个CarScope注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scope</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CarScope &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们需要用这个@CarScope去标记依赖提供方MarkCarModule。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@CarScope</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时还需要使用@Scope去标注注入器Compoent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CarScope</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了便于测试我们对Car和Engine类做了一些改造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span> Engine engineA;</div><div class="line">    <span class="meta">@Inject</span> Engine engineB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder()</div><div class="line">                .markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String gear;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String gear)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Create Engine"</span>);</div><div class="line">        <span class="keyword">this</span>.gear = gear;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们不适用@Scope,上面的代码会实例化两次Engine类，因此会有两次\”Create Engine\”输出。现在我们在有@Scope的情况测试下劳动成果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line"></div><div class="line">    System.out.println(car.engineA.hashCode());</div><div class="line">    System.out.println(car.engineB.hashCode());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Create Engine</div></pre></td></tr></table></figure>
<p>bingo！我们确实通过@Scope实现了局部的单例。</p>
<h2 id="Dagger2原理分析"><a href="#Dagger2原理分析" class="headerlink" title="Dagger2原理分析"></a>Dagger2原理分析</h2><p>前面啰里啰嗦的介绍了Dagger2的基本使用，接下来我们再分析分析实现原理。这里不会分析Dagger2根据注解生成各种代码的原理，关于Java注解以后有机会再写一篇文章来介绍。后面主要分析的是Dagger2生成的各种类如何帮我们实现依赖注入，为了便于理解我这里选了前面相对简单的<strong>案例B</strong>来做分析。</p>
<p>Dagger2编译期生成的代码位于<code>build/generated/source/apt/debug/your package name/</code>下面:<br><img src="http://ocjtywvav.bkt.clouddn.com/Blog/OpenSource/Android/Dagger2/generated_code.png" alt="Generated Code"></p>
<p>首先我们看看Dagger2依据依赖提供方<code>MarkCarModule</code>生成的对应工厂类<code>MarkCarModule_ProvideEngineFactory</code>。为了方便大家理解对比，后面我一律会把自己写的类和Dagger2生成的类一并放出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 我们自己的类</div><div class="line">*/</div><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span> <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Dagger2生成的工厂类</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule_ProvideEngineFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Engine</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MarkCarModule <span class="keyword">module</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule_ProvideEngineFactory</span><span class="params">(MarkCarModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> <span class="keyword">module</span> != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = <span class="keyword">module</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Engine <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">        <span class="keyword">module</span>.provideEngine(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Engine&gt; <span class="title">create</span><span class="params">(MarkCarModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarkCarModule_ProvideEngineFactory(<span class="keyword">module</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Proxies &#123;<span class="doctag">@link</span> MarkCarModule#provideEngine()&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Engine <span class="title">proxyProvideEngine</span><span class="params">(MarkCarModule instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance.provideEngine();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到<code>MarkCarModule_ProvideEngineFactory</code>中的get()调用了<code>MarkCarModule</code>的<code>provideEngine()</code>方法来获取我们需要的依赖<code>Engine</code>，<code>MarkCarModule_ProvideEngineFactory</code>的实例化有<code>crate()</code>创建，并且<code>MarkCarModule</code>的实例也是通过<code>create()</code>方法传进来的。那么这个<code>create()</code>一定会在哪里调用的，我们接着往下看。</p>
<p>前面提到@Component是依赖提供方(MarkCarModule)和依赖需求方(Car)之前的桥梁，那我看看Dagger2是如何通过CarComponent将两者联系起来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 我们自己的类</div><div class="line">*/</div><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Dagger2生成的CarComponent实现类</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerCarComponent</span> <span class="keyword">implements</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Engine&gt; provideEngineProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;Car&gt; carMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerCarComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CarComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.provideEngineProvider = MarkCarModule_ProvideEngineFactory.create(builder.markCarModule);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.carMembersInjector = Car_MembersInjector.create(provideEngineProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span> </span>&#123;</div><div class="line">    carMembersInjector.injectMembers(car);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MarkCarModule markCarModule;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> CarComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (markCarModule == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.markCarModule = <span class="keyword">new</span> MarkCarModule();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerCarComponent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">markCarModule</span><span class="params">(MarkCarModule markCarModule)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.markCarModule = Preconditions.checkNotNull(markCarModule);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码我们看到Dagger2依据<code>CarComponent</code>接口生成了实现类<code>DaggerCarComponent</code>（没错这正是我们在Car的构造函数中使用DaggerCarComponent）。<code>DaggerCarComponent</code>在build的时候实例化了<code>DaggerCarComponent</code>对象，并首先调用<code>MarkCarModule_ProvideEngineFactory.create(builder.markCarModule)</code>始化了<code>provideEngineProvider</code>变量，接着调用<code>Car_MembersInjector.create(provideEngineProvider)</code>初始化了<code>carMembersInjector</code>变量。当我们手动在Car类的构造函数中调用<code>inject(Car car)</code>方法时会执行<code>carMembersInjector.injectMembers(car)</code>。所以接下来我们要看看<code>Car_MembersInjector</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Car_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;Engine&gt; engineProvider;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car_MembersInjector</span><span class="params">(Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> engineProvider != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.engineProvider = engineProvider;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MembersInjector&lt;Car&gt; <span class="title">create</span><span class="params">(Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car_MembersInjector(engineProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(Car instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</div><div class="line">    &#125;</div><div class="line">    instance.engine = engineProvider.get();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectEngine</span><span class="params">(Car instance, Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    instance.engine = engineProvider.get();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Car_MembersInjector</code>中的<code>create()</code>用于实例化自己，这个方法前面我们看到是在<code>DaggerCarComponent</code>中调用的。<code>injectMembers(Car instance)</code>将<code>engineProvider.get()</code>的返回值赋给了依赖需求方Car的engine变量，而<code>engineProvider.get()</code>正是本节一开始我们提到的<code>MarkCarModule_ProvideEngineFactory</code>中的<code>get()</code>方法。至此整个依赖注入的流程就完成了。更复杂的应用场景会生成更加复杂的代码，但原理都和前面分析的大同小异。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章只是通过一些简单的例子介绍了Dagger2的相关概念及使用，实际项目中的应用远比这里的例子要复杂。关于Dagger2在实际项目中的应用可以参照这个开源项目 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">https://github.com/BaronZ88/MinimalistWeather</a>（项目采用MVP架构，其中View层和Presenter层的解耦就是通过Dagger2来实现的）。</p>
<blockquote>
<p><a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>是一款开源天气App，开发此项目主要是为展示各种开源库的使用方式以及Android项目的架构方案，并作为团队开发规范的一部分。项目中每一个字母、每一个命名、每一行代码都是经过仔细考究的；但是由于时间精力有限，项目UI未做严格要求。本着精益求精、提供更好开源项目和更美天气应用的原则，因此期望有兴趣的开发和UED同学可以一起来完成这个项目。</p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。&lt;/p&gt;
&lt;p&gt;Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。&lt;/p&gt;
&lt;p&gt;起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenSource" scheme="http://baronzhang.com/categories/OpenSource/"/>
    
      <category term="Java" scheme="http://baronzhang.com/categories/OpenSource/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="依赖注入" scheme="http://baronzhang.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="开源框架" scheme="http://baronzhang.com/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E4%B8%80%E4%B8%AARxJava%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例/</id>
    <published>2017-02-05T16:30:27.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：</p>
<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>拿<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>这个开源的天气App来举例：</p>
<a id="more"></a>
<p>进入App首页后，首先我们需要从数据库中获取当前城市的天气数据，如果数据库中存在天气数据则在UI页面上展示天气数据；如果数据库中未存储当前城市的天气数据，或者已存储的天气数据的发布时间相比现在已经超过了一小时，并且网络属于连接状态则调用API从服务端获取天气数据。如果获取到到的天气数据发布时间和当前数据库中的天气数据发布时间一致则丢弃掉从服务端获取到的天气数据，如果不一致则更新数据库并且在页面上展示最新的天气信息。（同时天气数据源是可配置的，可选择是小米天气数据源还是Know天气数据源）</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先我们需要创建一个从数据库获取天气数据的Observable <code>observableForGetWeatherFromDB</code>，同时我们也需要创建一个从API获取天气数据的Observable <code>observableForGetWeatherFromNetWork</code>；为了在无网络状态下免于创建<code>observableForGetWeatherFromNetWork</code>我们在这之前需要首先判断下网络状态。最后使用<code>contact</code>操作符将两个Observable合并，同时使用<code>distinct</code>和<code>takeUntil</code>操作符来过滤筛选数据以符合业务需求，然后结合<code>subscribeOn</code>和<code>observeOn</code>做线程切换。上述这一套复杂的业务逻辑如果使用传统编码方式将是极其复杂的。下面我们来看看使用RxJava如何清晰简洁的来实现这个复杂的业务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class="line"><span class="comment">//首先创建一个从数据库获取天气数据的Observable</span></div><div class="line">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Weather weather = weatherDao.queryWeather(cityId);</div><div class="line">            subscriber.onNext(weather);</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class="line">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//接着创建一个从网络获取天气数据的Observable</span></div><div class="line">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span> (configuration.getDataSourceType()) &#123;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class="line">                    .map(<span class="keyword">new</span> Func1&lt;KnowWeather, Weather&gt;() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> Weather <span class="title">call</span><span class="params">(KnowWeather knowWeather)</span> </span>&#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> KnowWeatherAdapter(knowWeather).getWeather();</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class="line">                    .map(<span class="keyword">new</span> Func1&lt;MiWeather, Weather&gt;() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> Weather <span class="title">call</span><span class="params">(MiWeather miWeather)</span> </span>&#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> MiWeatherAdapter(miWeather).getWeather();</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> observableForGetWeatherFromNetWork != <span class="keyword">null</span>;</div><div class="line">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class="line">            .doOnNext(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            weatherDao.insertOrUpdateWeather(weather);</div><div class="line">                        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//使用concat操作符将两个Observable合并</span></div><div class="line">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class="line">            .filter(<span class="keyword">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> weather != <span class="keyword">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId());</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .distinct(<span class="keyword">new</span> Func1&lt;Weather, Long&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> weather.getRealTime().getTime();<span class="comment">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .takeUntil(<span class="keyword">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;<span class="comment">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                displayWeatherInformation();</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">                Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>上面的代码看起来比较复杂，我们采用Lambda表达式简化下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class="line"><span class="comment">//首先创建一个从数据库获取天气数据的Observable</span></div><div class="line">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Weather weather = weatherDao.queryWeather(cityId);</div><div class="line">            subscriber.onNext(weather);</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class="line">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//接着创建一个从网络获取天气数据的Observable</span></div><div class="line">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span> (configuration.getDataSourceType()) &#123;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class="line">                    .map(knowWeather -&gt; <span class="keyword">new</span> KnowWeatherAdapter(knowWeather).getWeather());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class="line">                    .map(miWeather -&gt; <span class="keyword">new</span> MiWeatherAdapter(miWeather).getWeather());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> observableForGetWeatherFromNetWork != <span class="keyword">null</span>;</div><div class="line">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class="line">            .doOnNext(weather -&gt; Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    weatherDao.insertOrUpdateWeather(weather);</div><div class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">                &#125;</div><div class="line">            &#125;));</div><div class="line"></div><div class="line">    <span class="comment">//使用concat操作符将两个Observable合并</span></div><div class="line">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class="line">            .filter(weather -&gt; weather != <span class="keyword">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId()))</div><div class="line">            .distinct(weather -&gt; weather.getRealTime().getTime())<span class="comment">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class="line">            .takeUntil(weather -&gt; System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);<span class="comment">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(weather -&gt; displayWeatherInformation(),</div><div class="line">                throwable -&gt; Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show());</div></pre></td></tr></table></figure>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>在上述的实现中有几点是我们需要注意的:</p>
<ol>
<li><p>为什么我需要在判断网络那块整个if else？这样看起来很不优雅，我们通过RxJava符完全可以实现同样的操作啊！之所以这样做是为了在无网络状况下去创建不必要的Observable <code>observableForGetWeatherFromNetWork</code>;</p>
</li>
<li><p>更新数据库的操作不应该阻塞更新UI，因此我们在<code>observableForGetWeatherFromNetWork</code>的<code>doOnNext</code>中需要通过<code>Schedulers.io().createWorker()</code>去另起一条线程，以此保证更新数据库不会阻塞更新UI的操作。</p>
<blockquote>
<p>有同学可能会问为什么不在<code>doOnNext</code>之后再调用一次<code>observeOn</code>把更新数据库的操作切换到一条新的子线程去操作呢？其实一开始我也是这样做的，后来想想不对。整个Observable的事件传递处理就像是在一条流水线上完成的，虽然我们可以通过<code>observeOn</code>来指定子线程去处理更新数据库的操作，但是只有等这条子线程完成了更新数据库的任务后事件才会继续往后传递，这样就阻塞了更新UI的操作。对此有疑问的同学可以去看看我之前关于RxJava源码分析的文章或者自己动手debug看看。</p>
</blockquote>
</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最后给大家留个两个问题：</p>
<ol>
<li>上述代码是最佳实现方案吗？还有什么更加合理的做法？</li>
<li>我们在<code>observableForGetWeatherData</code>中使用<code>distinct</code>和<code>takeUntil</code>过滤筛选天气数据的时候网络请求会不会已经发出去了？这样做还有意义吗？</li>
</ol>
<p>欢迎大家留言讨论。</p>
<blockquote>
<p>本文中的代码在<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>中的<code>WeatherDataRepository</code>类中有同样的实现，文章中为了更完整的将整个实现过程呈现出来，对代码做了部分改动。</p>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h2&gt;&lt;p&gt;拿&lt;a href=&quot;https://github.com/BaronZ88/MinimalistWeather&quot;&gt;MinimalistWeather&lt;/a&gt;这个开源的天气App来举例：&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列7(最佳实践)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%977-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列7-最佳实践/</id>
    <published>2017-02-05T16:22:03.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。</p>
<blockquote>
<p>按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。</p>
</blockquote>
<a id="more"></a>
<h2 id="示例一、获取手机上已安装的App"><a href="#示例一、获取手机上已安装的App" class="headerlink" title="示例一、获取手机上已安装的App"></a>示例一、获取手机上已安装的App</h2><p>第一个例子我们需要在Android设备上展示已安装的第三方app列表，关于环境搭建、依赖配置、RecyclerView的使用等这些基础内容我就不做陈述了。需要了解的同学可以去GitHub上把项目clone下来看看。这里我主要讲讲如何通过RxJava实现核心功能。</p>
<p>首选我们需要调用系统api来获取所有已安装的app，所以在<code>OnSubscribe</code>的<code>call</code>方法中调用<code>getApplicationInfoList()</code>。但是<code>getApplicationInfoList()</code>获取的数据并不能完全满足我们的业务需求：</p>
<ol>
<li>由于我们只需要展示手机上已安装的第三方App，因此需要通过<code>filter</code>操作符来过滤掉系统app；</li>
<li><code>ApplicationInfo</code>并不是我们所需要的类型，因此需要通过<code>map</code>操作符将其转换为<code>AppInfo</code>；</li>
<li>由于获取<code>ApplicationInfo</code>、过滤数据、转换数据相对比较耗时，因此需要通过<code>subscribeOn</code>操作符将这一系列操作放到子线程中来处理；</li>
<li>而要将信息展示在页面上涉及到UI操作，因此需要通过<code>observeOn</code>操作符将<code>onNext</code>、<code>onCompleted</code>、<code>onError</code>调度到主线程，接着我们在这些方法中更新UI。</li>
</ol>
<p>下面是核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> PackageManager pm = MainActivity.<span class="keyword">this</span>.getPackageManager();</div><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;ApplicationInfo&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> ApplicationInfo&gt; subscriber)</span> </span>&#123;</div><div class="line">            List&lt;ApplicationInfo&gt; infoList = getApplicationInfoList(pm);</div><div class="line">            <span class="keyword">for</span> (ApplicationInfo info : infoList) &#123;</div><div class="line">                subscriber.onNext(info);</div><div class="line">            &#125;</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125;</div><div class="line">    &#125;).filter(<span class="keyword">new</span> Func1&lt;ApplicationInfo, Boolean&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;).map(<span class="keyword">new</span> Func1&lt;ApplicationInfo, AppInfo&gt;() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> AppInfo <span class="title">call</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class="line">            AppInfo info = <span class="keyword">new</span> AppInfo();</div><div class="line">            info.setAppIcon(applicationInfo.loadIcon(pm));</div><div class="line">            info.setAppName(applicationInfo.loadLabel(pm).toString());</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125;</div><div class="line">    &#125;).subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;AppInfo&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            mAppListAdapter.notifyDataSetChanged();</div><div class="line">            mPullDownSRL.setRefreshing(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            mPullDownSRL.setRefreshing(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</div><div class="line">            mAppInfoList.add(appInfo);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>程序执行效果图：</p>
<div align="left"><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/7/pic1.png" width="38%" alt="图片名称" align="center"></div>

<p>完整的代码我放到了GitHub上，有兴趣大家可以去clone下来自己运行看看。</p>
<p>源码地址：<a href="https://github.com/BaronZ88/HelloRxAndroid" target="_blank" rel="external">https://github.com/BaronZ88/HelloRxAndroid</a></p>
<h2 id="示例二、RxJava-Retrofit2实现获取天气数据"><a href="#示例二、RxJava-Retrofit2实现获取天气数据" class="headerlink" title="示例二、RxJava+Retrofit2实现获取天气数据"></a>示例二、RxJava+Retrofit2实现获取天气数据</h2><p>RxJava + Retrofit2几乎是Android应用开发的标配了，这个例子中我们就来聊聊这二者是如何配合起来帮助我们快速开发的。</p>
<p>Retrofit2中一个标准的接口定义是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"weather"</span>)</div><div class="line"><span class="function">Observable&lt;Weather&gt; <span class="title">getWeather</span><span class="params">(@Query(<span class="string">"cityId"</span>)</span> String cityId)</span>;</div></pre></td></tr></table></figure>
<p>现在有了RxJava，一个基本的网络请求我们便可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ApiClient.weatherService.getWeather(cityId)</div><div class="line">             	.subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                        weatherView.displayWeatherInformation(weather);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<p>但有时候可能一开始我们并不知道cityId，我们只知道cityName。所以就需要我们先访问服务器，拿到对应城市名的cityId，然后通过这个cityId再去获取天气数据。</p>
<p>同样的，我们需要定义一个获取cityId的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"city"</span>)</div><div class="line"><span class="function">Observable&lt;String&gt; <span class="title">getCityIdByName</span><span class="params">(@Query(<span class="string">"cityName"</span>)</span> String cityName)</span>;</div></pre></td></tr></table></figure>
<p>紧接着我们便可以使用无所不能的RxJava来实现需求了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ApiClient.weatherService.getCityIdByName(<span class="string">"上海"</span>)</div><div class="line">			 .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;Weather&gt;&gt;() &#123;</div><div class="line">			     <span class="meta">@Override</span></div><div class="line">			     <span class="function"><span class="keyword">public</span> Observable&lt;Weather&gt; <span class="title">call</span><span class="params">(String cityId)</span> </span>&#123;</div><div class="line">			         <span class="keyword">return</span> ApiClient.weatherService.getWeather(cityId);</div><div class="line">			     &#125;</div><div class="line">			 &#125;).subscribeOn(Schedulers.io())</div><div class="line">			 .observeOn(AndroidSchedulers.mainThread())</div><div class="line">			 .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">			     <span class="meta">@Override</span></div><div class="line">			     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">			         weatherView.displayWeatherInformation(weather);</div><div class="line">			     &#125;</div><div class="line">			 &#125;);</div></pre></td></tr></table></figure>
<p>哇哦！~ so easy！！！妈妈再也不用担心….</p>
<p>源码地址：<a href="https://github.com/BaronZ88/WeatherStyle" target="_blank" rel="external">https://github.com/BaronZ88/WeatherStyle</a></p>
<blockquote>
<p><a href="(https://github.com/BaronZ88/WeatherStyle">WeatherStyle</a>)这个项目还在开发中，这个项目不只包含了RxJava和Retrofit的使用，同时还包含MVP、ORMLite、RetroLambda、ButterKnife等等开源库的使用</p>
</blockquote>
<p>RxJava1.X的系列文章就到此结束了，由于本人对RxJava的理解有限，这一系列文章中如有错误还请大家指正。在使用RxJava过程中有任何疑问也欢迎大家和我交流。共同学习！共同进步！</p>
<p>好啦，我们RxJava2见！~</p>
<hr>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列6(从微观角度解读RxJava源码)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%976-%E4%BB%8E%E5%BE%AE%E8%A7%82%E8%A7%92%E5%BA%A6%E8%A7%A3%E8%AF%BBRxJava%E6%BA%90%E7%A0%81/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/</id>
    <published>2017-02-05T16:21:05.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：</p>
<ul>
<li>RxJava基本流程分析</li>
<li>操作符原理分析</li>
<li>线程调度原理分析</li>
</ul>
<blockquote>
<p>本章节基于<strong>RxJava1.1.9</strong>版本的源码</p>
</blockquote>
<h2 id="一、RxJava执行流程分析"><a href="#一、RxJava执行流程分析" class="headerlink" title="一、RxJava执行流程分析"></a>一、RxJava执行流程分析</h2><p>在<a href="http://www.jianshu.com/p/ba61c047c230" target="_blank" rel="external">RxJava系列2(基本概念及使用介绍)</a>中我们介绍过，一个最基本的RxJava调用是这样的：</p>
<a id="more"></a>
<p><strong>示例A</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello RxJava!"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"completed!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>首先调用<code>Observable.create()</code>创建一个被观察者<code>Observable</code>，同时创建一个<code>OnSubscribe</code>作为<code>create()</code>方法的入参；接着创建一个观察者<code>Subscriber</code>，然后通过<code>subseribe()</code>实现二者的订阅关系。这里涉及到三个关键对象和一个核心的方法：</p>
<ul>
<li><strong>Observable</strong>（被观察者）</li>
<li><strong>OnSubscribe</strong> (从纯设计模式的角度来理解，<code>OnSubscribe.call()</code>可以看做是<a href="https://github.com/BaronZ88/Blog/blob/master/DesignPatterns/ObserverPattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="external">观察者模式</a>中被观察者用来通知观察者的<code>notifyObservers()</code>方法)</li>
<li><strong>Subscriber</strong> （观察者）</li>
<li><strong>subscribe()</strong> （实现观察者与被观察者订阅关系的方法）</li>
</ul>
<h3 id="1-Observable-create-源码分析"><a href="#1-Observable-create-源码分析" class="headerlink" title="1. Observable.create()源码分析"></a>1. Observable.create()源码分析</h3><p>首先我们来看看<code>Observable.create()</code>的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建了一个被观察者<code>Observable</code>，同时将<code>RxJavaHooks.onCreate(f)</code>作为构造函数的参数，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.onSubscribe = f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到源码中直接将参数<code>RxJavaHooks.onCreate(f)</code>赋值给了当前我们构造的被观察者<code>Observable</code>的成员变量<code>onSubscribe</code>。那么<code>RxJavaHooks.onCreate(f)</code>返回的又是什么呢？我们接着往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observable.<span class="function">OnSubscribe&lt;T&gt; <span class="title">onCreate</span><span class="params">(Observable.OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</div><div class="line">    Func1&lt;OnSubscribe, OnSubscribe&gt; f = onObservableCreate;</div><div class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> f.call(onSubscribe);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onSubscribe;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我们并没调用<code>RxJavaHooks.initCreate()</code>，所以上面代码中的<code>onObservableCreate</code>为null；因此<code>RxJavaHooks.onCreate(f)</code>最终返回的就是<code>f</code>，也就是我们在<code>Observable.create()</code>的时候new出来的<code>OnSubscribe</code>。（<em>由于对RxJavaHooks的理解并不影响我们对RxJava执行流程的分析，因此在这里我们不做进一步的探讨。为了方便理解我们只需要知道RxJavaHooks一系列方法的返回值就是入参本身就OK了，例如这里的<code>RxJavaHooks.onCreate(f)</code>返回的就是<code>f</code></em>）。</p>
<p>至此我们做下逻辑梳理：<strong><code>Observable.create()</code>方法构造了一个被观察者<code>Observable</code>对象，同时将new出来的<code>OnSubscribe</code>赋值给了该<code>Observable</code>的成员变量<code>onSubscribe</code>。</strong></p>
<h3 id="2-Subscriber源码分析"><a href="#2-Subscriber源码分析" class="headerlink" title="2. Subscriber源码分析"></a>2. Subscriber源码分析</h3><p>接着我们看下观察者<code>Subscriber</code>的源码，为了增加可读性，我去掉了源码中的注释和部分代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscriptionList subscriptions;<span class="comment">//订阅事件集，所有发送给当前Subscriber的事件都会保存在这里</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Subscriber</span><span class="params">(Subscriber&lt;?&gt; subscriber, <span class="keyword">boolean</span> shareSubscriptions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subscriber = subscriber;</div><div class="line">        <span class="keyword">this</span>.subscriptions = shareSubscriptions &amp;&amp; subscriber != <span class="keyword">null</span> ? subscriber.subscriptions : <span class="keyword">new</span> SubscriptionList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</div><div class="line">        subscriptions.unsubscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isUnsubscribed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> subscriptions.isUnsubscribed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isUnsubscribed</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Subscriber</code>实现了<code>Subscription</code>接口，从而对外提供<code>isUnsubscribed()</code>和<code>unsubscribe()</code>方法。前者用于判断是否已经取消订阅；后者用于将订阅事件列表(<em>也就是当前观察者的成员变量<code>subscriptions</code></em>)中的所有<code>Subscription</code>取消订阅，并且不再接受观察者<code>Observable</code>发送的后续事件。</p>
<h3 id="3-subscribe-源码分析"><a href="#3-subscribe-源码分析" class="headerlink" title="3. subscribe()源码分析"></a>3. subscribe()源码分析</h3><p>前面我们分析了观察者和被观察者相关的源码，那么接下来便是整个订阅流程中最最关键的环节了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">    subscriber.onStart();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</div><div class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>subscribe()</code>方法中将传进来的<code>subscriber</code>包装成了<code>SafeSubscriber</code>，<code>SafeSubscriber</code>其实是<code>subscriber</code>的一个代理，对<code>subscriber</code>的一系列方法做了更加严格的安全校验。保证了<code>onCompleted()</code>和<code>onError()</code>只会有一个被执行且只执行一次，一旦它们其中方法被执行过后<code>onNext()</code>就不在执行了。</p>
<p>上述代码中最关键的就是<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber)</code>。这里的RxJavaHooks和之前提到的一样，<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe)</code>返回的正是他的第二个入参<code>observable.onSubscribe</code>，也就是当前<code>observable</code>的成员变量<code>onSubscribe</code>。而这个成员变量我们前面提到过，它是我们在<code>Observable.create()</code>的时候new出来的。所以这段代码可以简化为<code>onSubscribe.call(subscriber)</code>。这也印证了我在<a href="http://www.jianshu.com/p/ba61c047c230" target="_blank" rel="external">RxJava系列2(基本概念及使用介绍)</a>中说的，<code>onSubscribe.call(subscriber)</code>中的<code>subscriber</code>正是我们在<code>subscribe()</code>方法中new出来的观察者。</p>
<p>到这里，我们对RxJava的执行流程做个总结：首先我们调用<code>crate()</code>创建一个观察者，同时创建一个<code>OnSubscribe</code>作为该方法的入参；接着调用<code>subscribe()</code>来订阅我们自己创建的观察者<code>Subscriber</code>。<br>一旦调用<code>subscribe()</code>方法后就会触发执行<code>OnSubscribe.call()</code>。然后我们就可以在call方法调用观察者<code>subscriber</code>的<code>onNext()</code>,<code>onCompleted()</code>,<code>onError()</code>。</p>
<p>最后我用张图来总结下之前的分析结果：</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess1.jpg" alt="RxJava基本流程分析"></p>
<h2 id="二、操作符原理分析"><a href="#二、操作符原理分析" class="headerlink" title="二、操作符原理分析"></a>二、操作符原理分析</h2><p>之前我们介绍过几十个操作符，要一一分析它们的源码显然不太现实。在这里我抛砖引玉，选取一个相对简单且常用的<code>map</code>操作符来分析。</p>
<p>我们先来看一个<code>map</code>操作符的简单应用：</p>
<p><strong>示例B</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="number">1</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"This is "</span> + integer;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onCompleted!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(e.getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了便于表述，我将上面的代码做了如下拆解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; observableA = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="number">1</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Subscriber&lt;String&gt; subscriberOne = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onCompleted!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(e.getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Observable&lt;String&gt; observableB =</div><div class="line">        observableA.map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">"This is "</span> + integer;;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">observableB.subscribe(subscriberOne);</div></pre></td></tr></table></figure>
<p><code>map()</code>的源码和上一小节介绍的<code>create()</code>一样位于<code>Observable</code>这个类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; func)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeMap&lt;T, R&gt;(<span class="keyword">this</span>, func));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过查看源码我们发现调用<code>map()</code>的时候实际上是创建了一个新的被观察者<code>Observable</code>，我们姑且称它为<code>ObservableB</code>；一开始通过<code>Observable.create()</code>创建的<code>Observable</code>我们称之为<code>ObservableA</code>。在创建<code>ObservableB</code>的时候同时创建了一个<code>OnSubscribeMap</code>，而<code>ObservableA</code>和变换函数<code>Func1</code>则作为构造<code>OnSubscribeMap</code>的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;<span class="comment">//ObservableA</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer;<span class="comment">//map操作符中的转换函数Func1。T为转换前的数据类型，在上面的例子中为Integer；R为转换后的数据类型，在该例中为String。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeMap</span><span class="params">(Observable&lt;T&gt; source, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">        <span class="keyword">this</span>.transformer = transformer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;<span class="comment">//结合第一小节的分析结果，我们知道这里的入参o其实就是我们自己new的观察者subscriberOne。</span></div><div class="line">        MapSubscriber&lt;T, R&gt; parent = <span class="keyword">new</span> MapSubscriber&lt;T, R&gt;(o, transformer);</div><div class="line">        o.add(parent);</div><div class="line">        source.unsafeSubscribe(parent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSubscriber</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; actual;<span class="comment">//这里的actual就是我们在调用subscribe()时创建的观察者mSubscriber</span></div><div class="line">        <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;<span class="comment">//变换函数</span></div><div class="line">        <span class="keyword">boolean</span> done;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MapSubscriber</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; actual, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.actual = actual;</div><div class="line">            <span class="keyword">this</span>.mapper = mapper;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">            R result;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                result = mapper.call(t);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                Exceptions.throwIfFatal(ex);</div><div class="line">                unsubscribe();</div><div class="line">                onError(OnErrorThrowable.addValueAsLastCause(ex, t));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            actual.onNext(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            actual.onError(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            actual.onCompleted();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(Producer p)</span> </span>&#123;</div><div class="line">            actual.setProducer(p);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OnSubscribeMap</code>实现了<code>OnSubscribe</code>接口，因此<code>OnSubscribeMap</code>就是一个<code>OnSubscribe</code>。在调用<code>map()</code>的时候创建了一个新的被观察者<code>ObservableB</code>，然后我们用<code>ObservableB.subscribe(subscriberOne)</code>订阅了观察者<code>subscriberOne</code>。结合我们在第一小节的分析结果，所以<code>OnSubscribeMap.call(o)</code>中的<code>o</code>就是<code>subscribe(subscriberOne)</code>中的<code>subscriberOne</code>；一旦调用了<code>ObservableB.subscribe(subscriberOne)</code>就会执行<code>OnSubscribeMap.call()</code>。</p>
<p>在<code>call()</code>方法中，首先通过我们的观察者<code>o</code>和转换函数<code>transformer</code>构造了一个<code>MapSubscriber</code>，最后调用了<code>source</code>也就是<code>observableA</code>的<code>unsafeSubscribe()</code>方法。即<code>observableA</code>订阅了一个观察者<code>MapSubscriber</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">unsafeSubscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ...</div><div class="line">        RxJavaHooks.onObservableStart(<span class="keyword">this</span>, onSubscribe).call(subscriber);</div><div class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码最终执行了<code>onSubscribe</code>也就是<code>OnSubscribeMap</code>的<code>call()</code>方法，<code>call()</code>方法中的参数就是之前在<code>OnSubscribeMap.call()</code>中new出来的<code>MapSubscriber</code>。最后在<code>call()</code>方法中执行了我们自己的业务代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subscriber.onNext(<span class="number">1</span>);</div><div class="line">subscriber.onCompleted();</div></pre></td></tr></table></figure>
<p>其实也就是执行了<code>MapSubscriber</code>的<code>onNext()</code>和<code>onCompleted()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    R result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = mapper.call(t);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    actual.onNext(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>onNext(T t)</code>方法中的的<code>mapper</code>就是变换函数，<code>actual</code>就是我们在调用<code>subscribe()</code>时创建的观察者<code>subscriberOne</code>。这个<code>T</code>就是我们例子中的<code>Integer</code>，<code>R</code>就是<code>String</code>。在<code>onNext()</code>中首先调用变换函数<code>mapper.call()</code>将<code>T</code>转换成<code>R</code>(在我们的例子中就是将<code>Integer</code>类型的<strong>1</strong>转换成了<code>String</code>类型的<strong>“This is 1”</strong>)；接着调用<code>subscriberOne.onNext(String result)</code>。同样在调用<code>MapSubscriber.onCompleted()</code>时会执行<code>subscriberOne.onCompleted()</code>。这样就完成了一直完成的调用流程。</p>
<p>我承认太啰嗦了，花费了这么大的篇幅才将<code>map()</code>的转换原理解释清楚。我也是希望尽量的将每个细节都呈现出来方便大家理解，如果看我啰嗦了这么久还是没能理解，请看下面我画的这张执行流程图。</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess3.jpg" alt="加入Map操作符后的执行流程"></p>
<h2 id="三、线程调度原理分析"><a href="#三、线程调度原理分析" class="headerlink" title="三、线程调度原理分析"></a>三、线程调度原理分析</h2><p>在前面的文章中我介绍过RxJava可以很方便的通过<code>subscribeOn()</code>和<code>observeOn()</code>来指定数据流的每一部分运行在哪个线程。其中<code>subscribeOn()</code>指定了处理<code>Observable</code>的全部的过程(包括发射数据和通知)的线程；<code>observeOn()</code>指定了观察者的<code>onNext()</code>, <code>onError()</code>和<code>onCompleted()</code>执行的线程。接下来我们就分析分析源码，看看线程调度是如何实现的。</p>
<p>在分析源码前我们先看看一段常见的通过RxJava实现的线程调度代码：</p>
<p><strong>示例C</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello RxJava!"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">.observeOn(AndroidSchedulers.mainThread())</div><div class="line">.subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"completed!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="1-subscribeOn-源码分析"><a href="#1-subscribeOn-源码分析" class="headerlink" title="1. subscribeOn()源码分析"></a>1. subscribeOn()源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码我们可以看到，<code>subscribeOn()</code>和<code>map()</code>一样是创建了一个新的被观察者<code>Observable</code>。因此我大致就能猜到<code>subscribeOn()</code>的执行流程应该和<code>map()</code>差不多，<code>OperatorSubscribeOn</code>肯定也是一个<code>OnSubscribe</code>。那我们接下来就看看<code>OperatorSubscribeOn</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Scheduler scheduler;<span class="comment">//线程调度器，用来指定订阅事件发送、处理等所在的线程</span></div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line">        subscriber.add(inner);</div><div class="line"></div><div class="line">        inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">final</span> Thread t = Thread.currentThread();</div><div class="line"></div><div class="line">                Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                        subscriber.onNext(t);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            subscriber.onError(e);</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            inner.unsubscribe();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            subscriber.onCompleted();</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            inner.unsubscribe();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(<span class="keyword">final</span> Producer p)</span> </span>&#123;</div><div class="line">                        subscriber.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">                                <span class="keyword">if</span> (t == Thread.currentThread()) &#123;</div><div class="line">                                    p.request(n);</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                                        <span class="meta">@Override</span></div><div class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                                            p.request(n);</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;);</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">                source.unsafeSubscribe(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorSubscribeOn</code>实现了<code>OnSubscribe</code>接口，<code>call()</code>中对<code>Subscriber</code>的处理也和<code>OperatorMap</code>对<code>Subscriber</code>的处理类似。首先通过<code>scheduler</code>构建了一个<code>Worker</code>；然后用传进来的<code>subscriber</code>构造了一个新的<code>Subscriber s</code>，并将<code>s</code>丢到<code>Worker.schedule()</code>中来处理；最后用原<code>Observable</code>去订阅观察者<code>s</code>。而这个<code>Worker</code>就是线程调度的关键！前面的例子中我们通过<code>subscribeOn(Schedulers.io())</code>指定了<code>Observable</code>发射处理事件以及通知观察者的一系列操作的执行线程，正是通过这个<code>Schedulers.io()</code>创建了我们前面提到的<code>Worker</code>。所以我们来看看<code>Schedulers.io()</code>的实现。</p>
<p>首先通过<code>Schedulers.io()</code>获得了<code>ioScheduler</code>并返回，上面的<code>OperatorSubscribeOn</code>通过这个的<code>Scheduler</code>的<code>createWorker()</code>方法创建了我们前面提到的<code>Worker</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">io</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> RxJavaHooks.onIOScheduler(getInstance().ioScheduler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们看看这个<code>ioScheduler</code>是怎么来的，下面的代码向我们展现了是如何在<code>Schedulers</code>的构造函数中通过<code>RxJavaSchedulersHook.createIoScheduler()</code>来初始化<code>ioScheduler</code>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Schedulers</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    Scheduler io = hook.getIOScheduler();</div><div class="line">    <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</div><div class="line">        ioScheduler = io;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ioScheduler = RxJavaSchedulersHook.createIoScheduler();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终<code>RxJavaSchedulersHook.createIoScheduler()</code>返回了一个<code>CachedThreadScheduler</code>，并赋值给了<code>ioScheduler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">createIoScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> createIoScheduler(<span class="keyword">new</span> RxThreadFactory(<span class="string">"RxIoScheduler-"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">createIoScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CachedThreadScheduler(threadFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这一步既然我们知道了<code>ioScheduler</code>就是一个<code>CachedThreadScheduler</code>，那我们就来看看它的<code>createWorker()</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码向我们赤裸裸的呈现了前面<code>OperatorSubscribeOn</code>中的<code>Worker</code>其实就是<code>EventLoopWorker</code>。我们重点要关注的是他的<code>scheduleActual()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeSubscription innerSubscription = <span class="keyword">new</span> CompositeSubscription();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</div><div class="line">    <span class="keyword">final</span> AtomicBoolean once;</div><div class="line"></div><div class="line">    EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class="line">        <span class="keyword">this</span>.pool = pool;</div><div class="line">        <span class="keyword">this</span>.once = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">        <span class="keyword">this</span>.threadWorker = pool.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        ScheduledAction s = threadWorker.scheduleActual(<span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (isUnsubscribed()) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                action.call();</div><div class="line">            &#125;</div><div class="line">        &#125;, delayTime, unit);</div><div class="line">        innerSubscription.add(s);</div><div class="line">        s.addParent(innerSubscription);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对源码的一步步追踪，我们知道了前面<code>OperatorSubscribeOn.call()</code>中的<code>inner.schedule()</code>最终会执行到<code>ThreadWorker</code>的<code>scheduleActual()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ScheduledAction <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class="line">    Action0 decoratedAction = RxJavaHooks.onScheduledAction(action);</div><div class="line">    ScheduledAction run = <span class="keyword">new</span> ScheduledAction(decoratedAction);</div><div class="line">    Future&lt;?&gt; f;</div><div class="line">    <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</div><div class="line">        f = executor.submit(run);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        f = executor.schedule(run, delayTime, unit);</div><div class="line">    &#125;</div><div class="line">    run.add(f);</div><div class="line">    <span class="keyword">return</span> run;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scheduleActual()</code>中的<code>ScheduledAction</code>实现了<code>Runnable</code>接口，通过线程池<code>executor</code>最终实现了线程切换。上面便是<code>subscribeOn(Schedulers.io())</code>实现线程切换的全部过程。</p>
<h3 id="2-observeOn-源码分析"><a href="#2-observeOn-源码分析" class="headerlink" title="2. observeOn()源码分析"></a>2. observeOn()源码分析</h3><p><code>observeOn()</code>切换线程是通过<code>lift</code>来实现的，相比<code>subscribeOn()</code>在实现原理上相对复杂些。不过本质上最终还是创建了一个新的<code>Observable</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorObserveOn</code>作为<code>OnSubscribeLift</code>构造函数的参数用来创建了一个新的<code>OnSubscribeLift</code>对象，接下来我们看看<code>OnSubscribeLift</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeLift</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; parent;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeLift</span><span class="params">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">        <span class="keyword">this</span>.operator = operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; st = RxJavaHooks.onObservableLift(operator).call(o);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                st.onStart();</div><div class="line">                parent.call(st);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                Exceptions.throwIfFatal(e);</div><div class="line">                st.onError(e);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            Exceptions.throwIfFatal(e);</div><div class="line">            o.onError(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OnSubscribeLift</code>继承自<code>OnSubscribe</code>，通过前面的分析我们知道一旦调用了<code>subscribe()</code>将观察者与被观察绑定后就会触发被观察者所对应的<code>OnSubscribe</code>的<code>call()</code>方法，所以这里会触发<code>OnSubscribeLift.call()</code>。在<code>call()</code>中调用了<code>OperatorObserveOn.call()</code>并返回了一个新的观察者<code>Subscriber st</code>，接着调用了前一级<code>Observable</code>对应<code>OnSubscriber.call(st)</code>。</p>
<p>我们再看看<code>OperatorObserveOn.call()</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">    ...</div><div class="line">    ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">    parent.init();</div><div class="line">    <span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorObserveOn.call()</code>中创建了一个<code>ObserveOnSubscriber</code>并调用<code>init()</code>进行了初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable e)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">            recursiveScheduler.schedule(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> missed = <span class="number">1L</span>;</div><div class="line">        <span class="keyword">long</span> currentEmission = emitted;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="keyword">this</span>.queue;</div><div class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = <span class="keyword">this</span>.child;</div><div class="line">        <span class="keyword">final</span> NotificationLite&lt;T&gt; localOn = <span class="keyword">this</span>.on;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">long</span> requestAmount = requested.get();</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</div><div class="line">                <span class="keyword">boolean</span> done = finished;</div><div class="line">                Object v = q.poll();</div><div class="line">                <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (checkTerminated(done, empty, localChild, q)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (empty) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                localChild.onNext(localOn.getValue(v));</div><div class="line"></div><div class="line">                currentEmission++;</div><div class="line">                <span class="keyword">if</span> (currentEmission == limit) &#123;</div><div class="line">                    requestAmount = BackpressureUtils.produced(requested, currentEmission);</div><div class="line">                    request(currentEmission);</div><div class="line">                    currentEmission = <span class="number">0L</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (requestAmount == currentEmission) &#123;</div><div class="line">                <span class="keyword">if</span> (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            emitted = currentEmission;</div><div class="line">            missed = counter.addAndGet(-missed);</div><div class="line">            <span class="keyword">if</span> (missed == <span class="number">0L</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ObserveOnSubscriber</code>继承自<code>Subscriber</code>，并实现了<code>Action0</code>接口。我们看到<code>ObserveOnSubscriber</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>都有个<code>schedule()</code>，这个方法就是我们线程调度的关键；通过<code>schedule()</code>将新观察者<code>ObserveOnSubscriber</code>发送给<code>subscriberOne</code>的所有事件都切换到了<code>recursiveScheduler</code>所对应的线程，简单的说就是把<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法丢到了<code>recursiveScheduler</code>对应的线程中来执行。</p>
<p>那么<code>schedule()</code>又是如何做到这一点的呢？他内部调用了<code>recursiveScheduler.schedule(this)</code>，<code>recursiveScheduler</code>其实就是一个<code>Worker</code>，和我们在介绍<code>subscribeOn()</code>时提到的<code>worker</code>一样，执行<code>schedule()</code>实际上最终是创建了一个<code>runable</code>，然后把这个<code>runnable</code>丢到了特定的线程池中去执行。在<code>runnable</code>的<code>run()</code>方法中调用了<code>ObserveOnSubscriber.call()</code>，看上面的代码大家就会发现在<code>call()</code>方法中最终调用了<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法。这便是它实现线程切换的原理。</p>
<p>好了，我们最后再看看<strong>示例C</strong>对应的执行流程图，帮助大家加深理解。</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess.jpg" alt="RxJava执行流程"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章以<strong>执行流程</strong>、<strong>操作符实现</strong>以及<strong>线程调度</strong>三个方面为切入点剖析了RxJava源码。下一章将站在更宏观的角度来分析整个RxJava的框架结构、设计思想等等。敬请期待~~ :)</p>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RxJava基本流程分析&lt;/li&gt;
&lt;li&gt;操作符原理分析&lt;/li&gt;
&lt;li&gt;线程调度原理分析&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;本章节基于&lt;strong&gt;RxJava1.1.9&lt;/strong&gt;版本的源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、RxJava执行流程分析&quot;&gt;&lt;a href=&quot;#一、RxJava执行流程分析&quot; class=&quot;headerlink&quot; title=&quot;一、RxJava执行流程分析&quot;&gt;&lt;/a&gt;一、RxJava执行流程分析&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;http://www.jianshu.com/p/ba61c047c230&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;中我们介绍过，一个最基本的RxJava调用是这样的：&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列5(组合操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%975-%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列5-组合操作符/</id>
    <published>2017-02-05T16:20:46.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>   </li>
</ul>
<hr>
<p>这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： <strong><code>Merge</code></strong> <strong><code>StartWith</code></strong> <strong><code>Concat</code></strong> <strong><code>Zip</code></strong> <strong><code>CombineLatest</code></strong>  <strong><code>SwitchOnNext</code></strong> <strong><code>Join</code></strong>等等。</p>
<a id="more"></a>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><strong><code>merge(Observable, Observable)</code></strong>将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeOperator.png" alt="merge(Observable, Observable)"></p>
<p>我们看下面的例子，一共有两个Observable：一个用来发送字母，另一个用来发送数字；现在我们需要两连个Observable发射的数据合并。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.merge(letterSequence, numberSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                System.out.print(serializable.toString()+<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A 0 B C 1 D E 2 F 3 G H 4
</code></pre><p><strong><code>merge(Observable[])</code></strong>将多个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeIOOperator.png" alt="merge(Observable[])"></p>
<h3 id="StartWith"><a href="#StartWith" class="headerlink" title="StartWith"></a>StartWith</h3><p><strong><code>startWith(T)</code></strong>用于在源Observable发射的数据前插入数据。使用<strong><code>startWith(Iterable&lt;T&gt;)</code></strong>我们还可以在源Observable发射的数据前插入Iterable。官方示意图：<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOperator.png" alt="startWith(T) startWith(Iterable&lt;T&gt;)"></p>
<p><strong><code>startWith(Observable&lt;T&gt;)</code></strong>用于在源Observable发射的数据前插入另一个Observable发射的数据（这些数据会被插入到<br>源Observable发射数据的前面）。官方示意图：<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOOperator.png" alt="startWith(Observable&lt;T&gt;)"></p>
<h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p><strong><code>concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)</code></strong> <strong><code>concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;</code>)</strong>用于将多个obserbavle发射的的数据进行合并发射，concat严格按照顺序发射数据，前一个Observable没发射玩是不会发射后一个Observable的数据的。它和merge、startWitch和相似，不同之处在于：</p>
<ol>
<li>merge:合并后发射的数据是无序的；</li>
<li>startWitch:只能在源Observable发射的数据前插入数据。</li>
</ol>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ConcatOperator.png" alt="concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)、concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;)"></p>
<p>这里我们将前面Merge操作符的例子拿过来，并将操作符换成<code>Concat</code>，然后我们看看执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.concat(letterSequence, numberSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                System.out.print(serializable.toString() + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A B C D E F G H 0 1 2 3 4
</code></pre><h3 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h3><p><strong><code>zip(Observable, Observable, Func2)</code></strong>用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ZipOperator.png" alt="zip(Observable, Observable, Func2)"></p>
<p>和前面的例子一样，我们将操作符换成了<code>zip</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">120</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">200</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.zip(letterSequence, numberSequence, <span class="keyword">new</span> Func2&lt;String, Long, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String letter, Long number)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> letter + number;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">        System.out.print(result + <span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A0 B1 C2 D3 E4
</code></pre><h3 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest"></a>CombineLatest</h3><p><strong><code>comnineLatest(Observable, Observable, Func2)</code></strong>用于将两个Observale最近发射的数据已经Func2函数的规则进展组合。下面是官方提供的原理图：<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatestOperator.png" alt="comnineLatest(Observable, Observable, Func2)"></p>
<p>下面这张图应该更容易理解：<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatest.png" alt="comnineLatest(Observable, Observable, Func2)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; communityNames = DataSimulator.getCommunityNames();</div><div class="line">List&lt;Location&gt; locations = DataSimulator.getLocations();</div><div class="line"></div><div class="line">Observable&lt;String&gt; communityNameSequence = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> communityNames.get(position.intValue());</div><div class="line">            &#125;</div><div class="line">        &#125;).take(communityNames.size());</div><div class="line">Observable&lt;Location&gt; locationSequence = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, Location&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Location <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> locations.get(position.intValue());</div><div class="line">            &#125;</div><div class="line">        &#125;).take(locations.size());</div><div class="line"></div><div class="line">Observable.combineLatest(</div><div class="line">        communityNameSequence,</div><div class="line">        locationSequence,</div><div class="line">        <span class="keyword">new</span> Func2&lt;String, Location, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String communityName, Location location)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"小区名:"</span> + communityName + <span class="string">", 经纬度:"</span> + location.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                System.out.println(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区名:竹园新村, 经纬度:(21.827, 23.323)
小区名:康桥半岛, 经纬度:(21.827, 23.323)
小区名:康桥半岛, 经纬度:(11.923, 16.309)
小区名:中粮·海景壹号, 经纬度:(11.923, 16.309)
小区名:中粮·海景壹号, 经纬度:(22.273, 53.623)
小区名:浦江名苑, 经纬度:(22.273, 53.623)
小区名:南辉小区, 经纬度:(22.273, 53.623)
</code></pre><h3 id="SwitchOnNext"><a href="#SwitchOnNext" class="headerlink" title="SwitchOnNext"></a>SwitchOnNext</h3><p><strong><code>switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;</code></strong>用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新<br>的小Observable所发射的数据。</p>
<p>结合下面的原理图大家应该很容易理解，我们可以看到下图中的黄色圆圈就被丢弃了。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/SwitchOnNextOperator.png" alt="switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;)"></p>
<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p><strong><code>join(Observable, Func1, Func1, Func2)</code></strong>我们先介绍下join操作符的4个参数：</p>
<ul>
<li>Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；</li>
<li>Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；</li>
<li>Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；</li>
<li>Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。</li>
</ul>
<p>所以Join操作符的语法结构大致是这样的：<strong><code>onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)</code></strong></p>
<p>join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： <code>[0, B]</code> <code>[1, B]</code> <code>[2, B]</code> <code>[3, B]</code></p>
<p>再看看下面的图是不是好理解了呢？！<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/JoinOperator.png" alt="join(Observable, Func1, Func1, Func2)"></p>
<p>读懂了上面的文字，我们再来写段代码加深理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> List&lt;House&gt; houses = DataSimulator.getHouses();<span class="comment">//模拟的房源数据，用于测试</span></div><div class="line"></div><div class="line"><span class="comment">//用来每秒从houses总取出一套房源并发射出去</span></div><div class="line">Observable&lt;House&gt; houseSequence =</div><div class="line">        Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">                .map(<span class="keyword">new</span> Func1&lt;Long, House&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> House <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> houses.get(position.intValue());</div><div class="line">                    &#125;</div><div class="line">                &#125;).take(houses.size());<span class="comment">//这里的take是为了防止houses.get(position.intValue())数组越界</span></div><div class="line"></div><div class="line"><span class="comment">//用来实现每秒发送一个新的Long型数据</span></div><div class="line">Observable&lt;Long&gt; tictoc = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">houseSequence.join(tictoc,</div><div class="line">        <span class="keyword">new</span> Func1&lt;House, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">0</span>, TimeUnit.SECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func2&lt;House, Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house, Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> aLong + <span class="string">"--&gt;"</span> + house.getDesc();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Error:"</span>+e.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>0--&gt;中粮海景壹号新出大平层！总价4500W起
1--&gt;中粮海景壹号新出大平层！总价4500W起
1--&gt;满五唯一，黄金地段
2--&gt;中粮海景壹号新出大平层！总价4500W起
2--&gt;满五唯一，黄金地段
2--&gt;一楼自带小花园
3--&gt;一楼自带小花园
3--&gt;毗邻汤臣一品
4--&gt;毗邻汤臣一品
4--&gt;顶级住宅，给您总统般尊贵体验
5--&gt;顶级住宅，给您总统般尊贵体验
5--&gt;顶层户型，两室一厅
6--&gt;顶层户型，两室一厅
6--&gt;南北通透，豪华五房
7--&gt;南北通透，豪华五房
</code></pre><p>通过<a href="http://www.jianshu.com/p/5970280703b9" target="_blank" rel="external">转换操作符</a>、<a href="http://www.jianshu.com/p/3a188b995daa" target="_blank" rel="external">过滤操作符</a>、<a href="http://www.jianshu.com/p/546fe44a6e22" target="_blank" rel="external">组合操作符</a>三个篇幅将RxJava主要的操作符也介绍的七七八八了。更多操作符的介绍建议大家去查阅官方文档，并自己动手实践一下。这一系列的文章也会持续更新，欢迎大家保持关注！:)</p>
<p>Demo源码地址：<a href="https://github.com/BaronZ88/HelloRxJava" target="_blank" rel="external">https://github.com/BaronZ88/HelloRxJava</a></p>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： &lt;strong&gt;&lt;code&gt;Merge&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;StartWith&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Concat&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;CombineLatest&lt;/code&gt;&lt;/strong&gt;  &lt;strong&gt;&lt;code&gt;SwitchOnNext&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Join&lt;/code&gt;&lt;/strong&gt;等等。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列4(过滤操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%974-%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列4-过滤操作符/</id>
    <published>2017-02-05T16:20:33.000Z</published>
    <updated>2017-12-26T06:47:56.765Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<hr>
<p>前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： <strong><code>Filter</code></strong> <strong><code>Take</code></strong> <strong><code>TakeLast</code></strong> <strong><code>TakeUntil</code></strong> <strong><code>Skip</code></strong> <strong><code>SkipLast</code></strong> <strong><code>ElementAt</code></strong> <strong><code>Debounce</code></strong> <strong><code>Distinct</code></strong> <strong><code>DistinctUntilChanged</code></strong> <strong><code>First</code></strong> <strong><code>Last</code></strong>等等。</p>
<a id="more"></a>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p><strong><code>filter(Func1)</code></strong>用来过滤观测序列中我们不想要的值，只返回满足条件的值，我们看下原理图：</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FilterOperator.png" alt="filter(Func1)"></p>
<p>还是拿前面文章中的小区<code>Community[] communities</code>来举例，假设我需要赛选出所有房源数大于10个的小区，我们可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .filter(<span class="keyword">new</span> Func1&lt;Community, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> community.houses.size()&gt;<span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">        System.out.println(community.name);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h3><p><strong><code>take(int)</code></strong>用一个整数n作为一个参数，从原始的序列中发射前n个元素.<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeOperator.png" alt="take(int)"></p>
<p>现在我们需要取小区列表<code>communities</code>中的前10个小区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .take(10)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```     </div><div class="line"></div><div class="line">### TakeLast</div><div class="line">**`takeLast(int)`**同样用一个整数n作为参数，只不过它发射的是观测序列中后n个元素。</div><div class="line">![takeLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeLastNOperator.png)</div><div class="line"></div><div class="line">获取小区列表`communities`中的后3个小区</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .takeLast(3)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="TakeUntil"><a href="#TakeUntil" class="headerlink" title="TakeUntil"></a>TakeUntil</h3><p><strong><code>takeUntil(Observable)</code></strong>订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，<code>takeUntil()</code>返回的Observable会停止发射原始Observable并终止。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilOperator.png" alt="takeUntil(Observable)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Long&gt; observableA = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS);</div><div class="line">Observable&lt;Long&gt; observableB = Observable.interval(<span class="number">800</span>, TimeUnit.MILLISECONDS);</div><div class="line"></div><div class="line">observableA.takeUntil(observableB)</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                System.out.println(aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(Integer.MAX_VALUE);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>0
1
</code></pre><p><strong><code>takeUntil(Func1)</code></strong>通过Func1中的call方法来判断是否需要终止发射数据。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilPOperator.png" alt="takeUntil(Func1)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">                .takeUntil(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> integer &gt;= <span class="number">5</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                System.out.println(integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>1
2
3
4
5
</code></pre><p>###Skip<br><strong><code>skip(int)</code></strong>让我们可以忽略Observable发射的前n项数据。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipOperator.png" alt="skip(int)"></p>
<p>过滤掉小区列表<code>communities</code>中的前5个小区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .skip(5)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```        </div><div class="line"></div><div class="line"></div><div class="line">### SkipLast</div><div class="line"></div><div class="line">**`skipLast(int)`**忽略Observable发射的后n项数据。</div><div class="line">![skipLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipLastOperator.png)</div><div class="line"></div><div class="line">### ElementAt</div><div class="line">**`elementAt(int)`**用来获取元素Observable发射的事件序列中的第n项数据，并当做唯一的数据发射出去。</div><div class="line">![elementAt(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/ElementAtOperator.png)</div><div class="line"></div><div class="line">### Debounce</div><div class="line">**`debounce(long, TimeUnit)`**过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBing(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</div><div class="line">![debounce(long, TimeUnit)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceOperator.png)</div><div class="line"></div><div class="line">**`debounce(Func1)`**可以根据Func1的call方法中的函数来过滤，Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。</div><div class="line">![debounce(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceFOperator.png)</div><div class="line"></div><div class="line">### Distinct</div><div class="line">**`distinct()`**的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。</div><div class="line">![distinct()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctOperator.png)</div><div class="line"></div><div class="line">过滤掉一段数字中的重复项：</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class="line">        .distinct()</div><div class="line">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer i) &#123;</div><div class="line">                System.out.print(i + " ");</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>2 1 3 4 5
</code></pre><p><strong><code>distinct(Func1)</code></strong>参数中的Func1中的call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是不是相同；如果判定为重复则会和<code>distinct()</code>一样过滤掉重复的数据项。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctKeyOperator.png" alt="distinct(Func1)"></p>
<p>假设我们要过滤掉一堆房源中小区名重复的小区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//House构造函数中的第一个参数为该房源所属小区名，第二个参数为房源描述</span></div><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"中粮海景壹号新出大平层！总价4500W起"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"满五唯一，黄金地段"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"一楼自带小花园"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"毗邻汤臣一品"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"顶级住宅，给您总统般尊贵体验"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"顶层户型，两室一厅"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"南北通透，豪华五房"</span>));</div><div class="line">Observable.from(houses)</div><div class="line">        .distinct(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:竹园新村; 房源描述:满五唯一，黄金地段
</code></pre><h3 id="DistinctUntilChanged"><a href="#DistinctUntilChanged" class="headerlink" title="DistinctUntilChanged"></a>DistinctUntilChanged</h3><p><strong><code>distinctUntilChanged()</code></strong>和<code>distinct()</code>类似，只不过它判定的是Observable发射的当前数据项和前一个数据项是否相同。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedOperator.png" alt="distinctUntilChanged()"></p>
<p>同样还是上面过滤数字的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class="line">        .distinctUntilChanged()</div><div class="line">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer i) &#123;</div><div class="line">                System.out.print(i + &quot; &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>2 1 2 3 4 3 4 5
</code></pre><p><strong><code>distinctUntilChanged(Func1)</code></strong>和<code>distinct(Func1)</code>一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedKeyOperator.png" alt="distinctUntilChanged(Func1)"></p>
<p>我们还是拿前面的过滤房源的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .distinctUntilChanged(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:竹园新村; 房源描述:满五唯一，黄金地段
小区:中粮·海景壹号; 房源描述:毗邻汤臣一品
小区:竹园新村; 房源描述:顶层户型，两室一厅
小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
</code></pre><h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p><strong><code>first()</code></strong>顾名思义，它是的Observable只发送观测序列中的第一个数据项。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstOperator.png" alt="first()"></p>
<p>获取房源列表<code>houses</code>中的第一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .first()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;                </div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
</code></pre><p><strong><code>first(Func1)</code></strong>只发送符合条件的第一个数据项。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstNOperator.png" alt="first(Func1)"></p>
<p>现在我们要获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的第一套房源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .first(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"竹园新村"</span>.equals(house.communityName);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:竹园新村; 房源描述:满五唯一，黄金地段
</code></pre><h3 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h3><p><strong><code>last()</code></strong>只发射观测序列中的最后一个数据项。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastOperator.png" alt="last()"></p>
<p>获取房源列表中的最后一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .last()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
</code></pre><p><strong><code>last(Func1)</code></strong>只发射观测序列中符合条件的最后一个数据项。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastPOperator.png" alt="last(Func1)"></p>
<p>获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的最后一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .last(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"竹园新村"</span>.equals(house.communityName);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:竹园新村; 房源描述:顶层户型，两室一厅
</code></pre><p>这一章我们就先聊到这，更多的过滤类操作符的介绍大家可以去查阅官方文档和源码；在下一章我们将继续介绍组合类操作符。</p>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Take&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;TakeUntil&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Skip&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;SkipLast&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Debounce&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Distinct&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;DistinctUntilChanged&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;First&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Last&lt;/code&gt;&lt;/strong&gt;等等。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列3(转换操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%973-%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列3-转换操作符/</id>
    <published>2017-02-05T16:20:19.000Z</published>
    <updated>2017-12-26T06:46:56.241Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>   </li>
</ul>
<hr>
<p>前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：</p>
<ol>
<li><strong>转换类操作符</strong></li>
<li><strong>过滤类操作符</strong></li>
<li><strong>组合类操作符</strong></li>
</ol>
<p>这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。</p>
<a id="more"></a>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong><code>map(Func1)</code></strong>函数接受一个Func1类型的参数(就像这样<code>map(Func1&lt;? super T, ? extends R&gt; func)</code>),然后吧这个Func1应用到每一个由Observable发射的值上，将发射的只转换为我们期望的值。这种狗屁定义我相信你也听不懂，我们来看一下官方给出的原理图：</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/MapOperator.png" alt="map(Func1)"></p>
<p>假设我们需要将一组数字装换成字符串，我们可以通过map这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"This is "</span> + i;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                System.out.println(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>Func1构造函数中的两个参数分别是Observable发射值当前的类型和map转换后的类型，上面这个例子中发射值当前的类型是Integer,转换后的类型是String。</p>
</blockquote>
<h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p><strong><code>flatMap(Func1)</code></strong>函数同样也是做转换的，但是作用却不一样。flatMap不太好理解，我们直接看例子（<em>我们公司是个房产平台，那我就拿房子举例</em>）：假设我们有一组小区数据<code>Community[] communites</code>,现在我们要输出每个小区的名字；我们可以这样实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Community, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> community.name;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Community name : "</span> + name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>现在我们需求有变化，需要打印出每个小区下面每一套房子的价格。于是我可以这样实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">Community[] communities = &#123;&#125;;</div><div class="line">Observable.from(communities)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                for (House house : community.houses) &#123;</div><div class="line">                    System.out.println("House price : " + house.price);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```            </div><div class="line"></div><div class="line">如果我不想在Subscriber中使用for循环，而是希望Subscriber中直接传入单个的House对象呢？用map()显然是不行的，因为map()是一对一的转化，而我现在的要求是一对多的转化。那么我们可以使用flatMap()把一个Community转化成多个House。</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;House&gt; call(Community community) &#123;</div><div class="line">                return Observable.from(community.houses);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(House house) &#123;</div><div class="line">                System.out.println("House price : " + house.price);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```            </div><div class="line"></div><div class="line">从前面的例子中我们发现，flatMap()和map()都是把传入的参数转化之后返回另一个对象。但和map()不同的是，flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到 Subscriber的回调方法中。</div><div class="line"></div><div class="line">flatMap(Func1)的原理是这样的：</div><div class="line"></div><div class="line">1. 将传入的事件对象装换成一个Observable对象；</div><div class="line">2. 这是不会直接发送这个Observable, 而是将这个Observable激活让它自己开始发送事件；</div><div class="line">3. 每一个创建出来的Observable发送的事件，都被汇入同一个Observable，这个Observable负责将这些事件统一交给Subscriber的回调方法。</div><div class="line"></div><div class="line">这三个步骤，把事件拆成了两级，通过一组新创建的Observable将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是flatMap()所谓的flat。</div><div class="line"></div><div class="line">最后我们来看看flatMap的原理图：</div><div class="line">![flatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapOperator.png)</div><div class="line"></div><div class="line">### ConcatMap</div><div class="line">**`concatMap(Func1)`**解决了`flatMap()`的交叉问题，它能够把发射的值连续在一起，就像这样：</div><div class="line">![concatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ConcatMapOperator.png)</div><div class="line"></div><div class="line">### flatMapIterable</div><div class="line">**`flatMapIterable(Func1)`**和`flatMap()`几乎是一样的，不同的是`flatMapIterable()`它转化的多个Observable是使用Iterable作为源数据的。</div><div class="line">![flatMapIterable(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapIterableOperator.png)</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .flatMapIterable(new Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Iterable&lt;House&gt; call(Community community) &#123;</div><div class="line">                return community.houses;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void call(House house) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="SwitchMap"><a href="#SwitchMap" class="headerlink" title="SwitchMap"></a>SwitchMap</h3><p><strong><code>switchMap(Func1)</code></strong>和<code>flatMap(Func1)</code>很像，除了一点：每当源<code>Observable</code>发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的<code>Observable</code>，并开始监视当前发射的这一个。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/SwitchMapOperator.png" alt="switchMap(Func1)"></p>
<h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h3><p><strong><code>scan(Func2)</code></strong>对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用合格函数时的第一个参数使用。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ScanOperator.png" alt="scan(Func2)"></p>
<p>我们来看个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .scan(<span class="keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer integer, Integer integer2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer + integer2;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        System.out.print(integer+“ ”);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>输出结果为：</p>
<pre><code>1 3 6 10 15  
</code></pre><h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><p><strong><code>groupBy(Func1)</code></strong>将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小Observable分别发射其所包含的的数据，和SQL中的groupBy类似。实际使用中，我们需要提供一个生成key的规则（也就是Func1中的call方法），所有key相同的数据会包含在同一个小的Observable中。另外我们还可以提供一个函数来对这些数据进行转化，有点类似于集成了flatMap。<br><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/GroupByOperator.png" alt="groupBy(Func1)"></p>
<p>单纯的文字描述和图片解释可能难以理解，我们来看个例子：假设我现在有一组房源<code>List&lt;House&gt; houses</code>,每套房子都属于某一个小区，现在我们需要根据小区名来对房源进行分类，然后依次将房源信息输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"中粮海景壹号新出大平层！总价4500W起"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"满五唯一，黄金地段"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"毗邻汤臣一品"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"顶层户型，两室一厅"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"南北通透，豪华五房"</span>));</div><div class="line">Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable.from(houses)</div><div class="line">        .groupBy(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>通过上面的代码我们创建了一个新的Observable:<code>groupByCommunityNameObservable</code>，它将会发送一个带有<code>GroupedObservable</code>的序列（也就是指发送的数据项的类型为GroupedObservable）。<code>GroupedObservable</code>是一个特殊的<code>Observable</code>，它基于一个分组的key，在这个例子中的key就是小区名。现在我们需要将分类后的房源依次输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.concat(groupByCommunityNameObservable)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span>+house.communityName+<span class="string">"; 房源描述:"</span>+house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:中粮·海景壹号; 房源描述:毗邻汤臣一品
小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
小区:竹园新村; 房源描述:满五唯一，黄金地段
小区:竹园新村; 房源描述:顶层户型，两室一厅
</code></pre><p>转换类的操作符就先介绍到这，后续还会继续介绍组合、过滤类的操作符及源码分析，敬请期待！</p>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;p&gt;前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;转换类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列2(基本概念及使用介绍)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%972-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列2-基本概念及使用介绍/</id>
    <published>2017-02-05T16:20:04.000Z</published>
    <updated>2017-12-26T06:47:00.123Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>   </li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇的示例代码中大家一定发现了Observable这个类。从纯Java的观点看，Observable类源自于经典的观察者模式。RxJava的异步实现正是基于观察者模式来实现的，而且是一种扩展的观察者模式。</p>
<a id="more"></a>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式基于Subject这个概念，Subject是一种特殊对象，又叫做<strong>主题</strong>或者<strong>被观察者</strong>。当它改变时那些由它保存的一系列对象将会得到通知，而这一系列对象被称作Observer(<strong>观察者</strong>)。它们会对外暴漏了一个通知方法(比方说update之类的)，当Subject状态发生变化时会调用的这个方法。</p>
<p>观察者模式很适合下面这些场景中的任何一个：</p>
<ol>
<li>当你的架构有两个实体类，一个依赖另一个，你想让它们互不影响或者是独立复用它们时。</li>
<li>当一个变化的对象通知那些与它自身变化相关联的未知数量的对象时。</li>
<li>当一个变化的对象通知那些无需推断具体类型的对象时。</li>
</ol>
<p>通常一个观察者模式的类图是这样的：</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/2/Observer.png" alt="Observer"></p>
<p>如果你对观察者模式不是很了解，那么强烈建议你先去学习下。关于观察者模式的详细介绍可以参考我之前的文章：<a href="http://www.jianshu.com/p/d55ee6e83d66" target="_blank" rel="external">设计模式之观察者模式</a></p>
<h2 id="扩展的观察者模式"><a href="#扩展的观察者模式" class="headerlink" title="扩展的观察者模式"></a>扩展的观察者模式</h2><p>在RxJava中主要有4个角色：</p>
<ul>
<li>Observable</li>
<li>Subject</li>
<li>Observer</li>
<li>Subscriber</li>
</ul>
<p>Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。说直白点<code>Observable</code>对应于观察者模式中的<strong>被观察者</strong>，而<code>Observer</code>和<code>Subscriber</code>对应于观察者模式中的<strong>观察者</strong>。<code>Subscriber</code>其实是一个实现了<code>Observer</code>的抽象类，后面我们分析源码的时候也会介绍到。<code>Subject</code>比较复杂，以后再分析。</p>
<p>上一篇文章中我们说到RxJava中有个关键概念：<strong>事件</strong>。观察者<code>Observer</code>和被观察者<code>Observable</code>通过<code>subscribe()</code>方法实现订阅关系。从而<code>Observable</code> 可以在需要的时候发出<strong>事件</strong>来通知<code>Observer</code>。</p>
<h2 id="RxJava如何使用"><a href="#RxJava如何使用" class="headerlink" title="RxJava如何使用"></a>RxJava如何使用</h2><p>我自己在学习一种新技术的时候通常喜欢先去了解它是怎么用的，掌握了使用方法后再去深挖其原理。那么我们现在就来说说RxJava到底该怎么用。</p>
<p><strong>第一步：创建观察者Observer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Observer&lt;Object&gt; observer = <span class="keyword">new</span> Observer&lt;Object&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object s)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>这么简单，一个观察者Observer创建了!</p>
<p>大兄弟你等等…，你之前那篇<a href="http://www.jianshu.com/p/d55ee6e83d66" target="_blank" rel="external">观察者模式</a>中不是说观察者只提供一个update方法的吗？这特么怎么有三个？！！</p>
<p>少年勿急，且听我慢慢道来。在普通的观察者模式中观察者一般只会提供一个update()方法用于被观察者的状态发生变化时，用于提供给被观察者调用。而在RxJava中的观察者Observer提供了:<code>onNext()</code>、 <code>onCompleted()</code>和<code>onError()</code>三个方法。还记得吗？开篇我们讲过RxJava是基于一种扩展的观察这模式实现，这里多出的onCompleted和onError正是对观察者模式的扩展。<em>ps:onNext就相当于普通观察者模式中的update</em></p>
<p>RxJava中添加了普通观察者模式缺失的三个功能：</p>
<ol>
<li>RxJava中规定当不再有新的事件发出时，可以调用onCompleted()方法作为标示；</li>
<li>当事件处理出现异常时框架自动触发onError()方法；</li>
<li>同时Observables支持链式调用，从而避免了回调嵌套的问题。</li>
</ol>
<p><strong>第二步：创建被观察者Observable</strong></p>
<p><code>Observable.create()</code>方法可以创建一个Observable，使用<code>crate()</code>创建Observable需要一个OnSubscribe对象，这个对象继承Action1。当观察者订阅我们的Observable时，它作为一个参数传入并执行<code>call()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Object&gt; observable = Observable.create(<span class="keyword">new</span></div><div class="line">        	Observable.OnSubscribe&lt;Object&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Object&gt; subscriber)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>除了create()，just()和from()同样可以创建Observable。看看下面两个例子：</p>
<p><code>just(T...)</code>将传入的参数依次发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.just(<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>);</div><div class="line"><span class="comment">//上面这行代码会依次调用</span></div><div class="line"><span class="comment">//onNext("One");</span></div><div class="line"><span class="comment">//onNext("Two");</span></div><div class="line"><span class="comment">//onNext("Three");</span></div><div class="line"><span class="comment">//onCompleted();</span></div></pre></td></tr></table></figure>
<p><code>from(T[])/from(Iterable&lt;? extends T&gt;)</code>将传入的数组或者Iterable拆分成Java对象依次发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String[] parameters = &#123;<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>&#125;;</div><div class="line">Observable observable = Observable.from(parameters);</div><div class="line"><span class="comment">//上面这行代码会依次调用</span></div><div class="line"><span class="comment">//onNext("One");</span></div><div class="line"><span class="comment">//onNext("Two");</span></div><div class="line"><span class="comment">//onNext("Three");</span></div><div class="line"><span class="comment">//onCompleted();</span></div></pre></td></tr></table></figure>
<p><strong>第三步：被观察者Observable订阅观察者Observer</strong>（<em>ps:你没看错，不同于普通的观察者模式，这里是被观察者订阅观察者</em>）</p>
<p>有了观察者和被观察者，我们就可以通过subscribe()来实现二者的订阅关系了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/2/subscribe1.png" alt="observable.subscribe(observer)"></p>
<p>连在一起写就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            subscriber.onNext(i);</div><div class="line">        &#125;</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onCompleted"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onError"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Item is "</span> + item);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此一个完整的RxJava调用就完成了。</p>
<p>兄台，你叨逼叨叨逼叨的说了一大堆，可是我没搞定你特么到底在干啥啊？！！不急，我现在就来告诉你们到底发生了什么。</p>
<p>首先我们使用Observable.create()创建了一个新的Observable<integer>，并为<code>create()</code>方法传入了一个OnSubscribe，OnSubscribe中包含一个<code>call()</code>方法，一旦我们调用<code>subscribe()</code>订阅后就会自动触发call()方法。call()方法中的参数Subscriber其实就是subscribe()方法中的观察者Observer。我们在<code>call()</code>方法中调用了5次<code>onNext()</code>和1次<code>onCompleted()</code>方法。一套流程周下来以后输出结果就是下面这样的：</integer></p>
<pre><code>Item is 0
Item is 1
Item is 2
Item is 3
Item is 4
onCompleted
</code></pre><p>看到这里可能你又要说了，大兄弟你别唬我啊！OnSubscribe的call()方法中的参数Subscriber怎么就变成了subscribe()方法中的观察者Observer？！！！这俩儿货明明看起来就是两个不同的类啊。</p>
<p>我们先看看Subscriber这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码中我们可以看到，Subscriber是Observer的一个抽象实现类，所以我首先可以肯定的是Subscriber和Observer类型是一致的。接着往下我们看看subscribe()这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//这里的if判断对于我们要分享的问题没有关联，可以先无视</span></div><div class="line">    <span class="keyword">if</span> (observer <span class="keyword">instanceof</span> Subscriber) &#123;</div><div class="line">        <span class="keyword">return</span> subscribe((Subscriber&lt;? <span class="keyword">super</span> T&gt;)observer);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            observer.onCompleted();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            observer.onError(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">            observer.onNext(t);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到subscribe()方法内部首先将传进来的Observer做了一层代理，将它转换成了Subscriber。我们再看看这个方法内部的subscribe()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步往下追踪看看return后面这段代码到底做了什么。精简掉其他无关代码后的subscribe(subscriber, this)方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line"></div><div class="line">    subscriber.onStart();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</div><div class="line">        <span class="keyword">return</span> hook.onSubscribeReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们重点看看hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber),前面这个hook.onSubscribeStart(observable, observable.onSubscribe)返回的是它自己括号内的第二个参数observable.onSubscribe,然后调用了它的call方法。而这个observable.onSubscribe正是create()方法中的Subscriber，这样整个流程就理顺了。看到这里是不是对RxJava的执行流程清晰了一点呢？这里也建议大家在学习新技术的时候多去翻一翻源码，知其然还要能知其所以然不是吗。</p>
<blockquote>
<p>subscribe()的参数除了可以是Observer和Subscriber以外还可以是Action1、Action0；这是一种更简单的回调，只有一个call(T)方法；由于太简单这里就不做详细介绍了！</p>
</blockquote>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>上一篇文章中开篇就讲到RxJava就是来处理异步任务的。但是默认情况下我们在哪个线程调用subscribe()就在哪个线程生产事件，在哪个线程生产事件就在哪个线程消费事件。那怎么做到异步呢？RxJava为我们提供Scheduler用来做线程调度，我们来看看RxJava提供了哪些Scheduler。</p>
<table class="table table-striped"><tr><th>Schedulers</th><th>作用</th></tr><tr><td>Schedulers.immediate()</td><td>默认的Scheduler，直接在当前线程运行</td></tr><tr><td>Schedulers.newThread()</td><td>总是开启一个新线程</td></tr><tr><td>Schedulers.io()</td><td>用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io()默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</td></tr><tr><td>Schedulers.computation()</td><td>计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU</td></tr><tr><td>Schedulers.from(executor)</td><td>使用指定的Executor作为调度器</td></tr><tr><td>Schedulers.trampoline()</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>RxAndroid中新增的Scheduler，表示在Android的main线程中运行</td></tr></table>

<p>同时RxJava还为我们提供了<code>subscribeOn()</code>和<code>observeOn()</code>两个方法来指定Observable和Observer运行的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Observable.from(getCommunitiesFromServer())</div><div class="line">            .flatMap(community -&gt; Observable.from(community.houses))</div><div class="line">            .filter(house -&gt; house.price&gt;=<span class="number">5000000</span>).subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(<span class="keyword">this</span>::addHouseInformationToScreen);</div></pre></td></tr></table></figure>
<p>上面这段代码大家应该有印象吧，没错正是我们上一篇文章中的例子。<code>subscribeOn(Schedulers.io())</code>指定了获取小区列表、处理房源信息等一系列事件都是在IO线程中运行，<code>observeOn(AndroidSchedulers.mainThread())</code>指定了在屏幕上展示房源的操作在UI线程执行。这就做到了在子线程获取房源，主线程展示房源。</p>
<p>好了，RxJava系列的入门内容我们就聊到这。下一篇我们再继续介绍更多的API以及它们内部的原理。</p>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇的示例代码中大家一定发现了Observable这个类。从纯Java的观点看，Observable类源自于经典的观察者模式。RxJava的异步实现正是基于观察者模式来实现的，而且是一种扩展的观察者模式。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列1(简介)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%971-%E7%AE%80%E4%BB%8B/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列1-简介/</id>
    <published>2017-02-05T16:19:48.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。</p>
<blockquote>
<p>由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。</p>
</blockquote>
<a id="more"></a>
<h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>在介绍RxJava前，我们先聊聊响应式编程。那么什么是响应式编程呢？响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</p>
<p>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。</p>
<p>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</p>
<blockquote>
<p>本章节中部分概念摘自《RxJava Essentials》一书</p>
</blockquote>
<h2 id="RxJava的来历"><a href="#RxJava的来历" class="headerlink" title="RxJava的来历"></a>RxJava的来历</h2><p>Rx是微软.Net的一个响应式扩展，Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012年Netflix为了应对不断增长的业务需求开始将.NET Rx迁移到JVM上面。并于13年二月份正式向外展示了RxJava。<br>从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/rxjava/1/RxJava%E6%9D%A5%E5%8E%86.png" alt="RxJava来历"></p>
<h2 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h2><p>那么到底什么是RxJava呢？我对它的定义是：<strong>RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。</strong></p>
<h2 id="RxJava好在哪"><a href="#RxJava好在哪" class="headerlink" title="RxJava好在哪"></a>RxJava好在哪</h2><p>Android平台上为已经开发者提供了AsyncTask,Handler等用来做异步操作的类库，那我们为什么还要选择RxJava呢？答案是简洁！RxJava可以用非常简洁的代码逻辑来解决复杂问题；而且即使业务逻辑的越来越复杂，它依然能够保持简洁！再配合上Lambda用简单的几行代码分分钟就解决你负责的业务问题。简直逼格爆表，拿它装逼那是极好的！</p>
<p>多说无益，上代码！</p>
<p>假设我们安居客用户App上有个需求，需要从服务端拉取上海浦东新区塘桥板块的所有小区Community[] communities，每个小区下包含多套房源List<house> houses；我们需要把塘桥板块的所有总价大于500W的房源都展示在App的房源列表页。用于从服务端拉取communities需要发起网络请求，比较耗时，因此需要在后台运行。而这些房源信息需要展示到App的页面上，因此需要在UI线程上执行。(<em>此例子思路来源于扔物线的<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给Android开发者的RxJava详解</a>一文</em>)</house></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.run();</div><div class="line">            <span class="comment">//从服务端获取小区列表</span></div><div class="line">            List&lt;Community&gt; communities = getCommunitiesFromServer();</div><div class="line">            <span class="keyword">for</span> (Community community : communities) &#123;</div><div class="line">                List&lt;House&gt; houses = community.houses;</div><div class="line">                <span class="keyword">for</span> (House house : houses) &#123;</div><div class="line">                    <span class="keyword">if</span> (house.price &gt;= <span class="number">5000000</span>) &#123;</div><div class="line">                        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                <span class="comment">//将房子的信息添加到屏幕上</span></div><div class="line">                                addHouseInformationToScreen(house);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div></pre></td></tr></table></figure>
<p>使用RxJava的写法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable.from(getCommunitiesFromServer())</div><div class="line">            .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> Observable.from(community.houses);</div><div class="line">                &#125;</div><div class="line">            &#125;).filter(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> house.price&gt;=<span class="number">5000000</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;).subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                    <span class="comment">//将房子的信息添加到屏幕上</span></div><div class="line">                    addHouseInformationToScreen(house);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
<p>从上面这段代码我们可以看到：虽然代码量看起来变复杂了，但是RxJava的实现是一条链式调用，没有任何的嵌套；整个实现逻辑看起来异常简洁清晰，这对我们的编程实现和后期维护是有巨大帮助的。特别是对于那些回调嵌套的场景。配合Lambda表达式还可以简化成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Observable.from(getCommunitiesFromServer())</div><div class="line">        .flatMap(community -&gt; Observable.from(community.houses))</div><div class="line">        .filter(house -&gt; house.price&gt;=<span class="number">5000000</span>).subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">this</span>::addHouseInformationToScreen);</div></pre></td></tr></table></figure>
<p>简洁！有美感！这才是一个有情怀的程序员应该写出来的代码。</p>
<p>看完这篇文章大家应该能够理解RxJava为什么会越来越火了。它能极大的提高我们的开发效率和代码的可读性！当然了RxJava的学习曲线也是比较陡的，在后面的文章我会对主要的知识点做详细的介绍，敬请关注！</p>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android WebView那些坑之上传文件</title>
    <link href="http://baronzhang.com//blog/Android/Android-WebView%E9%82%A3%E4%BA%9B%E5%9D%91%E4%B9%8B%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://baronzhang.com//blog/Android/Android-WebView那些坑之上传文件/</id>
    <published>2017-02-05T16:16:41.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近公司项目需要在<code>WebView</code>上调用手机系统相册来上传图片，开发过程中发现在很多机器上无法正常唤起系统相册来选择图片。</p>
<p>解决问题之前我们先来说说<code>WebView</code>上传文件的逻辑：当我们在Web页面上点击选择文件的控件(<code>&lt;input type=&quot;file&quot;&gt;</code>)时，会回调<code>WebChromeClient</code>下的<code>openFileChooser()</code>（5.0及以上系统回调<code>onShowFileChooser()</code>）。这个时候我们在<code>openFileChooser</code>方法中通过<code>Intent</code>打开系统相册或者支持该<code>Intent</code>的第三方应用来选择图片。like this：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback, String acceptType, String capture)</span> </span>&#123;</div><div class="line">	uploadMessage = valueCallback;</div><div class="line">   	openImageChooserActivity();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openImageChooserActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">    Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</div><div class="line">    i.addCategory(Intent.CATEGORY_OPENABLE);</div><div class="line">    i.setType(<span class="string">"image/*"</span>);</div><div class="line">    startActivityForResult(Intent.createChooser(i,</div><div class="line">    			<span class="string">"Image Chooser"</span>), FILE_CHOOSER_RESULT_CODE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>最后我们在<code>onActivityResult()</code>中将选择的图片内容通过<code>ValueCallback</code>的<code>onReceiveValue</code>方法返回给<code>WebView</code>，然后通过js上传。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line">    <span class="keyword">if</span> (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;</div><div class="line">        Uri result = data == <span class="keyword">null</span> || resultCode != RESULT_OK ? <span class="keyword">null</span> : data.getData();</div><div class="line">        <span class="keyword">if</span> (uploadMessage != <span class="keyword">null</span>) &#123;</div><div class="line">            uploadMessage.onReceiveValue(result);</div><div class="line">            uploadMessage = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>PS:<code>ValueCallbacks</code>是<code>WebView</code>组件通过<code>openFileChooser()</code>或者<code>onShowFileChooser()</code>提供给我们的，它里面包含了一个或者一组<code>Uri</code>,然后我们在<code>onActivityResult()</code>里将<code>Uri</code>传给<code>ValueCallbacks</code>的<code>onReceiveValue()</code>方法，这样<code>WebView</code>就知道我们选择了什么文件。</p>
</blockquote>
<p>到这里你可能要问了，说了这么多还是没解释为什么在很多机型上无法唤起系统相册或者第三方app来选择图片啊？！这是因为为了最求完美的Google攻城狮们对<code>openFileChooser</code>做了多次修改，在5.0上更是将回调方法该为了<code>onShowFileChooser</code>。所以为了解决这一问题，兼容各个版本，我们需要对<code>openFileChooser()</code>进行重载，同时针对5.0及以上系统提供<code>onShowFileChooser()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">webview.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;</div><div class="line"></div><div class="line">        <span class="comment">// For Android &lt; 3.0</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback)</span> </span>&#123;</div><div class="line">            ***</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// For Android  &gt;= 3.0</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback valueCallback, String acceptType)</span> </span>&#123;</div><div class="line">            ***</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//For Android  &gt;= 4.1</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback,</span></span></div><div class="line">        		String acceptType, String capture) &#123;</div><div class="line">            ***</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// For Android &gt;= 5.0</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onShowFileChooser</span><span class="params">(WebView webView,</span></span></div><div class="line">        		ValueCallback&lt;Uri[]&gt; filePathCallback,</div><div class="line">        		WebChromeClient.FileChooserParams fileChooserParams) &#123;</div><div class="line">            ***</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>大家应该注意到<code>onShowFileChooser()</code>中的<code>ValueCallback</code>包含了一组<code>Uri(Uri[])</code>,所以针对5.0及以上系统，我们还需要对<code>onActivityResult()</code>做一点点处理。这里不做描述，最后我再贴上完整代码。</p>
<p>当处理完这些后你以为就万事大吉了？！当初我也这样天真，但当我们打好release包测试的时候却又发现没法选择图片了！！！真是坑了个爹啊！！！无奈去翻<code>WebChromeClient</code>的源码，发现<code>openFileChooser()</code>是系统API，我们的release包是开启了混淆的，所以在打包的时候混淆了<code>openFileChooser()</code>，这就导致无法回调<code>openFileChooser()</code>了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Tell the client to open a file chooser.</div><div class="line"> * <span class="doctag">@param</span> uploadFile A ValueCallback to set the URI of the file to upload.</div><div class="line"> *      onReceiveValue must be called to wake up the thread.a</div><div class="line"> * <span class="doctag">@param</span> acceptType The value of the 'accept' attribute of the input tag</div><div class="line"> *         associated with this file picker.</div><div class="line"> * <span class="doctag">@param</span> capture The value of the 'capture' attribute of the input tag</div><div class="line"> *         associated with this file picker.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #showFileChooser&#125; instead.</div><div class="line"> * <span class="doctag">@hide</span> This method was not published in any SDK version.</div><div class="line"> */</div><div class="line"><span class="meta">@SystemApi</span></div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; uploadFile, String acceptType, String capture)</span> </span>&#123;</div><div class="line">    uploadFile.onReceiveValue(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决方案也很简单，直接不混淆<code>openFileChooser()</code>就好了。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">webkit</span>.<span class="title">WebChromeClient</span>&#123;</span></div><div class="line">		<span class="keyword">public</span> <span class="keyword">void</span> openFileChooser(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>支持关于上传文件的所有坑都填完了，最后附上完整源码：<br>(源码地址:<a href="https://github.com/BaronZ88/WebViewSample" target="_blank" rel="external">https://github.com/BaronZ88/WebViewSample</a>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ValueCallback&lt;Uri&gt; uploadMessage;</div><div class="line">    <span class="keyword">private</span> ValueCallback&lt;Uri[]&gt; uploadMessageAboveL;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> FILE_CHOOSER_RESULT_CODE = <span class="number">10000</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        WebView webview = (WebView) findViewById(R.id.web_view);</div><div class="line">        <span class="keyword">assert</span> webview != <span class="keyword">null</span>;</div><div class="line">        WebSettings settings = webview.getSettings();</div><div class="line">        settings.setUseWideViewPort(<span class="keyword">true</span>);</div><div class="line">        settings.setLoadWithOverviewMode(<span class="keyword">true</span>);</div><div class="line">        settings.setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">        webview.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;</div><div class="line"></div><div class="line">            <span class="comment">// For Android &lt; 3.0</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback)</span> </span>&#123;</div><div class="line">                uploadMessage = valueCallback;</div><div class="line">                openImageChooserActivity();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// For Android  &gt;= 3.0</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback valueCallback, String acceptType)</span> </span>&#123;</div><div class="line">                uploadMessage = valueCallback;</div><div class="line">                openImageChooserActivity();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//For Android  &gt;= 4.1</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback, String acceptType, String capture)</span> </span>&#123;</div><div class="line">                uploadMessage = valueCallback;</div><div class="line">                openImageChooserActivity();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// For Android &gt;= 5.0</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onShowFileChooser</span><span class="params">(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)</span> </span>&#123;</div><div class="line">                uploadMessageAboveL = filePathCallback;</div><div class="line">                openImageChooserActivity();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        String targetUrl = <span class="string">"file:///android_asset/up.html"</span>;</div><div class="line">        webview.loadUrl(targetUrl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openImageChooserActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">        Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</div><div class="line">        i.addCategory(Intent.CATEGORY_OPENABLE);</div><div class="line">        i.setType(<span class="string">"image/*"</span>);</div><div class="line">        startActivityForResult(Intent.createChooser(i, <span class="string">"Image Chooser"</span>), FILE_CHOOSER_RESULT_CODE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line">        <span class="keyword">if</span> (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == uploadMessage &amp;&amp; <span class="keyword">null</span> == uploadMessageAboveL) <span class="keyword">return</span>;</div><div class="line">            Uri result = data == <span class="keyword">null</span> || resultCode != RESULT_OK ? <span class="keyword">null</span> : data.getData();</div><div class="line">            <span class="keyword">if</span> (uploadMessageAboveL != <span class="keyword">null</span>) &#123;</div><div class="line">                onActivityResultAboveL(requestCode, resultCode, data);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uploadMessage != <span class="keyword">null</span>) &#123;</div><div class="line">                uploadMessage.onReceiveValue(result);</div><div class="line">                uploadMessage = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.LOLLIPOP)</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onActivityResultAboveL</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (requestCode != FILE_CHOOSER_RESULT_CODE || uploadMessageAboveL == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        Uri[] results = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (resultCode == Activity.RESULT_OK) &#123;</div><div class="line">            <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</div><div class="line">                String dataString = intent.getDataString();</div><div class="line">                ClipData clipData = intent.getClipData();</div><div class="line">                <span class="keyword">if</span> (clipData != <span class="keyword">null</span>) &#123;</div><div class="line">                    results = <span class="keyword">new</span> Uri[clipData.getItemCount()];</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clipData.getItemCount(); i++) &#123;</div><div class="line">                        ClipData.Item item = clipData.getItemAt(i);</div><div class="line">                        results[i] = item.getUri();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (dataString != <span class="keyword">null</span>)</div><div class="line">                    results = <span class="keyword">new</span> Uri[]&#123;Uri.parse(dataString)&#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        uploadMessageAboveL.onReceiveValue(results);</div><div class="line">        uploadMessageAboveL = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码地址:<a href="https://github.com/BaronZ88/WebViewSample" target="_blank" rel="external">https://github.com/BaronZ88/WebViewSample</a></p>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近公司项目需要在&lt;code&gt;WebView&lt;/code&gt;上调用手机系统相册来上传图片，开发过程中发现在很多机器上无法正常唤起系统相册来选择图片。&lt;/p&gt;
&lt;p&gt;解决问题之前我们先来说说&lt;code&gt;WebView&lt;/code&gt;上传文件的逻辑：当我们在Web页面上点击选择文件的控件(&lt;code&gt;&amp;lt;input type=&amp;quot;file&amp;quot;&amp;gt;&lt;/code&gt;)时，会回调&lt;code&gt;WebChromeClient&lt;/code&gt;下的&lt;code&gt;openFileChooser()&lt;/code&gt;（5.0及以上系统回调&lt;code&gt;onShowFileChooser()&lt;/code&gt;）。这个时候我们在&lt;code&gt;openFileChooser&lt;/code&gt;方法中通过&lt;code&gt;Intent&lt;/code&gt;打开系统相册或者支持该&lt;code&gt;Intent&lt;/code&gt;的第三方应用来选择图片。like this：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openFileChooser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ValueCallback&amp;lt;Uri&amp;gt; valueCallback, String acceptType, String capture)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	uploadMessage = valueCallback;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   	openImageChooserActivity();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openImageChooserActivity&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Intent i = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_GET_CONTENT);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i.addCategory(Intent.CATEGORY_OPENABLE);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i.setType(&lt;span class=&quot;string&quot;&gt;&quot;image/*&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    startActivityForResult(Intent.createChooser(i,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    			&lt;span class=&quot;string&quot;&gt;&quot;Image Chooser&quot;&lt;/span&gt;), FILE_CHOOSER_RESULT_CODE);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://baronzhang.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="WebView" scheme="http://baronzhang.com/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式(ObserverPattern)</title>
    <link href="http://baronzhang.com//blog/DesignPatterns/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-ObserverPattern/"/>
    <id>http://baronzhang.com//blog/DesignPatterns/观察者模式-ObserverPattern/</id>
    <published>2017-02-05T16:16:14.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们接到一个来自气象局的需求：气象局需要我们构建一套系统，这系统有两个公告牌，分别用于显示当前的实时天气和未来几天的天气预报。当气象局发布新的天气数据（WeatherData）后，两个公告牌上显示的天气数据必须实时更新。气象局同时要求我们保证程序拥有足够的可扩展性，因为后期随时可能要新增新的公告牌。</p>
<a id="more"></a>
<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>这套系统中主要包括三个部分：气象站（获取天气数据的物理设备）、WeatherData（追踪来自气象站的数据，并更新公告牌）、公告牌（用于展示天气数据）</p>
<p><img src="http://ocjtywvav.bkt.clouddn.com/DesignPatterns/ObserverPattern/WeatherStation.png" alt="WeatherStation"></p>
<p>WeatherData知道如何跟气象站联系，以获得天气数据。当天气数据有更新时，WeatherData会更新两个公告牌用于展示新的天气数据。</p>
<h2 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h2><p>我们现来看看隔壁老王的实现思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//实例变量声明</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> temperature = getTemperature();</div><div class="line">        <span class="keyword">float</span> humidity = getHumidity();</div><div class="line">        <span class="keyword">float</span> pressure = getPressure();</div><div class="line">        List&lt;Float&gt; forecastTemperatures = getForecastTemperatures();</div><div class="line"></div><div class="line">        <span class="comment">//更新公告牌</span></div><div class="line">        currentConditionsDisplay.update(temperature, humidity, pressure);</div><div class="line">        forecastDisplay.update(forecastTemperatures);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码是典型的针对实现编程，这会导致我们以后增加或删除公告牌时必须修改程序。我们现在来看看观察者模式，然后再回来看看如何将观察者模式应用到这个程序。</p>
<h2 id="观察者模式介绍"><a href="#观察者模式介绍" class="headerlink" title="观察者模式介绍"></a>观察者模式介绍</h2><p>观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者（例如A不需要每隔1ms就检查一次B的状态），二是采用<strong>注册</strong>(<em>Register</em>)或者成为<strong>订阅</strong>(<em>Subscribe</em>)的方式告诉被观察者：我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。</p>
<p>观察者模式通常基于<strong>Subject</strong>和<strong>Observer</strong>接口类来设计，下面是是类图：<br><img src="http://ocjtywvav.bkt.clouddn.com/DesignPatterns/ObserverPattern/Observer.png" alt="Observer"></p>
<h2 id="观察者模式的应用"><a href="#观察者模式的应用" class="headerlink" title="观察者模式的应用"></a>观察者模式的应用</h2><p>结合上面的类图，我们现在将观察者模式应用到WeatherData项目中来。于是有了下面这张类图：<br><img src="http://ocjtywvav.bkt.clouddn.com/DesignPatterns/ObserverPattern/ObserverForWeatherStation.png" alt="ObserverForWeatherStation"></p>
<p><strong>主题接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 主题（发布者、被观察者）</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册观察者</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 移除观察者</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 通知观察者</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>观察者接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 观察者</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>公告牌用于显示的公共接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>下面我们再来看看WeatherData是如何实现的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;<span class="comment">//温度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;<span class="comment">//湿度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;<span class="comment">//气压</span></div><div class="line">    <span class="keyword">private</span> List&lt;Float&gt; forecastTemperatures;<span class="comment">//未来几天的温度</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observers.add(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observers.remove(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</div><div class="line">            observer.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</div><div class="line">        notifyObservers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity,</span></span></div><div class="line">    <span class="keyword">float</span> pressure, List&lt;Float&gt; forecastTemperatures) &#123;</div><div class="line">        <span class="keyword">this</span>.temperature = temperature;</div><div class="line">        <span class="keyword">this</span>.humidity = humidity;</div><div class="line">        <span class="keyword">this</span>.pressure = pressure;</div><div class="line">        <span class="keyword">this</span>.forecastTemperatures = forecastTemperatures;</div><div class="line">        measurementsChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> temperature;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> humidity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> pressure;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Float&gt; <span class="title">getForecastTemperatures</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> forecastTemperatures;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>显示当前天气的公告牌CurrentConditionsDisplay</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> WeatherData weatherData;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;<span class="comment">//温度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;<span class="comment">//湿度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;<span class="comment">//气压</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(WeatherData weatherData)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.weatherData = weatherData;</div><div class="line">        <span class="keyword">this</span>.weatherData.registerObserver(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"当前温度为："</span> + <span class="keyword">this</span>.temperature + <span class="string">"℃"</span>);</div><div class="line">        System.out.println(<span class="string">"当前湿度为："</span> + <span class="keyword">this</span>.humidity);</div><div class="line">        System.out.println(<span class="string">"当前气压为："</span> + <span class="keyword">this</span>.pressure);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.temperature = <span class="keyword">this</span>.weatherData.getTemperature();</div><div class="line">        <span class="keyword">this</span>.humidity = <span class="keyword">this</span>.weatherData.getHumidity();</div><div class="line">        <span class="keyword">this</span>.pressure = <span class="keyword">this</span>.weatherData.getPressure();</div><div class="line">        display();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>显示未来几天天气的公告牌ForecastDisplay</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForecastDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> WeatherData weatherData;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;Float&gt; forecastTemperatures;<span class="comment">//未来几天的温度</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForecastDisplay</span><span class="params">(WeatherData weatherData)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.weatherData = weatherData;</div><div class="line">        <span class="keyword">this</span>.weatherData.registerObserver(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"未来几天的气温"</span>);</div><div class="line">        <span class="keyword">int</span> count = forecastTemperatures.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"第"</span> + i + <span class="string">"天:"</span> + forecastTemperatures.get(i) + <span class="string">"℃"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.forecastTemperatures = <span class="keyword">this</span>.weatherData.getForecastTemperatures();</div><div class="line">        display();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，我们整个气象局的WeatherData应用就改造完成了。两个公告牌<code>CurrentConditionsDisplay</code>和<code>ForecastDisplay</code>实现了<code>Observer</code>和<code>DisplayElement</code>接口，在他们的构造方法中会调用<code>WeatherData</code>的<code>registerObserver</code>方法将自己注册成观察者，这样被观察者<code>WeatherData</code>就会持有观察者的应用，并将它们保存到一个集合中。当被观察者<code>`WeatherData</code>状态发送变化时就会遍历这个集合，循环调用观察者<code>公告牌</code>更新数据的方法。后面如果我们需要增加或者删除公告牌就只需要新增或者删除实现了<code>Observer</code>和<code>DisplayElement</code>接口的公告牌就好了。</p>
<p>观察者模式将观察者和主题（被观察者）彻底解耦，主题只知道观察者实现了某一接口（也就是Observer接口）。并不需要观察者的具体类是谁、做了些什么或者其他任何细节。任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西是一个实现了<code>Observer</code>接口的对象列表。</p>
<p>好了，我们测试下利用观察者模式重构后的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</div><div class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</div><div class="line">        ForecastDisplay forecastDisplay = <span class="keyword">new</span> ForecastDisplay(weatherData);</div><div class="line"></div><div class="line">        List&lt;Float&gt; forecastTemperatures = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</div><div class="line">        forecastTemperatures.add(<span class="number">22f</span>);</div><div class="line">        forecastTemperatures.add(-<span class="number">1f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">9f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">23f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">27f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">30f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">10f</span>);</div><div class="line">        weatherData.setMeasurements(<span class="number">22f</span>, <span class="number">0.8f</span>, <span class="number">1.2f</span>, forecastTemperatures);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<pre><code>当前温度为：22.0℃
当前湿度为：0.8
当前气压为：1.2
未来几天的气温
第0天:22.0℃
第1天:-1.0℃
第2天:9.0℃
第3天:23.0℃
第4天:27.0℃
第5天:30.0℃
第6天:10.0℃
</code></pre><blockquote>
<p>源码地址：<a href="https://github.com/BaronZ88/DesignPatterns/tree/master/src/com/baron/patterns/observer" target="_blank" rel="external">https://github.com/BaronZ88/DesignPatterns/tree/master/src/com/baron/patterns/observer</a></p>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;我们接到一个来自气象局的需求：气象局需要我们构建一套系统，这系统有两个公告牌，分别用于显示当前的实时天气和未来几天的天气预报。当气象局发布新的天气数据（WeatherData）后，两个公告牌上显示的天气数据必须实时更新。气象局同时要求我们保证程序拥有足够的可扩展性，因为后期随时可能要新增新的公告牌。&lt;/p&gt;
    
    </summary>
    
      <category term="DesignPatterns" scheme="http://baronzhang.com/categories/DesignPatterns/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
      <category term="Design Pattern" scheme="http://baronzhang.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>在Android项目中使用Java8</title>
    <link href="http://baronzhang.com//blog/Java/%E5%9C%A8Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Java8/"/>
    <id>http://baronzhang.com//blog/Java/在Android项目中使用Java8/</id>
    <published>2017-02-05T15:37:48.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在过去的文章中我介绍过Java8的一些新特性，包括：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/20540175" target="_blank" rel="external">Java8新特性第1章(Lambda表达式)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20540188" target="_blank" rel="external">Java8新特性第2章(接口默认方法)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20540202" target="_blank" rel="external">Java8新特性第3章(Stream API)</a></li>
</ol>
<p>之前由于Android平台不支持Java8，如果我们想在Android项目中使用Lambda表达式、Stream API等Java8中的新特性就必须使用Retrolambda、Lightweight-Stream-API等第三方开源库来实现。现在Google爸爸终于让Android平台支持Java8了，这篇文章中便来和大家聊聊如何在Android项目中配置使用Java8。</p>
<p>遗憾的是目前Android平台仅支持Java8的部分新特性，当我们在开发面向Android N及以上版本的应用时(即minSdkVersion&gt;=24)，可以使用如下新特性：</p>
<a id="more"></a>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="external">Lambda表达式(Lambda Expressions)</a>（也可以在minSdkVersion&lt;24的情况下使用）</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="external">方法引用(Method References)</a>（也可以在minSdkVersion&lt;24的情况下使用）</li>
<li><a href="http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html" target="_blank" rel="external">Stream API(Streams)</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="external">接口默认方法(Default Methods)</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="external">重复注解(Repeating Annotations)</a></li>
</ul>
<p>简单的说就是现在你的项目要想使用Stream API、接口默认方法和重复注解就要求你的minSdkVersion&gt;=24，而Lambda表达式和方法引用则对minSdkVersion无要求。关于这些新特的使用及分析可以看看我之前的文章。</p>
<h2 id="Jack-Java-Android-Compiler-Kit"><a href="#Jack-Java-Android-Compiler-Kit" class="headerlink" title="Jack(Java Android Compiler Kit)"></a>Jack(Java Android Compiler Kit)</h2><p>要想在Android项目中使用Java8的新特性，需要将你的Android Studio升级到2.1及以上版本，并采用新的Jack(Java Android Compiler Kit)编译。新的 Android 工具链将 Java 源语言编译成 Android 可读取的 Dalvik 可执行文件字节码，且有其自己的 .jack 库格式，在一个工具中提供了大多数工具链功能：重新打包、压缩、模糊化以及 Dalvik 可执行文件分包。</p>
<p>以下是构建 Android Dalvik 可执行文件可用的两种工具链的对比：</p>
<ul>
<li>旧版 javac 工具链：  <font color="ff0000"> <code>javac (.java --&gt; .class) --&gt; dx (.class --&gt; .dex)</code> </font></li>
<li>新版 Jack 工具链：  <font color="ff0000"> <code>Jack (.java --&gt; .jack --&gt; .dex)</code> </font>

</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为了在项目中使用Java8，我们还需要项目module中的gradle.build文件中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line"></div><div class="line">  compileSdkVersion <span class="number">24</span></div><div class="line">  buildToolsVersion <span class="string">"24.0.3"</span></div><div class="line"></div><div class="line">  defaultConfig &#123;</div><div class="line"></div><div class="line">    applicationId <span class="string">"me.baron.hellojava8"</span></div><div class="line">    minSdkVersion <span class="number">24</span></div><div class="line">    targetSdkVersion <span class="number">24</span></div><div class="line">    versionCode <span class="number">1</span></div><div class="line">    versionName <span class="string">"1.0"</span></div><div class="line"></div><div class="line">    jackOptions &#123;</div><div class="line">      enabled <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  compileOptions &#123;</div><div class="line">    sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">    targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进行上述配置后大家就可以在Android项目中尽情的探索使用Java8的新特性了。比如之前我们实现button的点击事件时需要这这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">		v.setText(<span class="string">"lalala"</span>);</div><div class="line">   	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在我们便可以使用Java8的Lambda表达式来实现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(v -&gt; v.setText(<span class="string">"lalala"</span>));</div></pre></td></tr></table></figure>
<p>如果你项目的minSdkVersion&gt;=24，我们还可以使用Stream API。比方说有一个形状集合shapes，现在我们想把所有蓝色的形状提取到新的List里。通过Stream API则可以很轻易的办到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Shape&gt; blue = shapes.stream()</div><div class="line">	.filter(s -&gt; s.getColor() == BLUE)</div><div class="line">	.collect(Collectors.toList());</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java8的新特性并不是本文的重点，对此有兴趣的同学可以去翻看我之前的文章。当前Jack编译器还有诸多限制，比如在使用新的Jack工具链时会禁用Instant Run以及前面提到的新特性对我们的最低支持版本和编译版本有要求等等(我猜想Jack对Buck、Layoutcast、Freeline等编译方案也会有影响，没做过验证，有了解的同学可以在评论区留言和大家交流下)；总之要想在Android项目中愉快的使用Java8全部的新特性还需时日。期待Google爸爸尽快优化吧！</p>
<p>参考资料：</p>
<ul>
<li><a href="https://developer.android.com/guide/platform/j8-jack.html" target="_blank" rel="external">https://developer.android.com/guide/platform/j8-jack.html</a></li>
<li><a href="https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad" target="_blank" rel="external">https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad</a></li>
</ul>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在过去的文章中我介绍过Java8的一些新特性，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20540175&quot;&gt;Java8新特性第1章(Lambda表达式)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20540188&quot;&gt;Java8新特性第2章(接口默认方法)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20540202&quot;&gt;Java8新特性第3章(Stream API)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前由于Android平台不支持Java8，如果我们想在Android项目中使用Lambda表达式、Stream API等Java8中的新特性就必须使用Retrolambda、Lightweight-Stream-API等第三方开源库来实现。现在Google爸爸终于让Android平台支持Java8了，这篇文章中便来和大家聊聊如何在Android项目中配置使用Java8。&lt;/p&gt;
&lt;p&gt;遗憾的是目前Android平台仅支持Java8的部分新特性，当我们在开发面向Android N及以上版本的应用时(即minSdkVersion&amp;gt;=24)，可以使用如下新特性：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://baronzhang.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性第3章(Stream API)</title>
    <link href="http://baronzhang.com//blog/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%AC3%E7%AB%A0-Stream-API/"/>
    <id>http://baronzhang.com//blog/Java/Java8新特性第3章-Stream-API/</id>
    <published>2017-02-05T15:37:32.000Z</published>
    <updated>2017-12-26T06:47:02.449Z</updated>
    
    <content type="html"><![CDATA[<p>Stream作为Java8的新特性之一，他与Java IO包中的InputStream和OutputStream完全不是一个概念。Java8中的Stream是对集合功能的一种增强，主要用于对集合对象进行各种非常便利高效的聚合和大批量数据的操作。结合Lambda表达式可以极大的提高开发效率和代码可读性。</p>
<p>假设我们需要把一个集合中的所有形状设置成红色，那么我们可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Shape shape : shapes)&#123;</div><div class="line">	shape.setColor(RED)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用Java8扩展后的集合框架则可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shapes.foreach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>第一种</strong>写法我们叫外部迭代，for-each调用<code>shapes</code>的<code>iterator()</code>依次遍历集合中的元素。这种外部迭代有一些问题：</p>
<ul>
<li>for循环是串行的，而且必须按照集合中元素的顺序依次进行；</li>
<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路求值以及惰性求值改善性能。<blockquote>
<p>上面这两个问题我们会在后面的文章中逐步解答。</p>
</blockquote>
</li>
</ul>
<p><strong>第二种</strong>写法我们叫内部迭代，两段代码虽然看起来只是语法上的区别，但实际上他们内部的区别其实非常大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>
<p>外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历），而内部迭代只负责做什么，而把怎么做留给类库。这样代码会变得更加清晰，而集合类库则可以在内部进行各种优化。</p>
<h2 id="一、什么是Stream"><a href="#一、什么是Stream" class="headerlink" title="一、什么是Stream"></a>一、什么是Stream</h2><p>Stream不是集合元素，它也不是数据结构、不能保存数据，它更像一个更高级的<code>Interator</code>。Stream提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。流的操作可以被组合成流水线（Pipeline）。拿前面的例子来说，如果我只想把蓝色改成红色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shapes.stream()</div><div class="line">      .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">      .forEach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure>
<p>在<code>Collection</code>上调用<code>stream()</code>会生成该集合元素的流，接下来<code>filter()</code>操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被<code>forEach</code>操作设为红色。</p>
<p>如果我们想把蓝色的形状提取到新的List里，则可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Shape&gt; blue = shapes.stream()</div><div class="line">						  .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">						  .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><code>collect()</code>操作会把其接收的元素聚集到一起（这里是List），<code>collect()</code>方法的参数则被用来指定如何进行聚集操作。在这里我们使用<code>toList()</code>以把元素输出到List中。</p>
<p>如果每个形状都被保存在<code>Box</code>里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Set&lt;Box&gt; hasBlueShape = shapes.stream()</div><div class="line">        .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">        .map(s -&gt; s.getContainingBox())</div><div class="line">        .collect(Collectors.toSet());</div></pre></td></tr></table></figure>
<p><code>map()</code>操作符通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>
<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">int sum = shapes.stream()</div><div class="line">        .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">        .mapToInt(s -&gt; s.getWeight())</div><div class="line">        .sum();</div><div class="line">```            </div><div class="line"></div><div class="line"></div><div class="line">## 二、Stream vs Collection</div><div class="line"></div><div class="line">流（Stream）和集合（Collection）的区别：</div><div class="line"></div><div class="line">* Collection主要用来对元素进行管理和访问；</div><div class="line">* Stream并不支持对其元素进行直接操作和直接访问，而只支持通过声明式操作在其之上进行运算后得到结果；</div><div class="line">* Stream不存储值</div><div class="line">* 对Stream的操作会产生一个结果，但是Stream并不会改变数据源；</div><div class="line">* 大多数Stream的操作(filter,map,sort等)都是以惰性的方式实现的。这使得我们可以使用一次遍历完成整个流水线操作,并可以用短路操作提供更高效的实现。</div><div class="line"></div><div class="line"></div><div class="line">## 三、惰性求值 vs 急性求值</div><div class="line"></div><div class="line">`filter()`和`map()`这样的操作既可以被急性求值（以`filter()`为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被惰性求值（用`Stream`代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）</div><div class="line"></div><div class="line">对于`filter()`和`map()`这样的操作符，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像`sum()`这样生成值的操作和`forEach()`这样产生副作用的操作都是__天然急性求值__，因为它们必须要产生具体的结果。</div><div class="line"></div><div class="line">我们拿下面这段代码举例：</div><div class="line"></div><div class="line">```java</div><div class="line">int sum = shapes.stream()</div><div class="line">        .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">        .mapToInt(s -&gt; s.getWeight())</div><div class="line">        .sum();</div><div class="line">```                </div><div class="line"></div><div class="line">这里的`filter()`和`map()`都是惰性的，这就意味着在调用`sum()`之前不会从数据源中提取任何元素。在`sum()`操作之后才会把`filter()`、`map()`和`sum()`放在对数据源一次遍历中。这样可以大大减少维持中间结果所带来的开销。</div><div class="line"></div><div class="line"></div><div class="line">## 四、举个栗子🌰</div><div class="line"></div><div class="line">前面长篇大论的介绍概念实在太枯燥，为了方便大家理解我们用Streams API来实现一个具体的业务场景。</div><div class="line"></div><div class="line">假设我们有一个房源库项目，这个房源库中有一系列的小区，每个小区都有小区名和房源列表，每套房子又有价格、面积等属性。现在我们需要筛选出含有100平米以上房源的小区，并按照小区名排序。</div><div class="line"></div><div class="line">我们先来看看不用Streams API如何实现：</div><div class="line"></div><div class="line"></div><div class="line">```java</div><div class="line">List&lt;Community&gt; result = new ArrayList&lt;&gt;();</div><div class="line">for (Community community : communities) &#123;</div><div class="line">        for (House house : community.houses) &#123;</div><div class="line">            if (house.area &gt; 100) &#123;</div><div class="line">                result.add(community);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Collections.sort(result, new Comparator&lt;Community&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public int compare(Community c1, Community c2) &#123;</div><div class="line">            return c1.name.compareTo(c2.name);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return result;</div></pre></td></tr></table></figure>
<p>如果使用Streams API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> communities.stream()</div><div class="line">          .filter(c -&gt; c.houses.stream().anyMatch(h -&gt; h.area&gt;<span class="number">100</span>))</div><div class="line">          .sorted(Comparator.comparing(c -&gt; c.name))</div><div class="line">          .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Stream作为Java8的新特性之一，他与Java IO包中的InputStream和OutputStream完全不是一个概念。Java8中的Stream是对集合功能的一种增强，主要用于对集合对象进行各种非常便利高效的聚合和大批量数据的操作。结合Lambda表达式可以极大的提高开发效率和代码可读性。&lt;/p&gt;
&lt;p&gt;假设我们需要把一个集合中的所有形状设置成红色，那么我们可以这样写&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Shape shape : shapes)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	shape.setColor(RED)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果使用Java8扩展后的集合框架则可以这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;shapes.foreach(s -&amp;gt; s.setColor(RED));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://baronzhang.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性第2章(接口默认方法)</title>
    <link href="http://baronzhang.com//blog/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%AC2%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    <id>http://baronzhang.com//blog/Java/Java8新特性第2章-接口默认方法/</id>
    <published>2017-02-05T15:37:11.000Z</published>
    <updated>2017-06-12T15:39:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在Java中一个接口一旦发布就已经被定型，除非我们能够一次性的更新所有该接口的实现，否者在接口的添加新方法将会破坏现有接口的实现。默认方法就是为了解决这一问题的，这样接口在发布之后依然能够继续演化。</p>
<p>默认方法就是向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或者是默认的。默认方法拥有默认实现，接口实现类通过继承得到该默认实现。默认方法不是抽象的，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口单抽象方法的限制。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(action);</div><div class="line">        <span class="keyword">while</span> (hasNext())</div><div class="line">            action.accept(next());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和其他方法一样，默认方法也可以被继承。</p>
<p>除了上面看到的默认方法，Java8中还允许我们在接口中定义静态方法。这使得我们可以从接口中直接调用它相关的辅助方法，而不是从其它的辅助类中调用（如Collections）。在做集合中元素比较的时候，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java8中我们可以直接把该静态方法定义在Comparator接口中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt;? <span class="keyword">super</span> U&gt;&gt;</div><div class="line">    <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(Function&lt;T, U&gt; keyExtractor)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在Java中一个接口一旦发布就已经被定型，除非我们能够一次性的更新所有该接口的实现，否者在接口的添加新方法将会破坏现有接口的实现。默认方法就是为了解决这一问题的，这样接口在发布之后依然能够继续演化。&lt;/p&gt;
&lt;p&gt;默认方法就是向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或者是默认的。默认方法拥有默认实现，接口实现类通过继承得到该默认实现。默认方法不是抽象的，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口单抽象方法的限制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://baronzhang.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性第1章(Lambda表达式)</title>
    <link href="http://baronzhang.com//blog/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%AC1%E7%AB%A0-Lambda%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://baronzhang.com//blog/Java/Java8新特性第1章-Lambda表达式/</id>
    <published>2017-02-05T06:24:30.000Z</published>
    <updated>2017-12-26T06:47:04.941Z</updated>
    
    <content type="html"><![CDATA[<p>在介绍Lambda表达式之前，我们先来看只有单个方法的Interface（通常我们称之为回调接口）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnClickListener</span> </span>&#123;</div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们是这样使用它的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">		v.setText(<span class="string">"lalala"</span>);</div><div class="line">   	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种回调模式在各种框架中非常流行,但是像上面这样的匿名内部类并不是一个好的选择，因为：</p>
<ul>
<li>语法冗余；</li>
<li>匿名内部类中的this指针和变量容易产生误解；</li>
<li>无法捕获非final局部变量；</li>
<li>非静态内部类默认持有外部类的引用，部分情况下会导致外部类无法被GC回收，导致内存泄露。</li>
</ul>
<a id="more"></a>
<p>令人高兴的是Java8为我们带来了Lambda,下面我们看看利用Lambda如何实现上面的功能：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(v -&gt; v.setText(<span class="string">"lalala"</span>));</div></pre></td></tr></table></figure>
<p>怎么样？！五行代码用一行就搞定了！！！</p>
<blockquote>
<p>在这里补充个概念<code>函数式接口</code>；前面提到的OnClickListener接口只有一个方法，Java中大多数回调接口都有这个特征：比如Runnable和Comparator；我们把这些只拥有一个方法的接口称之为<code>函数式接口</code>。</p>
</blockquote>
<h2 id="一、Lambda表达式"><a href="#一、Lambda表达式" class="headerlink" title="一、Lambda表达式"></a>一、Lambda表达式</h2><p>匿名内部类最大的问题在于其冗余的语法，比如前面的OnClickListener中五行代码仅有一行是在执行任务。Lambda表达式是匿名方法，前面我们也看到了它用极其轻量的语法解决了这一问题。</p>
<p>下面给大家看几个Lambda表达式的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">(<span class="keyword">int</span> x, <span class="keyword">int</span> y) -&gt; x + y                      <span class="comment">//接收x和y两个整形参数并返回他们的和</span></div><div class="line">() -&gt; <span class="number">66</span>                                     <span class="comment">//不接收任何参数直接返回66</span></div><div class="line">(String name) -&gt; &#123;System.out.println(name);&#125; <span class="comment">//接收一个字符串然后打印出来</span></div><div class="line">(View view) -&gt; &#123;view.setText(<span class="string">"lalala"</span>);&#125;     <span class="comment">//接收一个View对象并调用setText方法</span></div></pre></td></tr></table></figure>
<p>Lambda表达式语法由<code>参数列表</code>、<code>-&gt;</code>和<code>函数体</code>组成。函数体既可以是一个表达式也可以是一个代码块。</p>
<ul>
<li><strong>表达式</strong>：表达式会被执行然后返回结果。它简化掉了<code>return</code>关键字。</li>
<li><strong>代码块</strong>：顾名思义就是一坨代码，和普通方法中的语句一样。</li>
</ul>
<!--lambda经常出现在嵌套环境中，如作为方法的参数：

    Runnable runnable = () -> {doSomething();};
    new Thread(runnable);

    //也可以这样写
    new Thread(() -> {doSomething();});-->
<h2 id="二、目标类型"><a href="#二、目标类型" class="headerlink" title="二、目标类型"></a>二、目标类型</h2><p>通过前面的例子我们可以看到，lambda表达式没有名字，那我们怎么知道它的类型呢？答案是通过上下文推导而来的。例如，下面的表达式的类型是<code>OnClickListener</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OnClickListener listener = (View v) -&gt; &#123;v.setText(<span class="string">"lalala"</span>);&#125;;</div></pre></td></tr></table></figure>
<p>这就意味着同样的lambda表达式在不同的上下文里有不同的类型</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Runnable runnable = () -&gt; doSomething();  <span class="comment">//这个表达式是Runnable类型的</span></div><div class="line">Callback callback = () -&gt; doSomething();  <span class="comment">//这个表达式是Callback类型的</span></div></pre></td></tr></table></figure>
<p>编译器利用lambda表达式所在的上下文所期待的类型来推导表达式的类型，这个<strong>被期待的类型</strong>被称为<code>目标类型</code>。lambda表达式只能出现在<strong>目标类型</strong>为<code>函数式接口</code>的上下文中。</p>
<p>Lambda表达式的类型和目标类型的方法签名必须一致，编译器会对此做检查，一个lambda表达式要想赋值给目标类型<code>T</code>则必须满足下面所有的条件：</p>
<ul>
<li><code>T</code>是一个函数式接口</li>
<li>lambda表达式的参数必须和<code>T</code>的方法参数在数量、类型和顺序上一致（一一对应）</li>
<li>lambda表达式的返回值必须和<code>T</code>的方法的返回值一致或者是它的子类</li>
<li>lambda表达式抛出的异常和<code>T</code>的方法的异常一致或者是它的子类</li>
</ul>
<p>由于目标类型是知道lambda表达式的参数类型，所以我们没必要把已知的类型重复一遍。也就是说lambda表达式的参数类型可以从目标类型获取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//编译器可以推导出s1和s2是String类型</span></div><div class="line">Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareTo(s2);</div><div class="line"><span class="comment">//当表达式的参数只有一个时括号也是可以省略的</span></div><div class="line">button.setOnClickListener(v -&gt; v.setText(<span class="string">"lalala"</span>));</div></pre></td></tr></table></figure>
<blockquote>
<p>Java7中的泛型方法和&lt;&gt;构造器也是通过目标类型来进行类型推导的,如：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&gt;List&lt;Integer&gt; intList = Collections.emptyList&lt;&gt;();</div><div class="line">&gt;List&lt;String&gt; strList = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<h2 id="三、作用域"><a href="#三、作用域" class="headerlink" title="三、作用域"></a>三、作用域</h2><p>在内部类中使用变量名和this非常容易出错。内部类通过继承得到的成员变量（包括来说object的）可能会把外部类的成员变量覆盖掉，未做限制的this引用会指向内部类自己而非外部类。</p>
<p>而lambda表达式的语义就十分简单：它不会从父类中继承任何变量，也不用引入新的作用域。lambda表达式的参数及函数体里面的变量和它外部环境的变量具有相同的语义（this关键字也是一样）。</p>
<p>下面我们举个栗子吧!</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloLambda</span> </span>&#123;</div><div class="line"></div><div class="line">    Runnable r1 = () -&gt; System.out.println(<span class="keyword">this</span>);</div><div class="line">    Runnable r2 = () -&gt; System.out.println(toString());</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"Hello, lambda!"</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        <span class="keyword">new</span> HelloLambda().r1.run();  </div><div class="line">        <span class="keyword">new</span> HelloLambda().r2.run();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码最终会打印两个<code>Hello, lambda!</code>，与之相类似的内部类则会打印出类似<code>HelloLambda$1@32a890</code>和<code>HelloLambda$1@6b32098</code>这种出乎意料的字符串。</p>
<p>总结：基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文的局部变量。</p>
<h2 id="四、变量捕获"><a href="#四、变量捕获" class="headerlink" title="四、变量捕获"></a>四、变量捕获</h2><p>在Java7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为<code>final</code>就会产生一个编译错误。但是在Java8中放宽了这一限制–对于lambda表达式和内部类，允许在其中捕获那些符合有效只读的局部变量（如果一个局部变量在初始化后从未被修改过，那么它就是有效只读）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function">Runnable <span class="title">getRunnable</span><span class="params">(String name)</span></span>&#123;</div><div class="line">    String hello = <span class="string">"hello"</span>;</div><div class="line">    <span class="keyword">return</span> () -&gt; System.out.println(hello+<span class="string">","</span>+name);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>对于<code>this</code>的引用以及通过<code>this</code>对未限定字段的引用和未限定方法的调用本质上都属于使用<code>final</code>局部变量。包含此类引用的lambda表达式相当于捕获了<code>this</code>实例。在其他情况下，lambda对象不会保留任何对<code>this</code>的应用。</p>
<p>这个特性对内存管理是极好的：要知道在java中一个非静态内部类会默认持有外部类实例的强引用，这往往会造成内存泄露。而在lambda表达式中如果没有捕获外部类成员则不会保留对外部类实例的引用。</p>
<p>不过尽管Java8放宽了对捕获变量的语法限制，但试图修改捕获变量的行为是被禁止的，比如下面这个例子就是非法的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">int</span> sum  = <span class="number">0</span>;</div><div class="line">list.forEach(i -&gt; &#123;sum += i;&#125;);</div></pre></td></tr></table></figure>
<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起<a href="https://zh.wikipedia.org/zh-cn/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3" target="_blank" rel="external">race condition</a></p>
<p>lambda表达式不支持修改捕获变量的另外一个原因是我们可以使用更好的方式来实现同样的效果：使用规约(condition)。java.util.stream包提供了各种规约操作，关于Java8中的<code>Stream API</code>我们放到下一章介绍。</p>
<h2 id="五、方法引用"><a href="#五、方法引用" class="headerlink" title="五、方法引用"></a>五、方法引用</h2><p>lambda表达式允许我们定义一个匿名方法，并以函数式接口的方式使用它。Java8能够在已有的方法上实现同样的特性。</p>
<p>方法引用和lambda表达式拥有相同的特性（他们都需要一个目标类型，并且需要被转化为函数式接口的实例）,不过我们不需要为方法引用提供方法体，我们可以直接通过方法名引用已有方法。</p>
<p>以下面的代码为例，假设我们要按照<code>userName</code>排序</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">User</span></span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String userName;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getUserName</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> userName;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div><div class="line"></div><div class="line">List&lt;User&gt; users = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">Comparator&lt;User&gt; comparator = Comparator.comparing(u -&gt; u.getUserName());</div><div class="line">Collections.sort(users, comparator);</div></pre></td></tr></table></figure>
<p>我们可以用方法引用替换上面的lambda表达式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Comparator&lt;User&gt; comparator = Comparator.comparing(User::getUserName);</div></pre></td></tr></table></figure>
<p>这里的<code>User::getUserName</code>被看做是lambda表达式的简写形式。尽管方法引用不一定会把代码变得更紧凑，但它拥有更明确的语义–如果我们想要调用的方法拥有一个名字，那么我们就可以通过方法名调用它。</p>
<!--因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：

    Consumer<Integer> b1 = System::exit;    // void exit(int status)
    Consumer<String[]> b2 = Arrays:sort;    // void sort(Object[] a)
    Consumer<String> b3 = MyProgram::main;  // void main(String... args)
    Runnable r = Myprogram::mapToInt        // void main(String... args)-->
<p>方法引用有很多种，它们的语法如下：</p>
<ul>
<li>静态方法引用：ClassName::methodName</li>
<li>实例上的实例方法引用：instanceReference::methodName</li>
<li>超类上的实例方法引用：super::methodName</li>
<li>类型上的实例方法引用：ClassName::methodName</li>
<li>构造方法引用：Class::new</li>
<li>数组构造方法引用：TypeName[]::new</li>
</ul>
<blockquote>
<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>
<ul>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在介绍Lambda表达式之前，我们先来看只有单个方法的Interface（通常我们称之为回调接口）：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;interface&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;OnClickListener&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(View v)&lt;/span&gt;&lt;/span&gt;;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我们是这样使用它的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;button.setOnClickListener(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; View.OnClickListener() &amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;meta&quot;&gt;@Override&lt;/span&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;onClick&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(View v)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;		v.setText(&lt;span class=&quot;string&quot;&gt;&quot;lalala&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   	&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;);&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这种回调模式在各种框架中非常流行,但是像上面这样的匿名内部类并不是一个好的选择，因为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语法冗余；&lt;/li&gt;
&lt;li&gt;匿名内部类中的this指针和变量容易产生误解；&lt;/li&gt;
&lt;li&gt;无法捕获非final局部变量；&lt;/li&gt;
&lt;li&gt;非静态内部类默认持有外部类的引用，部分情况下会导致外部类无法被GC回收，导致内存泄露。&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="Java" scheme="http://baronzhang.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
  </entry>
  
</feed>
