<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术男的后花园</title>
  <subtitle>公众号：BaronTalk</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://baronzhang.com/"/>
  <updated>2019-08-19T16:59:35.559Z</updated>
  <id>http://baronzhang.com/</id>
  
  <author>
    <name>张磊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>邮件这样写，PK 掉 99% 的同事</title>
    <link href="http://baronzhang.com//blog/uncategorized/%E9%82%AE%E4%BB%B6%E8%BF%99%E6%A0%B7%E5%86%99%EF%BC%8CPK-%E6%8E%89-99-%E7%9A%84%E5%90%8C%E4%BA%8B/"/>
    <id>http://baronzhang.com//blog/uncategorized/邮件这样写，PK-掉-99-的同事/</id>
    <published>2019-08-19T16:55:25.000Z</published>
    <updated>2019-08-19T16:59:35.559Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>首发于微信公众号：<strong>BaronTalk</strong>，欢迎关注！</p>
</blockquote>
<p>工作中总免不了需要正式的邮件来沟通协调工作，有跨大团队沟通的，也有向老板汇报工作情况的。每每此时，总是小心谨慎，邮件发出后又常洋洋自得，总觉得自己的邮件条理清晰、结构合理、内容详实，横竖都算得上是专业度颇高的邮件了。</p>
<p>可事后回头来看，又觉之前的邮件颇有些青涩稚嫩，不恰当处比比皆是。细细推敲下来，我们在日常职场中的邮件写作还是有些讲究的。因此今天我们就来聊聊如何写好一封职场邮件。</p>
<h2 id="一-金字塔结构"><a href="#一-金字塔结构" class="headerlink" title="一. 金字塔结构"></a>一. 金字塔结构</h2><p>如果让我说邮件写作中最重要的是什么，那我首选「结构」。无论是写代码还是写文章，我都有一个习惯：先搭框架，再填充内容。写邮件也当如此，结构合理清晰了，读者才有代入感，才能顺着你的逻辑走下去。</p>
<p>在这个每天被各种邮件狂轰乱炸的职场，没人有功夫看你抽丝剥茧、娓娓道来，而后再提炼精髓，总结主题。大家要的是开宗明义，两三句话概括邮件主旨。因此在绝大多数的职场邮件写作应遵循自上而下的「金字塔结构」。</p>
<a id="more"></a>
<p>所谓金字塔结构就是邮件正文的一种组织方式，是用向下想三层的逻辑自上而下的来搭建邮件主体。金字塔的塔尖是邮件的主题，是鲜明的观点或者结论，是邮件的中心思想；下面两层是证据，是对中心思想的层层展开，用来阐述、论证塔尖的观点和结论。</p>
<p>举个例子，你要向老板汇报下个季度的工作计划，邮件开篇就要说明本次沟通的目的。比如：</p>
<blockquote>
<p>我给你写邮件是向你汇报下季度的工作计划：开发App性能监控组件。</p>
</blockquote>
<p>(<em>ps: 公众号后续会分享 Android 性能监控框架的系列文章，欢迎关注</em>)</p>
<p>老板自然会问：</p>
<blockquote>
<p>为什么？</p>
</blockquote>
<p>这就到了金字塔的第二层：</p>
<blockquote>
<p>因为需要为用户提供高质量的使用体验；</p>
<p>因为需要量化团队成员的工作质量。</p>
</blockquote>
<p>老板接着会问：</p>
<blockquote>
<p>提供高质量的使用体验 – 怎么提升？</p>
<p>量化团队成员工作质量 – 怎么量化？</p>
</blockquote>
<p>接下来金字塔进入第三层：</p>
<blockquote>
<p>针对「提供高质量的使用体验」这一点：我们需要监控网络请求、App 耗电量、FPS等，发现问题并针对性的优化；</p>
<p>针对「量化团队成员工作质量」这一点：我们需要考核工程师开发页面的平均响应时间、ANR、内存开销等。</p>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/other/mail/金字塔结构.png" width="70%"></div>

<p>我们需要从作者思维切换到读者思维，金字塔结构的写作方式就是一种读者思维的体现。站在读者的角度来思考，读者才能和你共情，信息的传递效率才会更高。</p>
<h2 id="二-邮件写作中的小技巧"><a href="#二-邮件写作中的小技巧" class="headerlink" title="二. 邮件写作中的小技巧"></a>二. 邮件写作中的小技巧</h2><p>除了前面介绍的金字塔结构，职场邮件中也很多小细节、小技巧是需要我们注意的。往往正是这些小细节体现了我们的职业化程度，所谓「寻常之处见功力，细微之处见真章」正是如此。</p>
<p>下面我从收件人、标题、正文、落款及签名四个方面来简单介绍一下。</p>
<h3 id="2-1-收件人"><a href="#2-1-收件人" class="headerlink" title="2.1 收件人"></a>2.1 收件人</h3><p>发送给（TO）需要知悉且需要回复的人，抄送给（CC）需要知悉但不需要回复的人，通常不使用密送（BCC）；注意控制收件人范围，尽量不要打扰到无关的人。这里有个小技巧，收件人可以到最后填写，避免出现邮件写到一半误发出去的尴尬。</p>
<h3 id="2-2-标题"><a href="#2-2-标题" class="headerlink" title="2.2 标题"></a>2.2 标题</h3><p>标题要简单，直击主题。如果是特别重要或者紧急的事，可以加上「【重要】」、「【紧急】」这样的标签；需要老板批示的，可以在标题后面接上「请批示」；对于谈论过很多轮的邮件，不要「re:re:re:xxx」这样一直 re 下去，可以保留最后一个 re 然后加上一个主标题，比如「线上问题已修复；re:关于线上出现大面积崩溃的情况通知」等等。</p>
<h3 id="2-3-正文"><a href="#2-3-正文" class="headerlink" title="2.3 正文"></a>2.3 正文</h3><p><strong>语言要有温度</strong></p>
<p>文字是冰冷的，职场是严肃的，但人是有温度的，我们的语言表达也应该是温情的。邮件的开头除了前面所说的要开宗明义，表明主题，还可以有一些暖场。这一点是从戴愫老师的职场写作课上学到的， 这里我就借用一下其中的一些范例。比如：</p>
<blockquote>
<p>嘿，刚刚的发言很精彩！（这句话用在某次的电话会议之后的邮件开头）</p>
<p>欢迎收获可爱宝宝的人回归团队。（这句话用在对方刚休完产假回来）</p>
</blockquote>
<p>有温度的语言能快速拉任何人之间的距离，职场中关系近了，很多事情就简单了，这一点大家在日常的工作中一定也深有感触。</p>
<p><strong>立场要清晰，语气要尊重</strong></p>
<p>在表达观点是立场是一定要明确清晰的，但是语气得让人感受到尊重，你不是在下命令，也没有夹杂个人情绪。理由和前面一样。</p>
<p><strong>能分段就分，能加小标题就加</strong></p>
<p>分段和加标题是为了梳理逻辑，降低读者的阅读难度。</p>
<p><strong>文不如表，表不如图</strong></p>
<p>对于复杂事物的描述，表格远比文字更生动，更让人记忆深刻，图形相较于表格则又更胜一筹。因此能用图表示的复杂信息就不要用表格，能用表格表示的就不要用文字。</p>
<p><strong>少说废话</strong></p>
<p>职场写作要遵循 KISS 原则：Keep it short and sample，能不说的就不说，该精简的就精简。把那些「我以为」、「我觉得」、「大概可能」从你的文字里剔除掉，意思重复的内容删掉，压缩 20~30% 的内容是很容易的。说白了就是，大家都很忙，没事别逼逼。</p>
<p><strong>合理利用冗余信息</strong></p>
<p>信息的传递是很容易产生歧义的，特别是一些复杂信息。因此我们可以适当的利用冗余信息从不同的角度来论证观点，方便读者做交叉验证。有人可能会说，这不就和前面的「少说废话」矛盾了吗？其实不然，文字要精简，内容要详实。</p>
<h3 id="2-4-落款及签名"><a href="#2-4-落款及签名" class="headerlink" title="2.4 落款及签名"></a>2.4 落款及签名</h3><p>很多问题不是单纯的邮件沟通就可以解决的，落款和签名是让大家了解你，方便线下联系。因此你的邮件签名里需要注明你的部门、职位和联系方式。</p>
<p>凡事过犹不及，以上种种，只是一个职场邮件写作的大方向，切忌生搬硬套。</p>
<h2 id="三-写在最后"><a href="#三-写在最后" class="headerlink" title="三. 写在最后"></a>三. 写在最后</h2><p>职场中的每一个人都有一张看不见的个人名片，每个人都在或有意或无意的经营着自己的个人品牌。你的老板、同事、下属是否认可你，你是否有足够的话语权和领导力，很大程度上取决于你的个人品牌经营的是否成功，而个人品牌正是从一件又一件小事建立起来的。</p>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首发于微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，欢迎关注！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;工作中总免不了需要正式的邮件来沟通协调工作，有跨大团队沟通的，也有向老板汇报工作情况的。每每此时，总是小心谨慎，邮件发出后又常洋洋自得，总觉得自己的邮件条理清晰、结构合理、内容详实，横竖都算得上是专业度颇高的邮件了。&lt;/p&gt;
&lt;p&gt;可事后回头来看，又觉之前的邮件颇有些青涩稚嫩，不恰当处比比皆是。细细推敲下来，我们在日常职场中的邮件写作还是有些讲究的。因此今天我们就来聊聊如何写好一封职场邮件。&lt;/p&gt;
&lt;h2 id=&quot;一-金字塔结构&quot;&gt;&lt;a href=&quot;#一-金字塔结构&quot; class=&quot;headerlink&quot; title=&quot;一. 金字塔结构&quot;&gt;&lt;/a&gt;一. 金字塔结构&lt;/h2&gt;&lt;p&gt;如果让我说邮件写作中最重要的是什么，那我首选「结构」。无论是写代码还是写文章，我都有一个习惯：先搭框架，再填充内容。写邮件也当如此，结构合理清晰了，读者才有代入感，才能顺着你的逻辑走下去。&lt;/p&gt;
&lt;p&gt;在这个每天被各种邮件狂轰乱炸的职场，没人有功夫看你抽丝剥茧、娓娓道来，而后再提炼精髓，总结主题。大家要的是开宗明义，两三句话概括邮件主旨。因此在绝大多数的职场邮件写作应遵循自上而下的「金字塔结构」。&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>系列 | 深入理解Java虚拟机六（高效并发）</title>
    <link href="http://baronzhang.com//blog/JVM/%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%85%AD%EF%BC%88%E9%AB%98%E6%95%88%E5%B9%B6%E5%8F%91%EF%BC%89/"/>
    <id>http://baronzhang.com//blog/JVM/系列-深入理解Java虚拟机六（高效并发）/</id>
    <published>2019-08-19T16:27:27.000Z</published>
    <updated>2019-08-19T17:00:26.019Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>首发于微信公众号：<strong>BaronTalk</strong>，欢迎关注！</p>
</blockquote>
<p>高效并发是 JVM 系列的最后一篇，本篇主要介绍虚拟机如何实现多线程、多线程间如何共享和竞争数据以及共享和竞争数据带来的问题及解决方案。</p>
<h2 id="一、Java-内存模型与线程"><a href="#一、Java-内存模型与线程" class="headerlink" title="一、Java 内存模型与线程"></a>一、Java 内存模型与线程</h2><p>让计算机同时执行多个任务，不只是因为处理器的性能更加强大了，更重要是因为计算机的运算速度和它的存储以及通信子系统速度差距太大，大量的时间都花费在磁盘 I/O 、网络通信和数据库访问上。为了不让处理器因为等待其它资源而浪费处理器的资源与时间，我们就必须采用让计算机同时执行多任务的方式去充分利用处理器的性能；同时也是为了应对服务端高并发的需求。而 Java 内存模型的设计和线程的存在正是为了更好、更高效的实现多任务。</p>
<h3 id="1-1-硬件的效率与一致性"><a href="#1-1-硬件的效率与一致性" class="headerlink" title="1.1 硬件的效率与一致性"></a>1.1 硬件的效率与一致性</h3><p>计算机中绝大多数的任务都不可能只靠处理器计算就能完成，处理器至少要和内存交互，如读取数据、存储结果等等，这个 I/O 操作是很难消除的。由于计算器的存储设备和处理器的运算速度有几个量级的差距，所以计算机不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。</p>
<p>基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性。在多处理器中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器的访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。</p>
<a id="more"></a>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/6/硬件的效率与一致性.png" width="75%"></div>

<p>除了增加高速缓存外，为了使处理器内部的运算单元能尽量被充分利用，处理器可能会对输入的代码进行乱序执行优化，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果一致，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另一个计算任务的中间结果，那么其顺序性并不能靠代码的先后顺序来保证。与处理器的乱象执行优化类似，JIT 编译器中也有类似的指令重排优化。</p>
<h3 id="1-2-Java-内存模型"><a href="#1-2-Java-内存模型" class="headerlink" title="1.2 Java 内存模型"></a>1.2 Java 内存模型</h3><p>Java 虚拟机规范中定义了 Java 内存模型，用来屏蔽各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致的内存访问效果。像 C/C++ 这类语言直接使用了物理硬件和操作系统的内存模型，因此会由于不同平台上内存模型的差异，需要针对不同平台来编写代码。</p>
<h4 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h4><p>Java 内存模型的主要目标是定义程序中各个变量的访问规则，即在虚拟机中将变量存储到内存和从内存中读取变量这样的底层细节。这里说的变量和 Java 代码中的变量有所区别，它包括了实例字段、静态字段和构成数组对象的元素，但不包括变量和方法参数，因为后者是线程私有的，不会被共享。为了获得较好的执行性能，Java 内存模型并没有限制执行引擎使用处理器的特定寄存器或缓存来和主内存进行交互，也没有限制 JIT 编译器进行代码执行顺序这类优化措施。</p>
<p>Java 内存模型规定了所有的变量都存储在主内存，每条线程都有自己单独的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存的副本拷贝，线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存，线程间变量值的传递均需要通过主内存来完成。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/6/Java内存模型.png" width="75%"></div>

<h4 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h4><p>关于主内存与工作内存间具体的交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步回主内存之类的细节，Java 内存模型定义了以下 8 种操作来完成，虚拟机实现时必须保证下面的每一种操作都是原子的、不可再分的。</p>
<p>这 8 种操作分别是：lock（锁定）、unlock（解锁）、read（读取）、load（载入）、use（使用）、assign（赋值）、store（存储）、write（写入）。</p>
<h4 id="对-volatile-型变量的特殊规则"><a href="#对-volatile-型变量的特殊规则" class="headerlink" title="对 volatile 型变量的特殊规则"></a>对 volatile 型变量的特殊规则</h4><p>volatile 是 Java 虚拟机提供的最轻量级的同步机制。当一个变量被定义为 volatile 后，它将具备两种特性：</p>
<p>第一是保证此变量对所有线程的可见性，这里的「可见性」是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。普通变量则做不到这一点，需要通过主内存来在线程间传递数据。比如，线程 A 修改了一个普通的变量值，然后向主内存进行回写，另一条线程 B 在 A 线程回写完成之后再从主内存进行读写操作，新变量值才会对线程 B 可见。</p>
<p>第二是禁止指令重排优化。普通变量仅仅会保证方法的执行过程中所有依赖赋值结果的地方<br>能够获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。因为在一个线程的方法执行过程中无法感知到这点，这也就是 Java 内存模型中描述的所谓的「线程内表现为串行的语义」。</p>
<h4 id="对-long-和-double-型变量的特殊规则"><a href="#对-long-和-double-型变量的特殊规则" class="headerlink" title="对 long 和 double 型变量的特殊规则"></a>对 long 和 double 型变量的特殊规则</h4><p>Java 内存模型要求 lock、unlock、read、load、assign、use、store、writer 这 8 个操作都具有原子性，但对于 64 位数据类型（long 和 double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的 64 位数据的读写操作划分为两次 32 位的操作来进行，即允许虚拟机实现选择可以不保证 64 位数据类型的 load、store、read 和 write 这 4 个操作的原子性。这点就是所谓的 long 和 double 的非原子协定。</p>
<p>如果有多个线程共享一个未声明为 volatile 的 long 或 double 类型的变量，并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个错误的值。好在这种情况非常罕见，主流商业虚拟机中也都把对 long 和 double 的操作视为原子性，因此在实际开发中无需使用 volatile 来修饰变量。</p>
<h4 id="原子性、可见性和有序性"><a href="#原子性、可见性和有序性" class="headerlink" title="原子性、可见性和有序性"></a>原子性、可见性和有序性</h4><p>Java 内存模型是围绕着在并发过程中如何处理原子性、可见性和有序性 3 个特质来建立的。</p>
<ol>
<li><strong>原子性（Atomicity）</strong>：由 Java 内存模型来直接保证原子性变量操作，包括 read、load、assign、use、store 和 write ，我们大致可以认为基本数据类型的访问读写是具备原子性的。如果应用场景需要一个更大范围的原子性保证，Java 内存模型还提供了 lock 和 unlock 操作来满足这种需求，尽管虚拟机未把 lock 和 unlock 操作直接开放给用户使用，但是却提供了更高层次的字节码指令 monitorenter 和 monitorexit 来隐式地使用这两个操作，这两个字节码指令反映到 Java 代码中就是 synchronized 关键字，因此被 synchronize 修饰的方法或代码块之间的操作是具备原子性的。</li>
<li><strong>可见性（Visibility）</strong>：可见性是指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。Java 内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷新变量值这种依赖主内存作为传递媒介的方式来实现可见性的，无论是普通变量还是 volatile 变量都是如此，普通变量与 volatile 变量的区别是， volatile 的规则保证了新值能立即同步到主内存，以及每次使用前立即从主内存刷新。因此，可以说 volatile 保证了多线程操作变量的可见性，而普通变量则不能保证这一点。除了 volatile 外，Java 还有两个关键字 synchronized 和 final 。synchronized 同步块的可见性是由「对一个变量执行 unlock 操作前，必须先把此变量同步回主内存中（执行 store、write 操作）」这条规则获得的；final 的可见性是指：被 final 修饰的字段在构造器中一旦初始化完成，并且构造器没有「this」的引用传递出去，那在其他线程中就能看见 final 字段的值。</li>
<li><strong>有序性（Ordering）</strong>：Java 程序中天然的有序性可以总结为：如果在本线程内，所有操作都是有序的；如果在一个线程中观察另一个线程，所有的操作都是无序的。前半句是指「线程内表现为串行的语义」，后半句是指「指令重排序」现象和「工作内存和主内存同步延迟」现象。Java 语言提供了 volatile 和 synchronized 两个关键字来保证线程之间操作的有序性，volatile 关键字本身就包含了禁止指令重排的语义，而 synchronized 则是由「一个变量在同一时刻只允许一条线程对其进行 lock 操作」这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行的进入。</li>
</ol>
<h4 id="先行发生原则"><a href="#先行发生原则" class="headerlink" title="先行发生原则"></a>先行发生原则</h4><p>如果 Java 内存模型中所有的有序性都仅仅靠 volatile 和 synchronized 来保证，那么有一些操作就会变得很繁琐，但是我们在编写 Java 并发代码的时候并没有感觉到这一点，这是因为 Java 语言中有一个「先行发生」（happens-before）原则。这个原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们可以通过几条规则一揽子解决并发环境下两个操作之间是否可能存在冲突的所有问题。</p>
<p>先行发生是 Java 内存模型中定义的两项操作之间的偏序关系，如果说操作 A 先行发生于操作 B，其实就是说在发生操作 B 之前，操作 A 产生的影响能被操作 B 观察到，「影响」包括修改了内存中共享变量的值、发送了消息、调用了方法等。</p>
<p>Java 内存模型下有一些天然的先行发生关系，这些先行发生关系无需任何同步器协助就已存在，可以在编码中直接使用。如果两个操作之间的关系不在此列，并且无法从下列规则推导出来，它们就没有顺序性保障，虚拟机就可以随意的对它们进行重排序。</p>
<ul>
<li>程序次序规则：在一个线程内，按照程序代码顺序，写在前面的代码先行发生写在后面的代码。准确的讲，应该是控制流顺序而不是程序代码顺序，因为要考虑分支、循环等结构；</li>
<li>管程锁定规则：一个 unlock 操作先行发生于后面对于同一个锁的 lock 操作；</li>
<li>volatile 变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作，理解了这个原则我们就能理解为什么 DCL 单例模式中为什么要用 volatile 来标识实例对象了；</li>
<li>线程启动规则：线程的 start() 方法先行发生于此线程的所有其它动作；</li>
<li>线程终止规则：线程中所有的操作都先行发生于对此线程的终止检测；</li>
<li>程序中断规则：对线程 interrupt() 的调用先行发生于被中断线程的代码检测到中断时间的发生；</li>
<li>对象终结规则：一个对象的初始化完成先行发生于它的 finalize() 的开始；</li>
<li>传递性：操作 A 先行发生于 B，B 先行发生于 C，那么 A 就先行发生于 C。</li>
</ul>
<h3 id="1-3-Java-与线程"><a href="#1-3-Java-与线程" class="headerlink" title="1.3 Java 与线程"></a>1.3 Java 与线程</h3><p>谈论 Java 中的并发，通常都是和多线程相关的。这一小节我们就讲讲 Java 线程在虚拟机中的实现。</p>
<h4 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h4><p>主流的操作系统都提供了线程实现，Java 语言则提供了在不同硬件和操作系统平台下对线程操作的统一处理，每个已经执行 start() 且还未结束的 Thread 类的实例就代表了一个线程。Thread 类所有关键方法都是 Native 的。Java API 中，一个 Native 方法往往意味着这个方法没有使用或者无法使用平台无关的手段来实现（当然也可能是为了执行效率而使用 Native 方法，不过，通常最高效率的手段就是平台相关的手段）。</p>
<p>实现线程主要有 3 种方式：使用内核线程实现、使用用户线程实现、使用用户线程加轻量级进程混合实现。</p>
<h4 id="Java-线程的实现"><a href="#Java-线程的实现" class="headerlink" title="Java 线程的实现"></a>Java 线程的实现</h4><p>Java 线程在 JDK 1.2 之前是基于称为「绿色线程」的用户线程实现的。而在 JDK 1.2 中，线程模型替换为基于操作系统原生线程模型来实现。因此，在目前的 JDK 版本中，操作系统支持怎样的线程模型，在很大程度上决定了 Java 虚拟机的线程是怎样映射的，这点在不同的平台上没有办法达成一致，虚拟机规范中也没有限定 Java 线程需要使用哪种线程模型来实现。线程模型只对线程的并发规模和操作成本产生影响，对 Java 程序的编码和运行过程来说，这些差异都透明的。</p>
<h3 id="1-4-Java-线程调度"><a href="#1-4-Java-线程调度" class="headerlink" title="1.4 Java 线程调度"></a>1.4 Java 线程调度</h3><p>线程调度是指系统为线程分配处理器使用权的过程，主要调度方式有两种，分别是协同式线程调度和抢占式线程调度。</p>
<h4 id="协同式线程调度"><a href="#协同式线程调度" class="headerlink" title="协同式线程调度"></a>协同式线程调度</h4><p>如果是使用协同式调度的多线程系统，线程的执行时间由线程本身来控制，线程把自己的工作执行完之后，要主动通知系统切换到另外一个线程上。协同式多线程的最大好处是实现简单，而且由于线程要把自己的事情做完后才会进行线程切换，切换操作对线程自己是可知的，所有没有线程同步的问题。但是它的坏处也很明显：线程执行时间不可控，甚至如果一个线程编写有问题，一直不告诉操作系统进行线程切换，那么程序就会一直阻塞在那里。很久以前的 Windows 3.x 系统就是使用协同式来实现对进程多任务，相当不稳定，一个进程坚持不让出 CPU 执行时间就可能导致整个系统崩溃。</p>
<h4 id="抢占式线程调度"><a href="#抢占式线程调度" class="headerlink" title="抢占式线程调度"></a>抢占式线程调度</h4><p>如果是使用抢占式调度的多线程系统，那么每个线程将由系统来分配执行时间，线程的切换不由线程本身来决定。在这种实现线程调度的方式下，线程的执行实现是系统可控的，也不会有一个线程导致整个进程阻塞的问题，Java 使用的线程调度方式就是抢占式的。和前面所说的 Windows 3.x 的例子相对，在 Windows 9x/NT 内核中就是使用抢占式来实现多进程的，当一个进程出了问题，我们还可以使用任务管理器把这个进程「杀掉」，而不至于导致系统崩溃。 </p>
<h3 id="1-5-状态转换"><a href="#1-5-状态转换" class="headerlink" title="1.5 状态转换"></a>1.5 状态转换</h3><p>Java 语言定义了 5 种线程状态，在任意一个时间点，一个线程只能有且只有其中一种状态，它们分别是：</p>
<ul>
<li>新建（New）：创建后尚未启动的线程处于这种状态；</li>
<li>运行（Runnable）：Runnable 包括了操作系统线程状态中的 Running 和 Ready，也就是处于此状态的线程有可能正在执行，也有可能正在等待着 CPU 为它分配执行时间；</li>
<li>无限期等待（Waiting）：处于这种状态的线程不会被分配 CPU 执行时间，它们要等待被其它线程显式地唤醒；以下三种方法会让线程进入无限期等待状态：<ul>
<li>没有设置 TimeOut 参数的 Object.wait()；</li>
<li>没有设置 TimeOut 参数的 Thread.join()；</li>
<li>LockSupport.park()。</li>
</ul>
</li>
<li>限期等待（Timed Waiting）：处于这种状态的线程也不会被分配 CPU 执行时间，不过无需等待被其它线程显式地唤醒，在一定时间之后它们会由系统自动唤醒；以下方法会让线程进入限期等待状态：<ul>
<li>Thread.sleep()；</li>
<li>设置了 TimeOut 参数的 Object.wait()；</li>
<li>设置了 TimeOut 参数的 Thread.join()；</li>
<li>LockSupport.parkNanos()；</li>
<li>LockSupport.parkUntil()。</li>
</ul>
</li>
<li>阻塞（Blocked）：线程被阻塞了，「阻塞状态」和「等待状态」的区别是：「阻塞状态」在等待着获取一个排他锁，这个事件将在另一个线程放弃这个锁的时候发生；而「等待状态」则是在等待一段时间，或者唤醒动作的发送。在程序等待进入同步区域时，线程将进入这种状态；</li>
<li>结束（Terminated）：线程已经结束执行。</li>
</ul>
<p>上述 5 中状态遇到特定事件发生的时候将会互相转换，如下图：</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/6/线程状态转换关系.png" width="60%"></div>

<h2 id="二、线程安全与锁优化"><a href="#二、线程安全与锁优化" class="headerlink" title="二、线程安全与锁优化"></a>二、线程安全与锁优化</h2><p>本文的主题是高效并发，但高效的前提是首先要保证并发的正确性和安全性，所以这一小节我们先从如何保证线程并发安全说起。</p>
<h3 id="2-1-Java-线程安全"><a href="#2-1-Java-线程安全" class="headerlink" title="2.1 Java 线程安全"></a>2.1 Java 线程安全</h3><p>那么什么是线程安全呢？可以简单的理解为多线程对同一块内存区域操作时，内存值的变化是可预期的，不会因为多线程对同一块内存区域的操作和访问导致内存中存储的值出现不可控的问题。</p>
<h4 id="Java-语言中的线程安全"><a href="#Java-语言中的线程安全" class="headerlink" title="Java 语言中的线程安全"></a>Java 语言中的线程安全</h4><p>如果我们不把线程安全定义成一个非此即彼的概念（要么线程绝对安全，要么线程绝对不安全），那么我们可以根据线程安全的程度由强至弱依次分为如下五档：</p>
<ol>
<li>不可变；</li>
<li>绝对线程安全；</li>
<li>相对线程安全；</li>
<li>线程兼容；</li>
<li>线程对立。</li>
</ol>
<h4 id="线程安全的实现方法"><a href="#线程安全的实现方法" class="headerlink" title="线程安全的实现方法"></a>线程安全的实现方法</h4><p>虽然线程安全与否与编码实现有着莫大的关系，但虚拟机提供的同步和锁机制也起到了非常重要的作用。下面我们就来看看虚拟机层面是如何保证线程安全的。</p>
<ol>
<li><p>同步互斥</p>
<p>互斥同步是常见的一种并发正确性保障的手段。同步是指在多个线程并发访问共享数据时，保证共享数据在同一时间只被一个线程使用。而互斥是实现同步的一种手段。Java 中最基本的互斥同步手段就是 synchronized 关键字，synchronized 关键字在经过编译之后，会在同步块的前后分别形成 monitorenter 和 monitorexit 这两个字节码指令，这两个字节码都需要一个 reference 类型的参数来指明要锁定和解锁的对象。如果 Java 程序中的 synchronized 明确指明了对象参数，那就是这个对象的 reference；如果没有，那就根据 synchronized 修饰的是实例方法还是类方法，去取对应的对象实例或 class 对象来作为锁对象。</p>
</li>
</ol>
<p>   根据虚拟机规范的要求，在执行 monitorenter 指令时，首先要尝试获取对象的锁。如果这个对象没被锁定，或者当前线程已经拥有了那个对象的锁，就把锁的计数器加 1；相应的，在执行monitorexit 指令时将锁计数器减 1，当锁计数器为 0 时，锁就被释放。如果获取锁对象失败，当前线程就要阻塞等待，直到对象锁被另一个线程释放为止。</p>
<p>   另外要说明的一点是，同步块在已进入的线程执行完之前，会阻塞后面其它线程的进入。由于 Java 线程是映射到操作系统原生线程之上的，如果要阻塞或者唤醒一个线程，都需要操作系统来帮忙完成，这就需要从用户态转换到内核态，线程状态转换需要耗费很多的处理器时间。对于简单的同步块（如被 synchronized 修饰的 getter() 和 setter() 方法），状态转换消耗的时间可能比用户代码消耗的时间还要长。所以 synchronized  是 Java 中一个重量级的操作，因此我们只有在必要的情况下才应该使用它。当然虚拟机本身也会做相应的优化，比如在操作系统阻塞线程前加入一段自旋等待过程，避免频繁的用户态到内核态的转换过程。这一点我们在介绍锁优化的时候再细聊。</p>
<ol>
<li><p>非阻塞同步</p>
<p>互斥同步最大的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也成为阻塞同步。从处理问题的方式上来说，互斥同步是一种悲观的并发策略，认为只要不去做正确的同步措施（例如加锁），就肯定会出问题，无论共享数据是否会出现竞争，它都要进行加锁（当然虚拟机也会优化掉一些不必要的锁）。随着硬件指令集的发展，我们有了另外一个选择：<strong>基于冲突检查的乐观并发策略</strong>。通俗的说，就是先进行操作，如果没有其他线程竞争，那操作就成功了；如果共享数据有其它线程竞争，产生了冲突，就采取其它的补救措施，这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作称为<strong>非阻塞同步</strong>。</p>
</li>
</ol>
<p>   前面之所以说需要硬件指令集的发展，是因为我们需要操作和冲突检测这两个步骤具备原子性。</p>
<p>   这个原子性靠什么来保证呢？如果这里再使用互斥同步来保证原子性就失去意义了，所以我们只能靠硬件来完成这件事，保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：</p>
<ul>
<li>测试并设置（Test-and-Set）</li>
<li>获取并增加（Fetch-and-Increment）</li>
<li>交换（Swap）</li>
<li>比较并交换（Compare-and-Swap，简称 CAS）</li>
<li><p>加载链接/条件存储（Load-Linked/Store-Conditional，简称 LL/SC）</p>
<p>前三条是之前的处理器指令集里就有的，后两条是新增的。</p>
</li>
</ul>
<p>   CAS 指令需要 3 个操作数，分别是内存位置（在 Java 中可以简单理解为变量的内存地址，用 V 表示）、旧的预期值（用 A 表示）和新值（用 B 表示）。CAS 执行指令时，当且仅当 V 符合旧预期值 A 时，处理器用新值 B 更新 V 的值，否则他就不执行更新，但是无论是否更新了 V 的值，都会返回 V 的旧值，上述的处理过程是一个原子操作。</p>
<p>   在 JDK 1.5 之后，Java 程序中才可以使用 CAS 操作，该操作由 sun.misc.Unsafe 类里的 compareAndSwapInt() 和 compareAndSwapLong() 等几个方法包装提供，虚拟机在内部对这些方法做了特殊处理，即时编译出来的结果就是一条平台相关的处理器 CAS 指令，没有方法的调用过程，或者可以认为是无条件内联进去了。</p>
<p>   由于 Unsafe 类不是提供给用户程序调用的类，因此如果不用反射，我们只能通过其他的 Java API 来间接使用，比如 J.U.C 包里的整数原子类，其中的 compareAndSet() 和 getAndIncrement() 等方法都使用了 Unsafe 类的 CAS 操作。</p>
<p>   尽管 CAS 看起来很美，但是这种操作却无法覆盖互斥同步的所有场景，并且 CAS 从语义上来说并不是完美的。如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查它仍然是 A 值，那我们就能说它的值没有被其他线程修改过吗？如果在这段时间内曾经被改为了 B，后来又被改回为 A，那 CAS 操作就会认为它从来没有被改变过。这个漏洞称为 CAS 操作的「ABA」问题。</p>
<p>   为了解决「ABA」问题，J.U.C 包提供了一个带有标记的原子引用类 <code>AtomicStamoedReference</code>，它可以通过控制变量值的版本来保证 CAS 的正确性。不过这个类比较「鸡肋」，大部分情况下 ABA 问题不会影响程序并发的正确性，如果需要解决 ABA 问题，改用传统的互斥同步可能会比原子类更高效。</p>
<ol>
<li><p>无同步方案</p>
<p>要保证线程安全不一定要进行同步，如果一个方法本来就不涉及共享数据，那它自然无需任何同步措施，因此会有一些代码天生就是线程安全的，其中就包括下面要说的<strong>可重入代码</strong>和<strong>线程本地存储</strong>。</p>
<p><strong>可重入代码（Reentrant Code）</strong>：也叫纯代码，可以在代码执行的任何时候中断它，转而去执行另一端代码（包括递归调用自己），而在重新获得控制权后，原来的程序不会出现任何错误。可重入代码有一些共同特征，例如不依赖存储在堆上的数据和公用的系统资源，用到的状态量都由参数传入、不调用非可重入的方法等。如果一个方法的返回结果可以预测，只要输入相同，就能返回相同的输出，那它就是可重入代码，当然也就是线程安全的。</p>
<p><strong>线程本地存储（Thread Local Storage）</strong>：也就是说这个数据是线程独有的，ThreadLocal 就是用来实现线程本地存储的。</p>
</li>
</ol>
<h3 id="2-2-锁优化"><a href="#2-2-锁优化" class="headerlink" title="2.2 锁优化"></a>2.2 锁优化</h3><p>HotSpot 虚拟机开发团队花费了很大的精力实现了各种锁优化，比如自旋锁与自适应自旋、锁消除、锁粗化、轻量级锁、偏向锁等。</p>
<h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p>自旋锁前面我们在聊互斥同步的时候就提到过，互斥同步对性能最大的影响就是阻塞的实现，挂起线程和恢复线程都涉及到了用户态到内核态的转换，这种状态的转换会给系统并发性能带来很大的压力。但是大多数场景下，共享数据的锁定状态只会持续很短的一段时间，为了这短暂的时间去挂起和恢复线程显得不那么划算。如果物理机有一个以上的处理器，能让两个或以上的线程同时并行处理，我们就可以让后面请求锁的那个线程「稍等一下」，但是不放弃处理器的执行时间，看看持有锁的线程是否很快就会释放锁。为了让线程等待，我们只需要执行一个空转的循环（自旋），这就是所谓的自旋锁。</p>
<p>自旋等待虽然避免了线程切换的开销，但是它要占用处理器的时间。如果锁被占用的时间很短，那么自旋等待的效果当然很好；反之，如果锁被占用的时间很长，那么自旋的线程就会白白消耗处理器资源，反而形成负优化。所以自旋等待必须有个限度，但是这个限度如果设置一个固定值并不是最有选择，因此虚拟机开发团队设计了<strong>自适应自旋锁</strong>，让自旋等待的时间不再固定，而是由前一次在同一个锁上自旋的时间及锁的拥有者的状态来决定。如果在同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在运行，那么虚拟机就会认为这次自旋也有可能会成功，会将自旋等待的时间延长。如果对于某个锁，自旋等待很少成功获得过，那在以后要获取这个锁的时候就会放弃自旋。有了自适应自旋，随着程序运行和性能监控信息的不断完善，虚拟机对程序锁的状况预测就会越来越准确。</p>
<h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>即时编译器在运行时，对一些代码上要求同步，但是被检测到不可能存在共享数据竞争的锁就会进行锁消除。所消除的主要判定依据来源于逃逸分析的数据支持，如果判定一段代码中，堆上的所有数据都不会逃逸出去从而被其它线程访问到，那就可以把它们当做栈上数据对待，认为它们是线程私有的，同步加锁自然就没必要了。</p>
<h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>我们在编码时，总是推荐将同步块的作用范围限制到最小，只在共享数据的实际作用域中才进行同步，这样是为了使得需要的同步操作数量尽可能变小，如果存在竞争，那等待锁的线程也能尽快拿到锁。通常，这样做是正确的，但是如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作是出现在循环体中，那即使没有线程竞争，频繁的进行互斥同步也会导致不必要的性能损耗。那加锁出现在循环体中来举例，虚拟机遇到这种情况，就会把加锁同步的范围扩展（粗化）到循环体外，这样只要加锁一次就可以了，这就是锁粗化。</p>
<p>关于轻量级锁和偏向锁这里就不再介绍，如果大家有兴趣可以留言反馈，我在单独发文介绍。     </p>
<h2 id="结束语"><a href="#结束语" class="headerlink" title="结束语"></a>结束语</h2><p>至此，整个 JVM 系列就更新完了，这个系列的文章基本上都是由我的读书笔记整理而成，希望能对大家有帮助。由于篇幅限制，加上本人水平有限，书中精华未能一一呈现。想进一步 Java 虚拟机的同学推荐去阅读周志明老师的原著。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版）》</li>
</ul>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首发于微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，欢迎关注！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;高效并发是 JVM 系列的最后一篇，本篇主要介绍虚拟机如何实现多线程、多线程间如何共享和竞争数据以及共享和竞争数据带来的问题及解决方案。&lt;/p&gt;
&lt;h2 id=&quot;一、Java-内存模型与线程&quot;&gt;&lt;a href=&quot;#一、Java-内存模型与线程&quot; class=&quot;headerlink&quot; title=&quot;一、Java 内存模型与线程&quot;&gt;&lt;/a&gt;一、Java 内存模型与线程&lt;/h2&gt;&lt;p&gt;让计算机同时执行多个任务，不只是因为处理器的性能更加强大了，更重要是因为计算机的运算速度和它的存储以及通信子系统速度差距太大，大量的时间都花费在磁盘 I/O 、网络通信和数据库访问上。为了不让处理器因为等待其它资源而浪费处理器的资源与时间，我们就必须采用让计算机同时执行多任务的方式去充分利用处理器的性能；同时也是为了应对服务端高并发的需求。而 Java 内存模型的设计和线程的存在正是为了更好、更高效的实现多任务。&lt;/p&gt;
&lt;h3 id=&quot;1-1-硬件的效率与一致性&quot;&gt;&lt;a href=&quot;#1-1-硬件的效率与一致性&quot; class=&quot;headerlink&quot; title=&quot;1.1 硬件的效率与一致性&quot;&gt;&lt;/a&gt;1.1 硬件的效率与一致性&lt;/h3&gt;&lt;p&gt;计算机中绝大多数的任务都不可能只靠处理器计算就能完成，处理器至少要和内存交互，如读取数据、存储结果等等，这个 I/O 操作是很难消除的。由于计算器的存储设备和处理器的运算速度有几个量级的差距，所以计算机不得不加入一层读写速度尽可能接近处理器运算速度的高速缓存来作为内存与处理器之间的缓冲：将运算需要用到的数据复制到缓存中，让运算能快速进行，当运算结束后再从缓存同步回内存中，这样处理器就无需等待缓慢的内存读写了。&lt;/p&gt;
&lt;p&gt;基于高速缓存的存储交互很好的解决了处理器与内存的速度矛盾，但是也为计算机系统带来更高的复杂度，因为它引入了一个新的问题：缓存一致性。在多处理器中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致。为了解决一致性的问题，需要各个处理器的访问缓存时都遵循一些协议，在读写时要根据协议来进行操作。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://baronzhang.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://baronzhang.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>系列 | 深入理解Java虚拟机五（程序编译与代码优化）</title>
    <link href="http://baronzhang.com//blog/JVM/%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%94%EF%BC%88%E7%A8%8B%E5%BA%8F%E7%BC%96%E8%AF%91%E4%B8%8E%E4%BB%A3%E7%A0%81%E4%BC%98%E5%8C%96%EF%BC%89/"/>
    <id>http://baronzhang.com//blog/JVM/系列-深入理解Java虚拟机五（程序编译与代码优化）/</id>
    <published>2019-08-19T16:27:07.000Z</published>
    <updated>2019-08-19T17:00:44.305Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>首发于微信公众号：<strong>BaronTalk</strong>，欢迎关注！</p>
</blockquote>
<p>对于性能和效率的追求一直是程序开发中永恒不变的宗旨，除了我们自己在编码过程中要充分考虑代码的性能和效率，虚拟机在编译阶段也会对代码进行优化。本文就从虚拟机层面来看看虚拟机对我们所编写的代码采用了哪些优化手段。</p>
<h2 id="一-早期优化（编译期优化）"><a href="#一-早期优化（编译期优化）" class="headerlink" title="一. 早期优化（编译期优化）"></a>一. 早期优化（编译期优化）</h2><p>Java 语言的「编译期」其实是一段「不确定」的操作过程。因为它可能是一个前端编译器（如 Javac）把 <em>.java 文件编译成 </em>.class 文件的过程；也可能是程序运行期的即时编译器（JIT 编译器，Just In Time Compiler）把字节码文件编译成机器码的过程；还可能是静态提前编译器（AOT 编译器，Ahead Of Time Compiler）直接把 *.java 文件编译成本地机器码的过程。</p>
<p>Javac 这类编译器对代码的运行效率几乎没有任何优化措施，虚拟机设计团队把对性能的优化都放到了后端的即时编译器中，这样可以让那些不是由 Javac 产生的 class 文件（如 Groovy、Kotlin 等语言产生的 class 文件）也能享受到编译器优化带来的好处。但是 Javac 做了很多针对 Java 语言编码过程的优化措施来改善程序员的编码风格、提升编码效率。相当多新生的 Java 语法特性，都是靠编译器的「语法糖」来实现的，而不是依赖虚拟机的底层改进来支持。</p>
<p>Java 中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说更加密切。</p>
<a id="more"></a>
<h3 id="1-1-Javac-编译器"><a href="#1-1-Javac-编译器" class="headerlink" title="1.1 Javac 编译器"></a>1.1 Javac 编译器</h3><p>Javac 编译器的编译过程大致可分为 3 个步骤：</p>
<ol>
<li>解析与填充符号表；</li>
<li>插入式注解处理器的注解处理；</li>
<li>分析与字节码生成。</li>
</ol>
<p>这 3 个步骤之间的关系如下图所示：</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/5/Javac编译过程.png" width="85%"></div>

<h4 id="解析与填充符号表"><a href="#解析与填充符号表" class="headerlink" title="解析与填充符号表"></a>解析与填充符号表</h4><p>解析步骤包含了经典程序编译原理中的词法分析和语法分析两个过程；完成词法分析和语法分析之后，下一步就是填充符号表的过程。符号表是由一组符号地址和符号信息构成的表格。在语义分析中，符号表所登记的内容将用于语义检查和产生中间代码。在目标代码生成阶段，当对符号名进行地址分配时，符号表是地址分配的依据。</p>
<h4 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h4><p>注解（Annotation）是在 JDK 1.5 中新增的，有了编译器注解处理的标准 API 后，我们的代码就可以干涉编译器的行为，比如在编译期生成 class 文件。</p>
<h4 id="语义分析与字节码生成"><a href="#语义分析与字节码生成" class="headerlink" title="语义分析与字节码生成"></a>语义分析与字节码生成</h4><p>语法分析之后，编译器获得了程序代码的抽象语法树表示，语法树能表示一个结构正确的源程序的抽象，但无法保证源程序是符合逻辑的。而语义分析的主要任务是对结构上正确的源程序进行上下文有关性质的审查，比如进行类型审查。</p>
<p>字节码生成是 Javac 编译过程的最后一个阶段，字节码生成阶段不仅仅是把前面各个步骤所生成的信息（语法树、符号表）转化成字节码写到磁盘中，编译器还进行了少量的代码添加和转换工作。如前面提到的 <init>() 方法就是在这一阶段添加到语法树中的。</init></p>
<p>在字节码生成阶段，除了生成构造器以外，还有一些其它的代码替换工作用于优化程序的实现逻辑，如把字符串的加操作替换为 StringBiulder 或 StringBuffer。</p>
<p>完成了对语法树的遍历和调整之后，就会把填充了所需信息的符号表交给 com.sun.tools.javac.jvm.ClassWriter 类，由这个类的 writeClass() 方法输出字节码，最终生成字节码文件，到此为止整个编译过程就结束了。</p>
<h3 id="1-2-Java-语法糖"><a href="#1-2-Java-语法糖" class="headerlink" title="1.2 Java 语法糖"></a>1.2 Java 语法糖</h3><p>Java 中提供了有很多语法糖来方便程序开发，虽然语法糖不会提供实质性的功能改进，但是它能提升开发效率、语法的严谨性、减少编码出错的机会。下面我们来了解下语法糖背后我们看不见的东西。</p>
<h4 id="泛型与类型擦除"><a href="#泛型与类型擦除" class="headerlink" title="泛型与类型擦除"></a>泛型与类型擦除</h4><p>泛型顾名思义就是类型泛化，本质是参数化类型的应用，也就是说操作的数据类型被指定为一个参数。这种参数可以用在类、接口和方法的创建中，分别称为泛型类、泛型接口和泛型方法。</p>
<p>在 Java 语言还没有泛型的时候，只能通过 Object 是所有类型的父类和强制类型转换两个特点的配合来实现类型泛化。例如 HashMap 的 get() 方法返回的就是一个 Object 对象，那么只有程序员和运行期的虚拟机才知道这个 Object 到底是个什么类型的对象。在编译期间，编译器无法检查这个 Object 的强制类型转换是否成功，如果仅仅依赖程序员去保障这项操作的正确性，许多 ClassCastException 的风险就会转嫁到程序运行期。</p>
<p>Java 语言中泛型只在程序源码中存在，在编译后的字节码文件中，就已经替换为原来的原生类型，并且在相应的地方插入了强制类型转换的代码。因此对于运行期的 Java 语言来说， ArrayList<int> 与 ArrayList<string> 是同一个类型，所以泛型实际上是 Java 语言的一个语法糖，这种泛型的实现方法称为类型擦除。</string></int></p>
<h4 id="自动装箱、拆箱与遍历循环"><a href="#自动装箱、拆箱与遍历循环" class="headerlink" title="自动装箱、拆箱与遍历循环"></a>自动装箱、拆箱与遍历循环</h4><p>自动装箱、拆箱与遍历循环是 Java 语言中用得最多的语法糖。这块比较简单，我们直接看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntaxSugars</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">        List&lt;Integer&gt; list = Arrays.asList(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i : list)&#123;</div><div class="line">            sum += i;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"sum = "</span> + sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>自动装箱、拆箱与遍历循环编译之后：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyntaxSugars</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        List list = Arrays.asList(<span class="keyword">new</span> Integer[]&#123;</div><div class="line">                Integer.valueOf(<span class="number">1</span>),</div><div class="line">                Integer.valueOf(<span class="number">2</span>),</div><div class="line">                Integer.valueOf(<span class="number">3</span>),</div><div class="line">                Integer.valueOf(<span class="number">4</span>),</div><div class="line">                Integer.valueOf(<span class="number">5</span>)</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</div><div class="line">        <span class="keyword">for</span> (Iterator iterable = list.iterator(); iterable.hasNext(); ) &#123;</div><div class="line">            <span class="keyword">int</span> i = ((Integer) iterable.next()).intValue();</div><div class="line">            sum += i;</div><div class="line">        &#125;</div><div class="line">        System.out.println(<span class="string">"sum = "</span> + sum);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第一段代码包含了泛型、自动装箱、自动拆箱、遍历循环和变长参数 5 种语法糖，第二段代码则展示了它们在编译后的变化。</p>
<h4 id="条件编译"><a href="#条件编译" class="headerlink" title="条件编译"></a>条件编译</h4><p>Java 语言中条件编译的实现也是一颗语法糖，根据布尔常量值的真假，编译器会把分支中不成立的代码块消除。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">true</span>) &#123;</div><div class="line">        System.out.println(<span class="string">"block 1"</span>);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        System.out.println(<span class="string">"block 2"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上述代码经过编译后 class 文件的反编译结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    System.out.println(<span class="string">"block 1"</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="二-晚期优化（运行期优化）"><a href="#二-晚期优化（运行期优化）" class="headerlink" title="二. 晚期优化（运行期优化）"></a>二. 晚期优化（运行期优化）</h2><p>在部分商业虚拟机中，Java 最初是通过解释器解释执行的，当虚拟机发现某个方法或者代码块的运行特别频繁时，就会把这些代码认定为「热点代码」（Hot Spot Code）。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器称为即时编译器（JIT）。</p>
<p>即时编译器不是虚拟机必须的部分，Java 虚拟机规范并没有规定虚拟机内部必须要有即时编译器存在，更没有限定或指导即时编译器应该如何实现。但是 JIT 编译性能的好坏、代码优化程度的高低却是衡量一款商用虚拟机优秀与否的最关键指标之一。</p>
<h3 id="2-1-HotSpot-虚拟机内的即时编译器"><a href="#2-1-HotSpot-虚拟机内的即时编译器" class="headerlink" title="2.1 HotSpot 虚拟机内的即时编译器"></a>2.1 HotSpot 虚拟机内的即时编译器</h3><p>由于 Java 虚拟机规范中没有限定即时编译器如何实现，所以本节的内容完全取决于虚拟机的具体实现。我们这里拿 HotSpot 来说明，不过后面的内容涉及具体实现细节的内容很少，主流虚拟机中 JIT 的实现又有颇多相似之处，因此对理解其它虚拟机的实现也有很高的参考价值。</p>
<h4 id="解释器与编译器"><a href="#解释器与编译器" class="headerlink" title="解释器与编译器"></a>解释器与编译器</h4><p>尽管并不是所有的 Java 虚拟机都采用解释器与编译器并存的架构，但许多主流的商用虚拟机，如 HotSpot、J9 等，都同时包含解释器与编译器。</p>
<p>解释器与编译器两者各有优势：</p>
<ul>
<li>当程序需要迅速启动和执行的时候，解释器可以首先发挥作用，省去编译的时间，立即执行。在程序运行后，随着时间的推移，编译器逐渐发挥作用，把越来越多的代码编译成本地机器码之后，可以获得更高的执行效率。</li>
<li>当程序运行环境中内存资源限制较大（如部分嵌入式系统），可以使用解释器执行来节约内存，反之可以使用编译执行来提升效率。</li>
</ul>
<p>同时，解释器还可以作为编译器激进优化时的一个「逃生门」，当编译器根据概率选择一些大多数时候都能提升运行速度的优化手段，当激进优化的假设不成立，如加载了新的类后类型继承结构出现变化、出现「罕见陷阱」时可以通过逆优化退回到解释状态继续执行。</p>
<h4 id="编译对象与触发条件"><a href="#编译对象与触发条件" class="headerlink" title="编译对象与触发条件"></a>编译对象与触发条件</h4><p>程序在运行过程中会被即时编译器编译的「热点代码」有两类：</p>
<ul>
<li>被多次调用的方法；</li>
<li>被多次执行的循环体。</li>
</ul>
<p>这两种被多次重复执行的代码，称之为「热点代码」。</p>
<ul>
<li>对于被多次调用的方法，方法体内的代码自然会被执行多次，理所当然的就是热点代码。</li>
<li>而对于多次执行的循环体则是为了解决一个方法只被调用一次或者少量几次，但是方法体内部存在循环次数较多的循环体问题，这样循环体的代码也被重复执行多次，因此这些代码也是热点代码。</li>
</ul>
<p>对于第一种情况，由于是方法调用触发的编译，因此编译器理所当然地会以整个方法作为编译对象，这种编译也是虚拟机中标准的 JIT 编译方式。而对于后一种情况，尽管编译动作是由循环体所触发的，但是编译器依然会以整个方法（而不是单独的循环体）作为编译对象。这种编译方式因为发生在方法执行过程中，因此形象地称之为栈上替换（On Stack Replacement，简称 OSR 编译，即方法栈帧还在栈上，方法就被替换了）。</p>
<p>我们反复提到多次，可是多少次算多次呢？虚拟机如何统计一个方法或一段代码被执行过多少次呢？回答了这两个问题，也就回答了即时编译器的触发条件。</p>
<p>判断一段代码是不是热点代码，是不是需要触发即时编译，这样的行为称为「热点探测」。其实进行热点探测并不一定需要知道方法具体被调用了多少次，目前主要的热点探测判定方式有两种。</p>
<ul>
<li>基于采样的热点探测：采用这种方法的虚拟机会周期性地检查各个线程栈顶，如果发现某个（或某些）方法经常出现在栈顶，那这个方法就是「热点方法」。基于采样的热点探测的好处是实现简单、高效，还可以很容易地获取方法调用关系（将调用栈展开即可），缺点是很难精确地确认一个方法的热度，容易因为受到线程阻塞或别的外界因数的影响而扰乱热点探测。</li>
<li>基于计数器的热点探测：采用这种方法的虚拟机会为每个方法（甚至代码块）建立计数器，统计方法的执行次数，如果执行次数超过一定的阈值就认为它是「热点方法」。这种统计方法实现起来麻烦一些，需要为每个方法建立并维护计数器，而且不能直接获取到方法的调用关系，但是统计结果相对来说更加精确和严谨。</li>
</ul>
<p>HotSpot 虚拟机采用的是第二种：基于计数器的热点探测。因此它为每个方法准备了两类计数器：方法调用计数器（Invocation Counter）和回边计数器（Back Edge Counter）。</p>
<p>在确定虚拟机运行参数的情况下，这两个计数器都有一个确定的阈值，当计数器超过阈值就会触发 JIT 编译。</p>
<p><strong>方法调用计数器</strong></p>
<p>顾名思义，这个计数器用于统计方法被调用的次数。当一个方法被调用时，会首先检查该方法是否存在被 JIT 编译过的版本，如果存在，则优先使用编译后的本地代码来执行。如果不存在，则将此方法的调用计数器加 1，然后判断方法调用计数器与回边计数器之和是否超过方法调用计数器的阈值。如果超过阈值，将会向即时编译器提交一个该方法的代码编译请求。</p>
<p>如果不做任何设置，执行引擎不会同步等待编译请求完成，而是继续进入解释器按照解释方式执行字节码，直到提交的请求被编译器编译完成。当编译完成后，这个方法的调用入口地址就会被系统自动改写成新的，下一次调用该方法时就会使用已编译的版本。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/5/方法调用计数器触发即时编译.png" width="65%"></div>

<p>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数，而是一个相对的执行频率，即一段时间内方法调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以让它提交给即时编译器编译，那这个方法的调用计数器值就会被减少一半，这个过程称为方法调用计数器热度的衰减，而这段时间就称为此方法统计的半衰期。</p>
<p>进行热度衰减的动作是在虚拟机进行 GC 时顺便进行的，可以设置虚拟机参数来关闭热度衰减，让方法计数器统计方法调用的绝对次数，这样，只要系统运行时间足够长，绝大部分方法都会被编译成本地代码。此外还可以设置虚拟机参数调整半衰期的时间。</p>
<p><strong>回边计数器</strong></p>
<p>回边计数器的作用是统计一个方法中循环体代码执行的次数，在字节码中遇到控制流向后跳转的指令称为「回边」（Back Edge）。建立回边计数器统计的目的是为了触发 OSR 编译。</p>
<p>当解释器遇到一条回边指令时，会先查找将要执行的代码片段是否已经有编译好的版本，如果有，它将优先执行已编译的代码，否则就把回边计数器值加 1，然后判断方法调用计数器和回边计数器值之和是否超过计数器的阈值。当超过阈值时，将会提交一个 OSR 编译请求，并且把回边计数器的值降低一些，以便继续在解释器中执行循环，等待编译器输出编译结果。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/5/回边计数器触发即时编译.png" width="65%"></div>

<p>与方法计数器不同，回边计数器没有计算热度衰减的过程，因此这个计数器统计的就是该方法循环执行的绝对次数。当计数器溢出时，它还会把方法计数器的值也调整到溢出状态，这样下次再进入该方法的时候就会执行标准编译过程。</p>
<h3 id="2-2-编译优化技术"><a href="#2-2-编译优化技术" class="headerlink" title="2.2 编译优化技术"></a>2.2 编译优化技术</h3><p>我们都知道，以编译方式执行本地代码比解释执行方式更快，一方面是因为节约了虚拟机解释执行字节码额外消耗的时间；另一方面是因为虚拟机设计团队几乎把所有对代码的优化措施都集中到了即时编译器中。这一小节我们来介绍下 HotSpot 虚拟机的即时编译器在编译代码时采用的优化技术。</p>
<h4 id="优化技术概览"><a href="#优化技术概览" class="headerlink" title="优化技术概览"></a>优化技术概览</h4><p>代码优化技术有很多，实现这些优化也很有难度，但是大部分还是比较好理解的。为了便于介绍，我们先从一段简单的代码开始，看看虚拟机会做哪些代码优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</div><div class="line">    <span class="keyword">int</span> value;</div><div class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    y = b.get();</div><div class="line">    z = b.get();</div><div class="line">    sum = y + z;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>首先需要明确的是，这些代码优化是建立在代码的某种中间表示或者机器码上的，绝不是建立在 Java 源码上。这里之所使用 Java 代码来介绍是为了方便演示。</p>
<p>上面这段代码看起来简单，但是有许多可以优化的地方。</p>
<p>第一步是进行方法内联（Method Inlining），方法内联的重要性要高于其它优化措施。方法内联的目的主要有两个，一是去除方法调用的成本（比如建立栈帧），二是为其它优化建立良好的基础，方法内联膨胀之后可以便于更大范围上采取后续的优化手段，从而获得更好的优化效果。因此，各种编译器一般都会把内联优化放在优化序列的最前面。内联优化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    y = b.value;</div><div class="line">    z = b.value;</div><div class="line">    sum = y + z;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第二步进行冗余消除，代码中「z = b.value;」可以被替换成「z = y」。这样就不用再去访问对象 b 的局部变量。如果把 b.value 看做是一个表达式，那也可以把这项优化工作看成是公共子表达式消除。优化后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    y = b.value;</div><div class="line">    z = y;</div><div class="line">    sum = y + z;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第三步进行复写传播，因为这段代码里没有必要使用一个额外的变量 z，它与变量 y 是完全等价的，因此可以使用 y 来代替 z。复写传播后的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    y = b.value;</div><div class="line">    y = y;</div><div class="line">    sum = y + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>第四步进行无用代码消除。无用代码可能是永远不会执行的代码，也可能是完全没有意义的代码。因此，又被形象的成为「Dead Code」。上述代码中 y = y 是没有意义的，因此进行无用代码消除后的代码是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</div><div class="line">    y = b.value;</div><div class="line">    sum = y + y;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>经过这四次优化后，最新优化后的代码和优化前的代码所达到的效果是一致的，但是优化后的代码执行效率会更高。编译器的这些优化技术实现起来是很复杂的，但是想要理解它们还是很容易的。接下来我们再讲讲如下几项最有代表性的优化技术是如何运作的，它们分别是：</p>
<ul>
<li>公共子表达式消除；</li>
<li>数组边界检查消除；</li>
<li>方法内联；</li>
<li>逃逸分析。</li>
</ul>
<h4 id="公共子表达式消除"><a href="#公共子表达式消除" class="headerlink" title="公共子表达式消除"></a>公共子表达式消除</h4><p>如果一个表达式 E 已经计算过了，并且从先前的计算到现在 E 中所有变量的值都没有发生变化，那么 E 的这次出现就成了公共子表达式。对于这种表达式，没有必要花时间再对它进行计算，只需要直接使用前面计算过的表达式结果代替 E 就好了。如果这种优化仅限于程序的基本块内，便称为局部公共子表达式消除，如果这种优化的范围覆盖了多个基本块，那就称为全局公共子表达式消除。</p>
<h4 id="数组边界检查消除"><a href="#数组边界检查消除" class="headerlink" title="数组边界检查消除"></a>数组边界检查消除</h4><p>如果有一个数组 array[]，在 Java 中访问数组元素 array[i] 的时候，系统会自动进行上下界的范围检查，即检查 i 必须满足 i &gt;= 0 &amp;&amp; i &lt; array.length，否则会抛出一个运行时异常：java.lang.ArrayIndexOutOfBoundsException，这就是数组边界检查。</p>
<p>对于虚拟机执行子系统来说，每次数组元素的读写都带有一次隐含的条件判定操作，对于拥有大量数组访问的程序代码，这是一种不小的性能开销。为了安全，数组边界检查是必须做的，但是数组边界检查并不一定每次都要进行。比如在循环的时候访问数组，如果编译器只要通过数据流分析就知道循环变量是不是在区间 [0, array.length] 之内，那在整个循环中就可以把数组的上下界检查消除。</p>
<h4 id="方法内联"><a href="#方法内联" class="headerlink" title="方法内联"></a>方法内联</h4><p>方法内联前面已经通过代码分析介绍过，这里就不再赘述了。</p>
<h4 id="逃逸分析"><a href="#逃逸分析" class="headerlink" title="逃逸分析"></a>逃逸分析</h4><p>逃逸分析不是直接优化代码的手段，而是为其它优化手段提供依据的分析技术。逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其它方法中，称为方法逃逸。甚至还有可能被外部线程访问到，例如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸。</p>
<p>如果能证明一个对象不会逃逸到方法或者线程之外，也就是别的方法和线程无法通过任何途径访问到这个方法，则可能为这个变量进行一些高效优化。比如：</p>
<ol>
<li>栈上分配：如果确定一个对象不会逃逸到方法之外，那么就可以在栈上分配内存，对象所占的内存空间就可以随栈帧出栈而销毁。通常，不会逃逸的局部对象所占的比例很大，如果能栈上分配就会大大减轻 GC 的压力。</li>
<li>同步消除：如果逃逸分析能确定一个变量不会逃逸出线程，无法被其它线程访问，那这个变量的读写就不会有多线程竞争的问题，因而变量的同步措施也就可以消除了。</li>
<li>标量替换：标量是指一个数据无法再拆分成更小的数据来表示了，Java 虚拟机中的原始数据类型都不能再进一步拆分，所以它们就是标量。相反，一个数据可以继续分解，那它就称作聚合量，Java 中的对象就是聚合量。如果把一个 Java 对象拆散，根据访问情况将其使用到的成员变量恢复成原始类型来访问，就叫标量替换。如果逃逸分析证明一个对象不会被外部访问，并且这个对象可以被拆散，那程序执行的时候就可能不创建这个对象，而改为直接创建它的若干个被这个方法使用到的成员变量来替代。对象被拆分后，除了可以让对象的成员变量在栈上分配和读写，还可以为后续进一步的优化手段创造条件。</li>
</ol>
<h2 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h2><p>本文用两个小节分别介绍了 Java 程序从源代码编译成字节码和从字节码编译成本地机器码的过程，Javac 字节码编译器与虚拟机内的 JIT 编译器的执行过程合并起来其实就等同于一个传统编译器所执行的编译过程。下一篇文章我们来聊聊虚拟机是如何高效处理并发的。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版）》</li>
</ul>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首发于微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，欢迎关注！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于性能和效率的追求一直是程序开发中永恒不变的宗旨，除了我们自己在编码过程中要充分考虑代码的性能和效率，虚拟机在编译阶段也会对代码进行优化。本文就从虚拟机层面来看看虚拟机对我们所编写的代码采用了哪些优化手段。&lt;/p&gt;
&lt;h2 id=&quot;一-早期优化（编译期优化）&quot;&gt;&lt;a href=&quot;#一-早期优化（编译期优化）&quot; class=&quot;headerlink&quot; title=&quot;一. 早期优化（编译期优化）&quot;&gt;&lt;/a&gt;一. 早期优化（编译期优化）&lt;/h2&gt;&lt;p&gt;Java 语言的「编译期」其实是一段「不确定」的操作过程。因为它可能是一个前端编译器（如 Javac）把 &lt;em&gt;.java 文件编译成 &lt;/em&gt;.class 文件的过程；也可能是程序运行期的即时编译器（JIT 编译器，Just In Time Compiler）把字节码文件编译成机器码的过程；还可能是静态提前编译器（AOT 编译器，Ahead Of Time Compiler）直接把 *.java 文件编译成本地机器码的过程。&lt;/p&gt;
&lt;p&gt;Javac 这类编译器对代码的运行效率几乎没有任何优化措施，虚拟机设计团队把对性能的优化都放到了后端的即时编译器中，这样可以让那些不是由 Javac 产生的 class 文件（如 Groovy、Kotlin 等语言产生的 class 文件）也能享受到编译器优化带来的好处。但是 Javac 做了很多针对 Java 语言编码过程的优化措施来改善程序员的编码风格、提升编码效率。相当多新生的 Java 语法特性，都是靠编译器的「语法糖」来实现的，而不是依赖虚拟机的底层改进来支持。&lt;/p&gt;
&lt;p&gt;Java 中即时编译器在运行期的优化过程对于程序运行来说更重要，而前端编译器在编译期的优化过程对于程序编码来说更加密切。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://baronzhang.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://baronzhang.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>系列 | 深入理解Java虚拟机四（字节码执行引擎）</title>
    <link href="http://baronzhang.com//blog/JVM/%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%9B%9B%EF%BC%88%E5%AD%97%E8%8A%82%E7%A0%81%E6%89%A7%E8%A1%8C%E5%BC%95%E6%93%8E%EF%BC%89/"/>
    <id>http://baronzhang.com//blog/JVM/系列-深入理解Java虚拟机四（字节码执行引擎）/</id>
    <published>2019-08-19T16:26:41.000Z</published>
    <updated>2019-08-19T17:00:38.054Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>首发于微信公众号：<strong>BaronTalk</strong>，欢迎关注！</p>
</blockquote>
<p>执行引擎是 Java 虚拟机最核心的组成部分之一。「虚拟机」是相对于「物理机」的概念，这两种机器都有代码执行的能力，区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机执行引擎是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。</p>
<p>在 Java 虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种方式，也可能两者都有，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上来看，所有 Java 虚拟机的执行引擎是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。</p>
<h2 id="一-运行时栈帧结构"><a href="#一-运行时栈帧结构" class="headerlink" title="一. 运行时栈帧结构"></a>一. 运行时栈帧结构</h2><p>栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量、操作数栈、动态链接和方法返回地址等信息。<strong>每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。</strong></p>
<a id="more"></a>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态链接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表，多深的操作数栈都已经完全确定了，并且写入到方法表的 Code 属性之中，因此一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。</p>
<p>一个线程中的方法调用链可能会很长，很多方法都处于执行状态。对于执行引擎来说，在活动线程中，只有位于栈顶的栈帧才是有效的，称为当前栈帧（Current Stack Frame），与这个栈帧相关联的方法成为当前方法。执行引擎运行的所有字节码指令对当前栈帧进行操作，在概念模型上，典型的栈帧结构如下图：</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/4/运行时栈帧结构.png" width="55%"></div>

<h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>局部变量表（Local Variable Table）是一组变量值存储空间，用于存放方法参数和方法内部定义的局部变量。在 Java 程序中编译为 Class 文件时，就在方法的 Code 属性的 max_locals 数据项中确定了该方法所需要分配的局部变量表的最大容量。</p>
<h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>操作数栈（Operand Stack）是一个后进先出栈。同局部变量表一样，操作数栈的最大深度也在编译阶段写入到 Code 属性的 max_stacks 数据项中。操作数栈的每一个元素可以是任意的 Java 数据类型，包括 long 和 double。32 位数据类型所占的栈容量为 1，64 位数据类型所占的栈容量为 2。在方法执行的任何时候，操作数栈的深度都不会超过 max_stacks 数据项中设定的最大值。</p>
<p>一个方法刚开始执行的时候，该方法的操作数栈是空的，在方法的执行过程中，会有各种字节码指令往操作数栈中写入和提取内容，也就是入栈和出栈操作。</p>
<h3 id="动态链接"><a href="#动态链接" class="headerlink" title="动态链接"></a>动态链接</h3><p>每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态链接（Dynamic Linking）。Class 文件的常量池中存在大量的符号引用，字节码中的方法调用指令就以常量池中指向方法的符号引用作为参数，这些符号引用一部分会在类加载阶段或第一次使用时转化为直接引用，这种转化成为静态解析。另一部分将在每一次运行期间转化为直接引用，这部分称为动态连接。</p>
<h3 id="方法返回地址"><a href="#方法返回地址" class="headerlink" title="方法返回地址"></a>方法返回地址</h3><p>当一个方法开始执行后，只有两种方式可以退出这个方法。</p>
<p>一种是执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层方法的调用者，是否有返回值和返回值的类型将根据遇到何种方法返回指令来决定，这种退出方法的方式称为<strong>正常完成出口</strong>。</p>
<p>另一种退出方式是，在方法执行过程中遇到了异常，并且这个异常没有在方法体内得到处理，无论是 Java 虚拟机内部产生的异常，还是代码中使用 athrow 字节码指令产生的异常，只要在本方法的异常表中没有搜索到匹配的异常处理器，就会导致方法退出。这种称为<strong>异常完成出口</strong>。一个方法使用异常完成出口的方式退出，是不会给上层调用者产生任何返回值的。</p>
<p>无论采用何种退出方式，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行，方法返回时可能需要在栈帧中保存一些信息，用来恢复它的上层方法的执行状态。一般来说，方法正常退出时，调用者的 PC 计数器的值可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中一般不会保存这部分信息。</p>
<p>方法退出的过程实际上就等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上次方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整 PC 计数器的值以指向方法调用指令后面的一条指令等。</p>
<h3 id="附加信息"><a href="#附加信息" class="headerlink" title="附加信息"></a>附加信息</h3><p>虚拟机规范允许具体的虚拟机实现增加一些规范里没有描述的信息到栈帧中，例如与调试相关的信息，这部分信息完全取决于具体的虚拟机实现。实际开发中，一般会把动态连接、方法返回地址与其他附加信息全部归为一类，成为栈帧信息。</p>
<h2 id="二-方法调用"><a href="#二-方法调用" class="headerlink" title="二. 方法调用"></a>二. 方法调用</h2><p>方法调用并不等同于方法执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程。</p>
<p>在程序运行时，进行方法调用是最为普遍、频繁的操作。前面说过 Class 文件的编译过程是不包含传统编译中的连接步骤的，一切方法调用在 Class 文件里面存储的都只是符号引用，而不是方法在运行时内存布局中的入口地址（相当于之前说的直接引用）。这个特性给 Java 带来了更强大的动态扩展能力，但也使得 Java 方法调用过程变得相对复杂起来，需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>所有方法调用中的目标方法在 Class 文件里都是一个常量池中的符号引用，在类加载的解析阶段，会将其中一部分符号引用转化为直接引用，这种解析能成立的前提是方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。话句话说，调用目标在程序代码写好、编译器进行编译时就必须确定下来。这类方法的调用称为解析（Resolution）。</p>
<p>Java 语言中符合「编译器可知，运行期不可变」这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或者别的方式重写其它版本，因此它们都适合在类加载阶段解析。</p>
<p>与之相应的是，在 Java 虚拟机里提供了 5 条方法调用字节码指令，分别是：</p>
<ul>
<li>invokestatic：调用静态方法；</li>
<li>invokespecial：调用实例构造器 <init> 方法、私有方法和父类方法；</init></li>
<li>invokevirtual：调用所有虚方法；</li>
<li>invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象；</li>
<li>invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。</li>
</ul>
<p>只要能被 invokestatic 和 invokespecial 指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构造器、父类方法 4 类，它们在加载的时候就会把符号引用解析为直接引用。这些方法可以称为非虚方法，与之相反，其它方法称为虚方法（final 方法除外）。</p>
<p>Java 中的非虚方法除了使用 invokestatic、invokespecial 调用的方法之外还有一种，就是被 final 修饰的方法。虽然 final 方法是使用 invokevirtual 指令来调用的，但是由于它无法被覆盖，没有其它版本，所以也无需对方法接受者进行多态选择，又或者说多态选择的结果肯定是唯一的。在 Java 语言规范中明确说明了 final 方法是一种非虚方法。</p>
<p>解析调用一定是个静态过程，在编译期间就能完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用，不会延迟到运行期再去完成。而分派（Dispatch）调用则可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式的两两组合就构成了静态单分派、静态多分派、动态单分派、动态多分派 4 种分派组合情况，下面我们再看看虚拟机中的方法分派是如何进行的。</p>
<h3 id="分派"><a href="#分派" class="headerlink" title="分派"></a>分派</h3><p>面向对象有三个基本特征，封装、继承和多态。这里要说的分派将会揭示多态特征的一些最基本的体现，如「重载」和「重写」在 Java 虚拟机中是如何实现的？虚拟机是如何确定正确目标方法的？</p>
<p><strong>静态分派</strong></p>
<p>在开始介绍静态分派前我们先看一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 方法静态分派演示</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> baronzhang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticDispatch</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Human guy)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, guy!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Man man)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, man!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Woman woman)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, woman!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human woman = <span class="keyword">new</span> Woman();</div><div class="line">        StaticDispatch dispatch = <span class="keyword">new</span> StaticDispatch();</div><div class="line">        dispatch.sayHello(man);</div><div class="line">        dispatch.sayHello(woman);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>运行后这段程序的输出结果如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Hello, guy!</div><div class="line">Hello, guy!</div></pre></td></tr></table></figure>
<p>稍有经验的 Java 程序员都能得出上述结论，但为什么我们传递给 sayHello() 方法的实际参数类型是 Man 和 Woman，虚拟机在执行程序时选择的却是 Human 的重载呢？要理解这个问题，我们先弄清两个概念。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Human man = <span class="keyword">new</span> Man();</div></pre></td></tr></table></figure>
<p>上面这段代码中的「Human」称为变量的静态类型（Static Type），或者叫做外观类型（Apparent Type），后面的「Man」称为变量为实际类型（Actual Type），静态类型和实际类型在程序中都可以发生一些变化，区别是静态类型的变化仅发生在使用时，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么。</p>
<p>弄清了这两个概念，再来看 StaticDispatch 类中 main() 方法里的两次 sayHello() 调用，在方法接受者已经确定是对象「dispatch」的前提下，使用哪个重载版本，就完全取决于传入参数的数量和数据类型。代码中定义了两个静态类型相同但是实际类型不同的变量，但是虚拟机（准确的说是编译器）在重载时是通过参数的静态类型而不是实际类型作为判定依据的。并且静态类型是编译期可知的，因此在编译阶段， Javac 编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了 sayHello(Human) 作为调用目标，并把这个方法的符号引用写到 man() 方法里的两条 invokevirtual 指令的参数中。</p>
<p>所有依赖静态类型来定位方法执行版本的分派动作称为<strong>静态分派</strong>。静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。 </p>
<p>另外，编译器虽然能确定方法的重载版本，但是很多情况下这个重载版本并不是「唯一」的，因此往往只能确定一个「更加合适」的版本。<strong>产生这种情况的主要原因是字面量不需要定义，所以字面量没有显示的静态类型，它的静态类型只能通过语言上的规则去理解和推断</strong>。下面的代码展示了什么叫「更加合适」的版本。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * <span class="doctag">@author</span> baronzhang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Overlaod</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Object arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, Object!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, int!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, long!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Character arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, Character!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span> arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, char!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">char</span>... arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, char...!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(Serializable arg)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Hello, Serializable!"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">        sayHello(<span class="string">'a'</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的运行结果为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, char!</div></pre></td></tr></table></figure>
<p>这很好理解，‘a’ 是一个 char 类型的数据，自然会寻找参数类型为 char 的重载方法，如果注释掉 sayHello(chat arg) 方法，那么输出结果将会变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, int!</div></pre></td></tr></table></figure>
<p>这时发生了一次类型转换， ‘a’ 除了可以代表一个字符，还可以代表数字 97，因为字符 ‘a’ 的 Unicode 数值为十进制数字 97，因此参数类型为 int 的重载方法也是合适的。我们继续注释掉 sayHello(int arg) 方法，输出变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, long!</div></pre></td></tr></table></figure>
<p>这时发生了两次类型转换，‘a’ 转型为整数 97 之后，进一步转型为长整型 97L，匹配了参数类型为 long 的重载方法。我们继续注释掉 sayHello(long arg) 方法，输出变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, Character!</div></pre></td></tr></table></figure>
<p>这时发生了一次自动装箱， ‘a’ 被包装为它的封装类型 java.lang.Character，所以匹配到了类型为 Character 的重载方法，继续注释掉 sayHello(Character arg) 方法，输出变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, Serializable!</div></pre></td></tr></table></figure>
<p>这里输出之所以为「Hello, Serializable!」，是因为 java.lang.Serializable 是 java.lang.Character 类实现的一个接口，当自动装箱后发现还是找不到装箱类，但是找到了装箱类实现了的接口类型，所以紧接着又发生了一次自动转换。char 可以转型为 int，但是 Character 是绝对不会转型为 Integer 的，他只能安全的转型为它实现的接口或父类。Character 还实现了另外一个接口 java.lang.Comparable<character>，如果同时出现两个参数分别为 Serializable 和 Comparable<character> 的重载方法，那它们在此时的优先级是一样的。编译器无法确定要自动转型为哪种类型，会提示类型模糊，拒绝编译。程序必须在调用时显示的指定字面量的静态类型，如：sayHello((Comparable<character>) ‘a’)，才能编译通过。继续注释掉 sayHello(Serializable arg) 方法，输出变为：</character></character></character></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, Object!</div></pre></td></tr></table></figure>
<p>这时是 char 装箱后转型为父类了，如果有多个父类，那将在继承关系中从下往上开始搜索，越接近上层的优先级越低。即使方法调用的入参值为 null，这个规则依然适用。继续注释掉 sayHello(Serializable arg) 方法，输出变为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Hello, char...!</div></pre></td></tr></table></figure>
<p>7 个重载方法以及被注释得只剩一个了，可见变长参数的重载优先级是最低的，这时字符 ‘a’ 被当成了一个数组元素。</p>
<p>前面介绍的这一系列过程演示了编译期间选择静态分派目标的过程，这个过程也是 Java 语言实现方法重载的本质。</p>
<p><strong>动态分派</strong></p>
<p>动态分派和多态性的另一个重要体现「重写（Override）」有着密切的关联，我们依旧通过代码来理解什么是动态分派。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 方法动态分派演示</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> baronzhang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicDispatch</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span></span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Man</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Man say hello!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Woman</span> <span class="keyword">extends</span> <span class="title">Human</span> </span>&#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Woman say hello!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">        Human man = <span class="keyword">new</span> Man();</div><div class="line">        Human woman = <span class="keyword">new</span> Woman();</div><div class="line">        man.sayHello();</div><div class="line">        woman.sayHello();</div><div class="line"></div><div class="line">        man = <span class="keyword">new</span> Woman();</div><div class="line">        man.sayHello();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">Man say hello!</div><div class="line">Woman say hello!</div><div class="line">Woman say hello!</div></pre></td></tr></table></figure>
<p>对于上面的代码，虚拟机是如何确定要调用哪个方法的呢？显然这里不再通过静态类型来决定了，因为静态类型同样都是 Human 的两个变量 man 和 woman 在调用 sayHello() 方法时执行了不同的行为，并且变量 man 在两次调用中执行了不同的方法。导致这个结果的原因是因为它们的实际类型不同。对于虚拟机是如何通过实际类型来分派方法执行版本的，这里我们就不做介绍了，有兴趣的可以去看看原著。</p>
<p>我们把这种在运行期根据实际类型来确定方法执行版本的分派称为<strong>动态分派</strong>。</p>
<p><strong>单分派和多分派</strong></p>
<p>方法的接收者和方法的参数统称为方法的宗量，这个定义最早来源于《Java 与模式》一书。根据分派基于多少宗量，可将分派划分为<strong>单分派</strong>和<strong>多分派</strong>。</p>
<p>单分派是根据一个宗量来确定方法的执行版本；多分派则是根据多余一个宗量来确定方法的执行版本。</p>
<p>我们依旧通过代码来理解(代码以著名的 3Q 大战作为背景)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 单分派、多分派演示</div><div class="line"> *</div><div class="line"> * <span class="doctag">@author</span> baronzhang</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dispatch</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QQ</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">QiHu360</span> </span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ qq)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Father choice QQ!"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QiHu360 qiHu360)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Father choice 360!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QQ qq)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Son choice QQ!"</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">hardChoice</span><span class="params">(QiHu360 qiHu360)</span> </span>&#123;</div><div class="line">            System.out.println(<span class="string">"Son choice 360!"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        Father father = <span class="keyword">new</span> Father();</div><div class="line">        Father son = <span class="keyword">new</span> Son();</div><div class="line"></div><div class="line">        father.hardChoice(<span class="keyword">new</span> QQ());</div><div class="line">        son.hardChoice(<span class="keyword">new</span> QiHu360());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>代码输出结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Father choice QQ!</div><div class="line">Son choice 360!</div></pre></td></tr></table></figure>
<p>我们先来看看编译阶段编译器的选择过程，也就是静态分派过程。这个时候选择目标方法的依据有两点：一是静态类型是 Father 还是 Son；二是方法入参是 QQ 还是 QiHu360。<strong>因为是根据两个宗量进行选择的，所以 Java 语言的静态分派属于多分派</strong>。</p>
<p>再看看运行阶段虚拟机的选择过程，也就是动态分派的过程。在执行 son.hardChoice(new QiHu360()) 时，由于编译期已经确定目标方法的签名必须为 hardChoice(QiHu360)，这时参数的静态类型、实际类型都不会对方法的选择造成任何影响，唯一可以影响虚拟机选择的因数只有此方法的接收者的实际类型是 Father 还是 Son。因为只有一个宗量作为选择依据，所以 Java 语言的动态分派属于单分派。</p>
<p>综上所述，Java 语言是一门静态多分派、动态单分派的语言。</p>
<h2 id="三-基于栈的字节码解释执行引擎"><a href="#三-基于栈的字节码解释执行引擎" class="headerlink" title="三. 基于栈的字节码解释执行引擎"></a>三. 基于栈的字节码解释执行引擎</h2><p>虚拟机如何调用方法已经介绍完了，下面我们来看看虚拟机是如何执行方法中的字节码指令的。</p>
<h3 id="解释执行"><a href="#解释执行" class="headerlink" title="解释执行"></a>解释执行</h3><p>Java 语言常被人们定义成「解释执行」的语言，但随着 JIT 以及可直接将 Java 代码编译成本地代码的编译器的出现，这种说法就不对了。只有确定了谈论对象是某种具体的 Java 实现版本和执行引擎运行模式时，谈解释执行还是编译执行才会比较确切。</p>
<p>无论是解释执行还是编译执行，无论是物理机还是虚拟机，对于应用程序，机器都不可能像人一样阅读、理解，然后获得执行能力。大部分的程序代码到物理机的目标代码或者虚拟机执行的指令之前，都需要经过下图中的各个步骤。下图中最下面的那条分支，就是传统编译原理中程序代码到目标机器代码的生成过程；中间那条分支，则是解释执行的过程。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/4/编译过程.png" width="85%"></div>

<p>如今，基于物理机、Java 虚拟机或者非 Java 的其它高级语言虚拟机的语言，大多都会遵循这种基于现代编译原理的思路，在执行前先对程序源代码进行词法分析和语法分析处理，把源代码转化为抽象语法树。对于一门具体语言的实现来说，词法分析、语法分析以至后面的优化器和目标代码生成器都可以选择独立于执行引擎，形成一个完整意义的编译器去实现，这类代表是 C/C++。也可以为一个半独立的编译器，这类代表是 Java。又或者把这些步骤和执行全部封装在一个封闭的黑匣子中，如大多数的 JavaScript 执行器。</p>
<p>Java 语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树、再遍历语法树生成字节码指令流的过程。因为这一部分动作是在 Java 虚拟机之外进行的，而解释器在虚拟机的内部，所以 Java 程序的编译就是半独立的实现。</p>
<p>许多 Java 虚拟机的执行引擎在执行 Java 代码的时候都有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。而对于最新的 Android 版本的执行模式则是 AOT + JIT + 解释执行，关于这方面我们后面有机会再聊。</p>
<h3 id="基于栈的指令集与基于寄存器的指令集"><a href="#基于栈的指令集与基于寄存器的指令集" class="headerlink" title="基于栈的指令集与基于寄存器的指令集"></a>基于栈的指令集与基于寄存器的指令集</h3><p>Java 编译器输出的指令流，基本上是一种基于栈的指令集架构。基于栈的指令集主要的优点就是可移植，寄存器由硬件直接提供，程序直接依赖这些硬件寄存器则不可避免的要受到硬件约束。栈架构的指令集还有一些其他优点，比如相对更加紧凑（字节码中每个字节就对应一条指令，而多地址指令集中还需要存放参数）、编译实现更加简单（不需要考虑空间分配的问题，所有空间都是在栈上操作）等。</p>
<p>栈架构指令集的主要缺点是执行速度相对来说会稍慢一些。所有主流物理机的指令集都是寄存器架构也从侧面印证了这一点。</p>
<p>虽然栈架构指令集的代码非常紧凑，但是完成相同功能需要的指令集数量一般会比寄存器架构多，因为出栈、入栈操作本身就产生了相当多的指令数量。更重要的是，栈实现在内存中，频繁的栈访问也意味着频繁的内存访问，相对于处理器来说，内存始终是执行速度的瓶颈。由于指令数量和内存访问的原因，所以导致了栈架构指令集的执行速度会相对较慢。</p>
<p>正是基于上述原因，Android 虚拟机中采用了基于寄存器的指令集架构。不过有一点不同的是，前面说的是物理机上的寄存器，而 Android 上指的是虚拟机上的寄存器。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>这一篇我们介绍了虚拟机是如何执行方法中的字节码指令的，下一篇文章我们来重点介绍下虚拟机是如何优化我们所编写的代码的。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版）》</li>
</ul>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首发于微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，欢迎关注！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行引擎是 Java 虚拟机最核心的组成部分之一。「虚拟机」是相对于「物理机」的概念，这两种机器都有代码执行的能力，区别是物理机的执行引擎是直接建立在处理器、硬件、指令集和操作系统层面上的，而虚拟机执行引擎是由自己实现的，因此可以自行制定指令集与执行引擎的结构体系，并且能够执行那些不被硬件直接支持的指令集格式。&lt;/p&gt;
&lt;p&gt;在 Java 虚拟机规范中制定了虚拟机字节码执行引擎的概念模型，这个概念模型成为各种虚拟机执行引擎的统一外观（Facade）。在不同的虚拟机实现里，执行引擎在执行 Java 代码的时候可能会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种方式，也可能两者都有，甚至还可能会包含几个不同级别的编译器执行引擎。但从外观上来看，所有 Java 虚拟机的执行引擎是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。&lt;/p&gt;
&lt;h2 id=&quot;一-运行时栈帧结构&quot;&gt;&lt;a href=&quot;#一-运行时栈帧结构&quot; class=&quot;headerlink&quot; title=&quot;一. 运行时栈帧结构&quot;&gt;&lt;/a&gt;一. 运行时栈帧结构&lt;/h2&gt;&lt;p&gt;栈帧（Stack Frame）是用于支持虚拟机进行方法调用和方法执行的数据结构，它是虚拟机运行时数据区中的虚拟机栈的栈元素。栈帧存储了方法的局部变量、操作数栈、动态链接和方法返回地址等信息。&lt;strong&gt;每一个方法从调用开始到执行完成的过程，都对应着一个栈帧在虚拟机栈里从入栈到出栈的过程。&lt;/strong&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://baronzhang.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://baronzhang.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>系列 | 深入理解Java虚拟机三（类加载机制）</title>
    <link href="http://baronzhang.com//blog/JVM/%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%89%EF%BC%88%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <id>http://baronzhang.com//blog/JVM/系列-深入理解Java虚拟机三（类加载机制）/</id>
    <published>2019-08-19T16:25:48.000Z</published>
    <updated>2019-08-19T17:00:31.720Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>首发于微信公众号：<strong>BaronTalk</strong>，欢迎关注！</p>
</blockquote>
<p>上一篇文章我们介绍了<a href="https://mp.weixin.qq.com/s/mSqiItrTAhlk0UY-0j5TpA" target="_blank" rel="external">「类文件结构」</a>，这一篇我们来看看虚拟机是如何加载类的。</p>
<p>我们的源代码经过编译器编译成字节码之后，最终都需要加载到虚拟机之后才能运行。虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的<strong>类加载机制</strong>。</p>
<p>与编译时需要进行连接工作的语言不同，Java 语言中类的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会让类加载时增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可动态扩展的语言特性就是依赖运行期间动态加载和动态连接的特点实现的。</p>
<p>例如，一个面向接口的应用程序，可以等到运行时再指定实际的实现类；用户可以通过 Java 预定义的和自定义的类加载器，让一个本地的应用程序运行从网络上或其它地方加载一个二进制流作为程序代码的一部分。</p>
<h2 id="一-类加载时机"><a href="#一-类加载时机" class="headerlink" title="一. 类加载时机"></a>一. 类加载时机</h2><p>类从被虚拟机从加载到卸载，整个生命周期包含：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）7 个阶段。其中验证、准备、解析 3 个部分统称为连接（Linking）。这 7 个阶段的发生顺序如下图：</p>
<a id="more"></a>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/3/类加载过程.png" width="85%"></div>

<p>上图中加载、验证、准备、初始化和卸载 5 个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班的开始「注意，这里说的是按部就班的开始，并不要求前一阶段执行完才能进入下一阶段」，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持 Java 的动态绑定。</p>
<p>虚拟机规范中对于什么时候开始类加载过程的第一节点「加载」并没有强制约束。但是对于「初始化」阶段，虚拟机则是严格规定了有且只有以下 5 种情况，如果类没有进行初始化，则必须立即对类进行「初始化」（加载、验证、准备自然需要在此之前开始）：</p>
<ol>
<li>遇到 new、getstatic、putstatic 或 invokestatic 这 4 条字节码指令；</li>
<li>使用 java.lang.reflect 包的方法对类进行反射调用的时候；</li>
<li>当初始化一个类的时候，发现其父类还没有进行初始化的时候，需要先触发其父类的初始化；</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类，虚拟机会先初始化这个类；</li>
<li>当使用 JDK 1.7 的动态语言支持时，如果一个 java.lang.invoke.MethodHandle 实例最后的解析结果 REF_getStatic、REF_putStatic、REF_invokeStatic 的方法句柄，并且这个方法句柄所对应的类没有初始化。</li>
</ol>
<p>「有且只有」以上 5 种场景会触发类的初始化，这 5 种场景中的行为称为对一个类的主动引用。除此之外，所有引用类的方式都不会触发初始化，称为被动引用。比如如下几种场景就是被动引用：</p>
<ol>
<li>通过子类引用父类的静态字段，不会导致子类的初始化；</li>
<li>通过数组定义来引用类，不会触发此类的初始化；</li>
<li>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化；</li>
</ol>
<h2 id="二-类加载过程"><a href="#二-类加载过程" class="headerlink" title="二. 类加载过程"></a>二. 类加载过程</h2><h3 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h3><p>这里的「加载」是指「类加载」过程的一个阶段。在加载阶段，虚拟机需要完成以下 3 件事：</p>
<ol>
<li>通过一个类的全限定名来获取定义此类的二进制字节流；</li>
<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构；</li>
<li>在内存中生成一个代表这个类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。</li>
</ol>
<h3 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h3><p>验证是连接阶段的第一步，这一阶段的目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致上会完成下面 4 个阶段的检验动作：</p>
<ol>
<li><strong>文件格式验证</strong>：第一阶段要验证字节流是否符合 Class 文件格式的规范，并且能够被当前版本的虚拟机处理。验证点主要包括：是否以魔数 0xCAFEBABE 开头；主、次版本号是否在当前虚拟机处理范围之内；常量池的常量中是否有不被支持的常量类型；Class 文件中各个部分及文件本身是否有被删除的或者附加的其它信息等等。</li>
<li><strong>元数据验证</strong>：第二阶段是对字节码描述的信息进行语义分析，以保证其描述的信息符合 Java 语言规范的要求，这个阶段的验证点包括：这个类是否有父类；这个类的父类是否继承了不允许被继承的类；如果这个类不是抽象类，是否实现了其父类或者接口之中要求实现的所有方法；类中的字段、方法是否与父类产生矛盾等等。</li>
<li><strong>字节码验证</strong>：第三阶段是整个验证过程中最复杂的一个阶段，主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li>
<li><strong>符号引用验证</strong>：最后一个阶段的校验发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段–解析阶段中发生。符号引用验证可以看做是对类自身以外（常量池中的各种符号引用）的形象进行匹配性校验。</li>
</ol>
<h3 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h3><p>准备阶段是正式为类变量分配内存并设置类变量初始值的阶段，这些变量所使用的内存都将在方法区进行分配。这个阶段中有两个容易产生混淆的概念需要强调下：</p>
<ul>
<li>首先，这时候进行内存分配的仅包括类变量（被 static 修饰的变量），而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在 Java 堆中；</li>
<li>其次这里所说的初始值「通常情况」下是数据类型的零值。假设一个类变量的定义为<code>public static int value = 123;</code> 那么变量 <code>value</code> 在准备阶段过后的初始值为 0 而不是 123，因为这个时候尚未执行任何 Java 方法，而把 value 赋值为 123 的 putstatic 指令是程序被编译之后，存放于类构造器 <init>() 方法之中，所以把 value 赋值为 123 的动作将在初始化阶段才会执行。</init></li>
</ul>
<p>这里提到，在「通常情况」下初始值是零值，那相对的会有一些「特殊情况」：如果类字段的字段属性表中存在 ConstantsValue 属性，那在准备阶段变量 value 就会被初始化为 ConstantValue 属性所指的值。假设上面的类变量 value 的定义变为 <code>public static final int value = 123;</code>，编译时 JavaC 将会为 value 生成 ConstantValue 属性，在准备阶段虚拟机就会根据 ConstantValue 的设置将 value 赋值为 123。</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>解析阶段是虚拟机将常量池内的符号引用替换为直接引用的过程。前面提到过很多次符号引用和直接引用，那么到底什么是符号引用和直接引用呢？</p>
<ul>
<li><strong>符号引用（Symbolic Reference）</strong>：符号引用以一组符号来描述所引用的目标，符号可以上任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li>
<li><strong>直接引用（Direct Reference）</strong>：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。</li>
</ul>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>类初始化阶段是类加载过程中的最后一步，前面的类加载过程中，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全是由虚拟机主导和控制的。到了初始化阶段，才真正开始执行类中定义的 Java 程序代码。初始阶段是执行类构造器 <init>() 方法的过程。</init></p>
<h2 id="三-类加载器"><a href="#三-类加载器" class="headerlink" title="三. 类加载器"></a>三. 类加载器</h2><p>虚拟机设计团队把类加载阶段中的「通过一个类的全限定名来获取描述此类的二进制字节流」这个动作放到 Java 虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为「类加载器」。</p>
<h3 id="类与类加载器"><a href="#类与类加载器" class="headerlink" title="类与类加载器"></a>类与类加载器</h3><p>对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在 Java 虚拟机的唯一性，每个类加载器都拥有一个独立的类名称空间。也就是说：比较两个类是否「相等」，只要在这两个类是由同一个类加载器加载的前提下才有意义，否则，即使这两个类来源于同一个 Class 文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。</p>
<h3 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h3><p>从 Java 虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），这个类加载器使用 C++ 来实现，是虚拟机自身的一部分；另一种就是所有其他的类加载器，这些类加载器都由 Java 来实现，独立于虚拟机外部，并且全都继承自抽象类 <code>java.lang.ClassLoader</code>。</p>
<p>从 Java 开发者的角度来看，类加载器可以划分为：</p>
<ul>
<li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：这个类加载器负责将存放在 <java_home>\lib 目录中的类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，那直接使用 null 代替即可；</java_home></li>
<li><strong>扩展类加载器（Extension ClassLoader）</strong>：这个类加载器由 <code>sun.misc.Launcher$ExtClassLoader</code> 实现，它负责加载 <java_home>\lib\ext 目录中，或者被 java.ext.dirs 系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器；</java_home></li>
<li><strong>应用程序类加载器（Application ClassLoader）</strong>：这个类加载器由 <code>sun.misc.Launcher$App-ClassLoader</code> 实现。<code>getSystemClassLoader()</code> 方法返回的就是这个类加载器，因此也被称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库。开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。</li>
</ul>
<p>我们的应用程序都是由这 3 种类加载器互相配合进行加载的，在必要时还可以自己定义类加载器。它们的关系如下图所示：</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/3/双亲委派模型.png" width="55%"></div>

<p>上图中所呈现出的这种层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。双亲委派模型要求除了顶层的启动类加载器以外，其余的类加载器都应当有自己的父类加载器。</p>
<p>双亲委派模型的工作过程是这样的：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个类加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p>
<p>这样做的好处就是 Java 类随着它的类加载器一起具备了一种带有优先级的层次关系。例如 java.lang.Object，它放在 rt.jar 中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器来加载，因此 Object 类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为 java.lang.Object 的类，并放在程序的 ClassPath 中，那系统中将会出现多个不同的 Object 类，Java 类型体系中最基本的行为也就无法保证了。</p>
<p>双亲委派模型对于保证 Java 程序运行的稳定性很重要，但它的实现很简单，实现双亲委派模型的代码都集中在 java.lang.ClassLoader 的 loadClass() 方法中，逻辑很清晰：先检查是否已经被加载过，若没有则调用父类加载器的 loadClass() 方法，若父加载器为空则默认使用启动类加载器作为父加载器。如果父类加载失败，抛出 ClassNotFoundException 异常后，再调用自己的 findClass() 方法进行加载。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</div><div class="line">        <span class="keyword">throws</span> ClassNotFoundException &#123;</div><div class="line">    <span class="comment">// 首先，检查请求的类是不是已经被加载过</span></div><div class="line">    Class&lt;?&gt; c = findLoadedClass(name);</div><div class="line">    <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</div><div class="line">                c = parent.loadClass(name, <span class="keyword">false</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                c = findBootstrapClassOrNull(name);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</div><div class="line">            <span class="comment">// 如果父类抛出 ClassNotFoundException 说明父类加载器无法完成加载</span></div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</div><div class="line">            <span class="comment">// 如果父类加载器无法加载，则调用自己的 findClass 方法来进行类加载</span></div><div class="line">            c = findClass(name);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (resolve) &#123;</div><div class="line">        resolveClass(c);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> c;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关于类文件结构和类加载就通过连续的两篇文章介绍到这里了，下一篇我们来聊聊「虚拟机的字节码执行引擎」。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版）》</li>
</ul>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首发于微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，欢迎关注！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上一篇文章我们介绍了&lt;a href=&quot;https://mp.weixin.qq.com/s/mSqiItrTAhlk0UY-0j5TpA&quot;&gt;「类文件结构」&lt;/a&gt;，这一篇我们来看看虚拟机是如何加载类的。&lt;/p&gt;
&lt;p&gt;我们的源代码经过编译器编译成字节码之后，最终都需要加载到虚拟机之后才能运行。虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的&lt;strong&gt;类加载机制&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;与编译时需要进行连接工作的语言不同，Java 语言中类的加载、连接和初始化都是在程序运行期间完成的，这种策略虽然会让类加载时增加一些性能开销，但是会为 Java 应用程序提供高度的灵活性，Java 里天生可动态扩展的语言特性就是依赖运行期间动态加载和动态连接的特点实现的。&lt;/p&gt;
&lt;p&gt;例如，一个面向接口的应用程序，可以等到运行时再指定实际的实现类；用户可以通过 Java 预定义的和自定义的类加载器，让一个本地的应用程序运行从网络上或其它地方加载一个二进制流作为程序代码的一部分。&lt;/p&gt;
&lt;h2 id=&quot;一-类加载时机&quot;&gt;&lt;a href=&quot;#一-类加载时机&quot; class=&quot;headerlink&quot; title=&quot;一. 类加载时机&quot;&gt;&lt;/a&gt;一. 类加载时机&lt;/h2&gt;&lt;p&gt;类从被虚拟机从加载到卸载，整个生命周期包含：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）、卸载（Unloading）7 个阶段。其中验证、准备、解析 3 个部分统称为连接（Linking）。这 7 个阶段的发生顺序如下图：&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://baronzhang.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://baronzhang.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>系列 | 深入理解Java虚拟机二（类文件结构）</title>
    <link href="http://baronzhang.com//blog/JVM/%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%BA%8C%EF%BC%88%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84%EF%BC%89/"/>
    <id>http://baronzhang.com//blog/JVM/系列-深入理解Java虚拟机二（类文件结构）/</id>
    <published>2019-08-19T16:25:01.000Z</published>
    <updated>2019-08-19T17:00:14.760Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>首发于微信公众号：<strong>BaronTalk</strong>，欢迎关注！</p>
</blockquote>
<p>之前在阅读 ASM 文档时，对于已编译类的结构、方法描述符、访问标志、ACC_PUBLIC、ACC_PRIVATE、各种字节码指令等等许多概念听起来都是云山雾罩、一知半解，原因就在于对类文件结构和类加载机制不够了解。直到后来细读了《深入理解 Java 虚拟机》中虚拟机执行子系统的相关内容，才建立了清晰的认知。如果你也和我一样，不了解类结构和类加载，但是工作中又涉及到字节码相关内容，相信后面两篇文章会对你有所帮助。</p>
<p>我们所编写的每一行代码，要在机器上运行最终都需要编译成二进制的机器码 CPU 才能识别。但是由于虚拟机的存在，屏蔽了操作系统与 CPU 指令集的差异性，类似于 Java 这种建立在虚拟机之上的编程语言通常会编译成一种中间格式的文件来存储，比如我们今天要聊的字节码（ByteCode）文件。</p>
<h2 id="一-语言无关性"><a href="#一-语言无关性" class="headerlink" title="一. 语言无关性"></a>一. 语言无关性</h2><p>Java 虚拟机的设计者在设计之初就考虑并实现了其它语言在 Java 虚拟机上运行的可能性。所以并不是只有 Java 语言能够跑在 Java 虚拟机上，时至今日诸如 Kotlin、Groovy、Jython、JRuby 等一大批 JVM 语言都能够在 Java 虚拟机上运行。它们和 Java 语言一样都会被编译器编译成字节码文件，然后由虚拟机来执行。所以说类文件（字节码文件）具有语言无关性。</p>
<a id="more"></a>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/2/语言无关性.png" width="80%"></div>

<h2 id="二-Class-文件结构"><a href="#二-Class-文件结构" class="headerlink" title="二. Class 文件结构"></a>二. Class 文件结构</h2><p>Class 文件是一组以 8 位字节为基础单位的二进制流，各个数据严格按照顺序紧凑的排列在 Class 文件中，中间无任何分隔符，这使得整个 Class 文件中存储的内容几乎全部都是程序运行的必要数据，没有空隙存在。当遇到需要占用 8 位字节以上空间的数据项时，会按照高位在前的方式分割成若干个 8 位字节进行存储。</p>
<p>Java 虚拟机规范规定 Class 文件格式采用一种类似与 C 语言结构体的微结构体来存储数据，这种伪结构体中只有两种数据类型：无符号数和表。</p>
<ul>
<li><strong>无符号数</strong>属于基本的数据类型，以 u1、u2、u4、u8来分别代表 1 个字节、2 个字节、4 个字节和 8 个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照 UTF-8 编码结构构成的字符串值。</li>
<li><strong>表</strong>是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以「_info」结尾。表用于描述有层次关系的复合结构的数据，整个 Class 文件就是一张表，它由下表中所示的数据项构成。</li>
</ul>
<table>
<thead>
<tr>
<th>类型</th>
<th>名称</th>
<th>数量</th>
</tr>
</thead>
<tbody>
<tr>
<td>u4</td>
<td>magic</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>minor_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>major_version</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>constant_pool_count</td>
<td>1</td>
</tr>
<tr>
<td>cp_info</td>
<td>constant_pool</td>
<td>constant_pool_count-1</td>
</tr>
<tr>
<td>u2</td>
<td>access_flags</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>this_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>super_class</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces_count</td>
<td>1</td>
</tr>
<tr>
<td>u2</td>
<td>interfaces</td>
<td>interfaces_count</td>
</tr>
<tr>
<td>u2</td>
<td>fields_count</td>
<td>1</td>
</tr>
<tr>
<td>field_info</td>
<td>fields</td>
<td>fields_count</td>
</tr>
<tr>
<td>u2</td>
<td>methods_count</td>
<td>1</td>
</tr>
<tr>
<td>method_info</td>
<td>methods</td>
<td>methods_count</td>
</tr>
<tr>
<td>u2</td>
<td>attributes_count</td>
<td>1</td>
</tr>
<tr>
<td>attribute_info</td>
<td>attributes</td>
<td>attributes_count</td>
</tr>
</tbody>
</table>
<p>Class 文件中存储的字节严格按照上表中的顺序紧凑的排列在一起。哪个字节代表什么含义，长度是多少，先后顺序如何都是被严格限制的，不允许有任何改变。</p>
<h3 id="2-1-魔数与-Class-文件版本"><a href="#2-1-魔数与-Class-文件版本" class="headerlink" title="2.1 魔数与 Class 文件版本"></a>2.1 魔数与 Class 文件版本</h3><p>每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接收的 Calss 文件。之所以使用魔数而不是文件后缀名来进行识别主要是基于安全性的考虑，因为文件后缀名是可以随意更改的。Class 文件的魔数值为「0xCAFEBABE」。</p>
<p>紧接着魔数的 4 个字节存储的是 Class 文件的版本号：第 5 和第 6 两个字节是次版本号（Minor Version），第 7 和第 8 个字节是主版本号（Major Version）。高版本的 JDK 能够向下兼容低版本的 Class 文件，虚拟机会拒绝执行超过其版本号的 Class 文件。</p>
<h3 id="2-2-常量池"><a href="#2-2-常量池" class="headerlink" title="2.2 常量池"></a>2.2 常量池</h3><p>主版本号之后是常量池入口，常量池可以理解为 Class 文件之中的资源仓库，它是 Class 文件结构中与其他项目关联最多的数据类型，也是占用 Class 文件空间最大的数据项目之一，同是它还是 Class 文件中第一个出现的表类型数据项目。</p>
<p>因为常量池中常量的数量是不固定的，所以在常量池入口需要放置一个 u2 类型的数据来表示常量池的容量「constant_pool_count」，和计算机科学中计数的方法不一样，这个容量是从 1 开始而不是从 0 开始计数。之所以将第 0 项常量空出来是为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达「不引用任何一个常量池项目」的含义，这种情况可以把索引值置为 0 来表示。</p>
<blockquote>
<p>Class 文件结构中只有常量池的容量计数是从 1 开始的，其它集合类型，包括接口索引集合、字段表集合、方法表集合等容量计数都是从 0 开始。</p>
</blockquote>
<p>常量池中主要存放两大类常量：<strong>字面量</strong>和<strong>符号引用</strong>。</p>
<ul>
<li><strong>字面量</strong>比较接近 Java 语言层面的常量概念，如字符串、声明为 final 的常量值等。</li>
<li><strong>符号引用</strong>属于编译原理方面的概念，包括了以下三类常量：<ul>
<li>类和接口的全限定名</li>
<li>字段的名称和描述符</li>
<li>方法的名称和描述符</li>
</ul>
</li>
</ul>
<h3 id="2-3-访问标志"><a href="#2-3-访问标志" class="headerlink" title="2.3 访问标志"></a>2.3 访问标志</h3><p>紧接着常量池之后的两个字节代表访问标志（access_flag），这个标志用于识别一些类或者接口层次的访问信息，包括这个 Class 是类还是接口；是否定义为 public 类型；是否定义为 abstract 类型；如果是类的话，是否被申明为 final 等。具体的标志位以及标志的含义见下表：</p>
<table class="table table-striped" style="width:100%"><br>  <tr><br>    <th>标志名称</th><br>    <th>标志值</th><br>    <th>含义</th><br>  </tr><br>  <tr><br>    <td>ACC_PUBLIC</td><br>    <td>0x0001</td><br>    <td>是否为 public 类型</td><br>  </tr><br>  <tr><br>    <td>ACC_FINAL</td><br>    <td>0x0010</td><br>    <td>是否被声明为 final，只有类可设置</td><br>  </tr><br>  <tr><br>    <td>ACC_SUPER</td><br>    <td>0x0020</td><br>    <td>是否允许使用 invokespecial 字节码指令的新语意，invokespecial 指令的语意在 JKD 1.0.2 中发生过改变，微聊区别这条指令使用哪种语意，JDK 1.0.2 编译出来的类的这个标志都必须为真</td><br>  </tr><br>  <tr><br>    <td>ACC_INTERFACE</td><br>    <td>0x0200</td><br>    <td>标识这是一个接口</td><br>  </tr><br>  <tr><br>    <td>ACC_ABSTRACT</td><br>    <td>0x0400</td><br>    <td>是否为 abstract 类型，对于接口或者抽象类来说，此标志值为真，其它类值为假</td><br>  </tr><br>  <tr><br>    <td>ACC_SYNTHETIC</td><br>    <td>0x1000</td><br>    <td>标识这个类并非由用户代码产生</td><br>  </tr><br>  <tr><br>    <td>ACC_ANNOTATION</td><br>    <td>0x2000</td><br>    <td>标识这是一个注解</td><br>  </tr><br>  <tr><br>    <td>ACC_ENUM</td><br>    <td>0x4000</td><br>    <td>标识这是一个枚举</td><br>  </tr><br></table>

<p>access_flags 中一共有 16 个标志位可以使用，当前只定义了其中的 8 个，没有使用到的标志位要求一律为 0。</p>
<h3 id="2-4-类索引、父类索引与接口索引集合"><a href="#2-4-类索引、父类索引与接口索引集合" class="headerlink" title="2.4 类索引、父类索引与接口索引集合"></a>2.4 类索引、父类索引与接口索引集合</h3><p>类索引（this_class）和父类索引（super_class）都是一个 u2 类型的数据，而接口索引集合（interfaces）是一组 u2 类型的数据集合，Class 文件中由这三项数据来确定这个类的继承关系。</p>
<ul>
<li>类索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名</li>
<li>接口索引集合用于描述这个类实现了哪些接口</li>
</ul>
<h3 id="2-5-字段表集合"><a href="#2-5-字段表集合" class="headerlink" title="2.5 字段表集合"></a>2.5 字段表集合</h3><p>字段表集合（field_info）用于描述接口或者类中声明的变量。字段（field）包括类变量和实例变量，但不包括方法内部声明的局部变量。下面我们看看字段表的结构：</p>
<table class="table table-striped" style="width:100%"><br>  <tr><br>    <th>类型</th><br>    <th>名称</th><br>    <th>数量</th><br>  </tr><br>  <tr><br>    <td>u2</td><br>    <td>access_flag</td><br>    <td>1</td><br>  </tr><br>  <tr><br>    <td>u2</td><br>    <td>name_index</td><br>    <td>1</td><br>  </tr><br>  <tr><br>    <td>u2</td><br>    <td>descriptor_index</td><br>    <td>1</td><br>  </tr><br>  <tr><br>    <td>u2</td><br>    <td>attributes_count</td><br>    <td>1</td><br>  </tr><br>  <tr><br>    <td>attribute_info</td><br>    <td>attributes</td><br>    <td>attributes_count</td><br>  </tr><br></table>

<p>字段修饰符放在 access_flags 中，它与类中的 access_flag 非常相似，都是一个 u2 的数据类型。</p>
<table class="table table-striped" style="width:100%"><br>   <tr><br>    <th>标志名称</th><br>    <th>标志值</th><br>    <th>含义</th><br>  </tr><br>  <tr><br>    <td>ACC_PUBLIC</td><br>    <td>0x0001</td><br>    <td>字段是否为 public</td><br>  </tr><br>  <tr><br>    <td>ACC_PRIVATE</td><br>    <td>0x0002</td><br>    <td>字段是否为 private</td><br>  </tr><br>  <tr><br>    <td>ACC_PROTECTED</td><br>    <td>0x0004</td><br>    <td>字段是否为 protected</td><br>  </tr><br>  <tr><br>    <td>ACC_STATIC</td><br>    <td>0x0008</td><br>    <td>字段是否为 static</td><br>  </tr><br>  <tr><br>    <td>ACC_FINAL</td><br>    <td>0x0010</td><br>    <td>字段是否为 final</td><br>  </tr><br>  <tr><br>    <td>ACC_VOLATILE</td><br>    <td>0x0040</td><br>    <td>字段是否为 volatile</td><br>  </tr><br>  <tr><br>    <td>ACC_TRANSIENT</td><br>    <td>0x0080</td><br>    <td>字段是否为 transient</td><br>  </tr><br>  <tr><br>    <td>ACC_SYNTHETIC</td><br>    <td>0x1000</td><br>    <td>字段是否由编译器自动生成</td><br>  </tr><br>  <tr><br>    <td>ACC_ENUM</td><br>    <td>0x4000</td><br>    <td>字段是否为 enum</td><br>  </tr><br></table>

<h3 id="2-6-方法表集合"><a href="#2-6-方法表集合" class="headerlink" title="2.6 方法表集合"></a>2.6 方法表集合</h3><p>Class 文件中对方法的描述和对字段的描述是完全一致的，方法表中的结构和字段表的结构一样。</p>
<p>因为 volatile 关键字和 transient 关键字不能修饰方法，所以方法表的访问标志中没有 ACC_VOLATILE 和 ACC_TRANSIENT。与之相对的，synchronizes、native、strictfp 和 abstract 关键字可以修饰方法，所以方法表的访问标志中增加了 ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP 和 ACC_ABSTRACT 标志。</p>
<p>对于方法里的代码，经过编译器编译成字节码指令后，存放在方法属性表中一个名为「Code」的属性里面。</p>
<h3 id="2-7-属性表集合"><a href="#2-7-属性表集合" class="headerlink" title="2.7 属性表集合"></a>2.7 属性表集合</h3><p>在 Class 文件、字段表、方法表中都可以携带自己的属性表（attribute_info）集合，用于描述某些场景专有的信息。</p>
<p>属性表集合不像 Class 文件中的其它数据项要求这么严格，不强制要求各属性表的顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java 虚拟机在运行时会略掉它不认识的属性。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>为了控制篇幅，这篇文章里丢弃了很多细节，比如常量池的项目类型、方法表、属性表的具体内容等等。建议想要深入了解的同学可以自己动手将 Java 类编译成二进制字节码文件，根据文章里介绍的类文件结构逐个字符去对照和实验，有助于加深理解。</p>
<p>关于「类文件结构」我们就介绍到这里，下一篇我们来聊聊「虚拟机的类加载机制」。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版）》</li>
</ul>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首发于微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，欢迎关注！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前在阅读 ASM 文档时，对于已编译类的结构、方法描述符、访问标志、ACC_PUBLIC、ACC_PRIVATE、各种字节码指令等等许多概念听起来都是云山雾罩、一知半解，原因就在于对类文件结构和类加载机制不够了解。直到后来细读了《深入理解 Java 虚拟机》中虚拟机执行子系统的相关内容，才建立了清晰的认知。如果你也和我一样，不了解类结构和类加载，但是工作中又涉及到字节码相关内容，相信后面两篇文章会对你有所帮助。&lt;/p&gt;
&lt;p&gt;我们所编写的每一行代码，要在机器上运行最终都需要编译成二进制的机器码 CPU 才能识别。但是由于虚拟机的存在，屏蔽了操作系统与 CPU 指令集的差异性，类似于 Java 这种建立在虚拟机之上的编程语言通常会编译成一种中间格式的文件来存储，比如我们今天要聊的字节码（ByteCode）文件。&lt;/p&gt;
&lt;h2 id=&quot;一-语言无关性&quot;&gt;&lt;a href=&quot;#一-语言无关性&quot; class=&quot;headerlink&quot; title=&quot;一. 语言无关性&quot;&gt;&lt;/a&gt;一. 语言无关性&lt;/h2&gt;&lt;p&gt;Java 虚拟机的设计者在设计之初就考虑并实现了其它语言在 Java 虚拟机上运行的可能性。所以并不是只有 Java 语言能够跑在 Java 虚拟机上，时至今日诸如 Kotlin、Groovy、Jython、JRuby 等一大批 JVM 语言都能够在 Java 虚拟机上运行。它们和 Java 语言一样都会被编译器编译成字节码文件，然后由虚拟机来执行。所以说类文件（字节码文件）具有语言无关性。&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://baronzhang.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://baronzhang.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>系列 | 深入理解Java虚拟机一（自动内存管理机制）</title>
    <link href="http://baronzhang.com//blog/JVM/%E7%B3%BB%E5%88%97-%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Java%E8%99%9A%E6%8B%9F%E6%9C%BA%E4%B8%80%EF%BC%88%E8%87%AA%E5%8A%A8%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E6%9C%BA%E5%88%B6%EF%BC%89/"/>
    <id>http://baronzhang.com//blog/JVM/系列-深入理解Java虚拟机一（自动内存管理机制）/</id>
    <published>2019-08-19T16:17:35.000Z</published>
    <updated>2019-08-19T17:01:44.761Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>首发于微信公众号：<strong>BaronTalk</strong>，欢迎关注！</p>
</blockquote>
<p>书籍真的是常读常新，古人说「书读百遍其义自见」还是蛮有道理的。周志明老师的这本《深入理解 Java 虚拟机》我细读了不下三遍，每一次阅读都有新的收获，每一次阅读对 Java 虚拟机的理解就更进一步。因而萌生了将读书笔记整理成文的想法，一是想检验下自己的学习成果，对学习内容进行一次系统性的复盘；二是给还没接触过这部好作品的同学推荐下，在阅读这部佳作之前能通过我的文章一窥书中的精华。</p>
<p>原想着一篇文章就够了，但写着写着就发现篇幅大大超出了预期。看来还是功力不够，索性拆成了六篇文章，分别从<strong>自动内存管理机制</strong>、<strong>类文件结构</strong>、<strong>类加载机制</strong>、<strong>字节码执行引擎</strong>、<strong>程序编译与代码优化</strong>、<strong>高效并发</strong>六个方面来做更加细致的介绍。本文先说说 Java 虚拟机的自动内存管理机制。</p>
<h2 id="一-运行时数据区"><a href="#一-运行时数据区" class="headerlink" title="一. 运行时数据区"></a>一. 运行时数据区</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：</p>
<a id="more"></a>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/运行时数据区.png" width="60%"></div>

<h3 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h3><p>程序计数器是一块较小的内存区域，可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。「属于线程私有的内存区域」</p>
<h3 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h3><p>就是我们平时所说的栈，每个方法被执行时，都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作栈、动态链接、方法出口等信息。<strong>每个方法从被调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中从出栈到入栈的过程。</strong>「属于线程私有的内存区域」</p>
<blockquote>
<p><strong>局部变量表</strong>：局部变量表是 Java 虚拟机栈的一部分，存放了编译器可知的基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference 类型，不等同于对象本身，根据不同的虚拟机实现，它可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和 returnAddress 类型（指向了一条字节码指令的地址）。</p>
</blockquote>
<h3 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h3><p>和虚拟机栈类似，只不过虚拟机栈为虚拟机执行的 Java 方法服务，本地方法栈为虚拟机使用的 Native 方法服务。「属于线程私有的内存区域」</p>
<h3 id="Java-堆"><a href="#Java-堆" class="headerlink" title="Java 堆"></a>Java 堆</h3><p>对大多数应用而言，Java 堆是虚拟机所管理的内存中最大的一块，是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一作用就是存放对象实例，几乎所有的对象实例都是在这里分配的（不绝对，在虚拟机的优化策略下，也会存在栈上分配、标量替换的情况，后面的章节会详细介绍）。Java 堆是 GC 回收的主要区域，因此很多时候也被称为 GC 堆。从内存回收的角度看，Java 堆还可以被细分为新生代和老年代；再细一点新生代还可以被划分为 Eden Space、From Survivor Space、To Survivor Space。从内存回收的角度看，线程共享的 Java 堆可能划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer，TLAB）。「属于线程共享的内存区域」</p>
<h3 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h3><p>用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。「属于线程共享的内存区域」</p>
<blockquote>
<p><strong>运行时常量池</strong>: 运行时常量池是方法区的一部分，Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息就是常量池（Constant Pool Table），用于存放在编译期生成的各种字面量和符号引用。</p>
<p><strong>直接内存</strong>：直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。Java 中的 NIO 可以使用 Native 函数直接分配堆外内存，然后通过一个存储在 Java 堆中的 DiectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。直接内存不受 Java 堆大小的限制。</p>
</blockquote>
<h2 id="二-对象的创建、内存布局及访问定位"><a href="#二-对象的创建、内存布局及访问定位" class="headerlink" title="二. 对象的创建、内存布局及访问定位"></a>二. 对象的创建、内存布局及访问定位</h2><p>前面介绍了 Java 虚拟机的运行时数据区，了解了虚拟机内存的情况。接下来我们看看对象是如何创建的、对象的内存布局是怎样的以及对象在内存中是如何定位的。</p>
<h3 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h3><p>要创建一个对象首先得在 Java 堆中（不绝对，后面介绍虚拟机优化策略的时候会做详细介绍）为这个要创建的对象分配内存，分配内存的过程要保证并发安全，最后再对内存进行相应的初始化，这一系列的过程完成后，一个真正的对象就被创建了。</p>
<h4 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h4><p>先说说内存分配，当虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能够在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化。如果没有，那必须先执行相应的类加载过程。在类加载检查通过后，虚拟机将为新生对象分配内存。对象所需的内存大小在类加载完成后便可完全确定，为对象分配内存空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/JVM 创建对象.png" width="45%"></div>

<p>在 Java 堆中划分内存涉及到两个概念：<strong>指针碰撞（Bump the Pointer）</strong>、<strong>空闲列表（Free List）</strong>。</p>
<ul>
<li><p>如果 Java 堆中的内存绝对规整，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配的内存就仅仅是把指针往空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为<strong>「指针碰撞」</strong>。</p>
</li>
<li><p>如果 Java 堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没办法简单的进行指针碰撞了。虚拟机必须维护一个列表来记录哪些内存是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为<strong>「空闲列表」</strong>。</p>
</li>
</ul>
<p>选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。</p>
<p><img src="http://resources.baronzhang.com/blog/jvm/1/内存分配的两种方式.png" alt="JVM 内存分配的两种方式"></p>
<h4 id="保证并发安全"><a href="#保证并发安全" class="headerlink" title="保证并发安全"></a>保证并发安全</h4><p>对象的创建在虚拟机中是一个非常频繁的行为，哪怕只是修改一个指针所指向的位置，在并发情况下也是不安全的，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案：</p>
<ul>
<li><p>对分配内存空间的动作进行同步处理（采用 CAS + 失败重试来保障更新操作的原子性）；</p>
</li>
<li><p>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer, TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB  上分配。只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁。</p>
</li>
</ul>
<p><img src="http://resources.baronzhang.com/blog/jvm/1/内存分配时保证线程安全的两种方式.png" alt="内存分配时保证线程安全的两种方式"></p>
<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>内存分配完后，虚拟机要将分配到的内存空间初始化为零值（不包括对象头），如果使用了 TLAB，这一步会提前到 TLAB 分配时进行。这一步保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用。</p>
<p>接下来设置对象头（Object Header）信息，包括对象是哪个类的实例、如何找到类的元数据、对象的 Hash、对象的 GC 分代年龄等。</p>
<p>这一系列动作完成之后，紧接着会执行 <init> 方法，把对象按照程序员的意图进行初始化，这样一个真正意义上的对象就产生了。</init></p>
<p>JVM 中对象的创建过程大致如下图：</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/对象创建的完整过程.png" width="70%"></div>

<h3 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h3><p>在 HotSpot 虚拟机中，对象在内存中的布局可以分为 3 块：<strong>对象头（Header）</strong>、<strong>实例数据（Instance Data）</strong>和<strong>对齐填充（Padding）</strong>。</p>
<h4 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h4><p>对象头包含两部分信息，第一部分用于存储对象自身的运行时数据，比如哈希码（HashCode）、GC 分代年龄、锁状态标志、线程持有的锁、偏向线程 ID、偏向时间戳等，这部分数据称之为 Mark Word。对象头的另一部分是类型指针，即对象指向它的类元数据指针，虚拟机通过它来确定对象是哪个类的实例；如果是数组，对象头中还必须有一块用于记录数组长度的数据。（并不是所有所有虚拟机的实现都必须在对象数据上保留类型指针，在下一小节介绍「对象的访问定位」的时候再做详细说明）。</p>
<h4 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h4><p>对象真正存储的有效数据，也是在程序代码中所定义的各种字段内容。</p>
<h4 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h4><p>无特殊含义，不是必须存在的，仅作为占位符。</p>
<h3 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h3><p>Java 程序需要通过栈上的 reference 信息来操作堆上的具体对象。根据不同的虚拟机实现，主流的访问对象的方式主要有<strong>句柄访问</strong>和<strong>直接指针</strong>两种。</p>
<h4 id="句柄访问"><a href="#句柄访问" class="headerlink" title="句柄访问"></a>句柄访问</h4><p>Java 堆中划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/对象访问定位-句柄.png" width="75%"></div>

<p>使用句柄访问的好处就是 reference 中存储的是稳定的句柄地址，在对象被移动时只需要改变句柄中实例数据的指针，而 reference 本身不需要修改。</p>
<h4 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h4><p>在对象头中存储类型数据相关信息，reference 中存储的对象地址。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/对象访问定位-直接指针.png" width="75%"></div>

<p>使用直接指针访问的好处是速度更快，它节省了一次指针定位的开销。由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项非常可观的执行成本。HotSpot 中采用的就是这种方式。</p>
<h2 id="三-垃圾回收器与内存分配策略"><a href="#三-垃圾回收器与内存分配策略" class="headerlink" title="三. 垃圾回收器与内存分配策略"></a>三. 垃圾回收器与内存分配策略</h2><p>在前面我们介绍 JVM 运行时数据区的时候说过，程序计数器、虚拟机栈、本地方法栈 3 个区域随线程而生，随线程而死；栈中的栈帧随着方法的进入和退出而有条不紊的执行着入栈和出栈的操作。每一个栈帧中分配多少内存基本上在数据结构确定下来的时候就已经知道了，因此这几个区域内存的分配和回收是具有确定性的，所以不用过度考虑内存回收的问题，因为在方法结束或者线程结束时，内存就跟着回收了。</p>
<p>而 Java 堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序运行期才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器要关注的就是这部分内存。</p>
<h3 id="3-1-对象回收的判定规则"><a href="#3-1-对象回收的判定规则" class="headerlink" title="3.1 对象回收的判定规则"></a>3.1 对象回收的判定规则</h3><p>垃圾收集器在做垃圾回收的时候，首先需要判定的就是哪些内存是需要被回收的，哪些对象是「存活」的，是不可以被回收的；哪些对象已经「死掉」了，需要被回收。</p>
<h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>判断对象存活与否的一种方式是「引用计数」，即对象被引用一次，计数器就加 1，如果计数器为 0 则判断这个对象可以被回收。但是引用计数法有一个很致命的缺陷就是它无法解决循环依赖的问题，因此现在主流的虚拟机基本不会采用这种方式。</p>
<h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>可达性分析算法又叫根搜索算法，该算法的基本思想就是通过一系列称为「GC Roots」的对象作为起始点，从这些起始点开始往下搜索，搜索所走过的路径称为引用链，当一个对象到 GC Roots 对象之间没有任何引用链的时候（不可达），证明该对象是不可用的，于是就会被判定为可回收对象。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/可达性分析.png" width="65%"></div>

<p>在 Java 中可作为 GC Roots 的对象包含以下几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象；</li>
<li>方法区中类静态属性引用的对象；</li>
<li>方法区中常量引用的对象；</li>
<li>本地方法栈中 JNI（Native 方法）引用的对象。</li>
</ul>
<h4 id="Java-中是四种引用类型"><a href="#Java-中是四种引用类型" class="headerlink" title="Java 中是四种引用类型"></a>Java 中是四种引用类型</h4><p>无论是通过引用计数器还是通过可达性分析来判断对象是否可以被回收都设计到「引用」的概念。在 Java 中，根据引用关系的强弱不一样，将引用类型划为强引用（Strong Reference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）。</p>
<p><strong>强引用</strong>：<code>Object obj = new Object()</code>这种方式就是强引用，只要这种强引用存在，垃圾收集器就永远不会回收被引用的对象。</p>
<p><strong>软引用</strong>：用来描述一些有用但非必须的对象。在 OOM 之前垃圾收集器会把这些被软引用的对象列入回收范围进行二次回收。如果本次回收之后还是内存不足才会触发 OOM。在 Java 中使用 SoftReference 类来实现软引用。</p>
<p><strong>弱引用</strong>：同软引用一样也是用来描述非必须对象的，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在 Java 中使用 WeakReference 类来实现。 </p>
<p><strong>虚引用</strong>：是最弱的一种引用关系，一个对象是否有虚引用的存在完全不影响对象的生存时间，也无法通过虚引用来获取一个对象的实例。一个对象使用虚引用的唯一目的是为了在被垃圾收集器回收时收到一个系统通知。在 Java 中使用 PhantomReference 类来实现。</p>
<h4 id="生存还是死亡，这是一个问题"><a href="#生存还是死亡，这是一个问题" class="headerlink" title="生存还是死亡，这是一个问题"></a>生存还是死亡，这是一个问题</h4><p>在可达性分析中判定为不可达的对象，也不一定就是「非死不可的」。这时它们处于「缓刑」阶段，真正要宣告一个对象死亡，至少需要经历两次标记过程：</p>
<p>第一次标记：如果对象在进行可达性分析后被判定为不可达对象，那么它将被第一次标记并且进行一次筛选。筛选的条件是此对象是否有必要执行 finalize() 方法。对象没有覆盖 finalize() 方法或者该对象的 finalize() 方法曾经被虚拟机调用过，则判定为没必要执行。</p>
<p>第二次标记：如果被判定为有必要执行 finalize() 方法，那么这个对象会被放置到一个 F-Queue 队列中，并在稍后由虚拟机自动创建的、低优先级的 Finalizer 线程去执行该对象的 finalize() 方法。但是虚拟机并不承诺会等待该方法结束，这样做是因为，如果一个对象的 finalize() 方法比较耗时或者发生了死循环，就可能导致 F-Queue 队列中的其他对象永远处于等待状态，甚至导致整个内存回收系统崩溃。finalize() 方法是对象逃脱死亡命运的最后一次机会，如果对象要在 finalize() 中挽救自己，只要重新与 GC Roots 引用链关联上就可以了。这样在第二次标记时它将被移除「即将回收」的集合，如果对象在这个时候还没有逃脱，那么它基本上就真的被回收了。</p>
<h4 id="方法区回收"><a href="#方法区回收" class="headerlink" title="方法区回收"></a>方法区回收</h4><p>前面介绍过，方法区在 HotSpot 虚拟机中被划分为永久代。在 Java 虚拟机规范中没有要求方法区实现垃圾收集，而且方法区垃圾收集的性价比也很低。</p>
<p>方法区（永久代）的垃圾收集主要回收两部分内容：废弃常量和无用的类。</p>
<p>废弃常量的回收和 Java 堆中对象的回收非常类似，这里就不做过多的解释了。</p>
<p>类的回收条件就比较苛刻了。要判定一个类是否可以被回收，要满足以下三个条件：</p>
<ol>
<li>该类的所有实例已经被回收；</li>
<li>加载该类的 ClassLoader 已经被回收；</li>
<li>该类的 Class 对象没有被引用，无法再任何地方通过反射访问该类的方法。</li>
</ol>
<h3 id="3-2-垃圾回收算法"><a href="#3-2-垃圾回收算法" class="headerlink" title="3.2 垃圾回收算法"></a>3.2 垃圾回收算法</h3><h4 id="标记-清除算法"><a href="#标记-清除算法" class="headerlink" title="标记-清除算法"></a>标记-清除算法</h4><p>正如标记-清除的算法名一样，该算法分为「标记」和「清除」两个阶段：</p>
<p>首先标记出所有需要回收的对象，在标记完成后回收所有被标记的对象。标记-清除算法是一种最基础的算法，后续其它算法都是在它的基础上基于不足之处改进而来的。它的不足体现在两方面：一是效率问题，标记和清除的效率都不高；二是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后程序的运行过程中又要分配较大对象是，无法找打足够的连续内存而不得不提前出发下一次 GC。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/标记-清除算法.png" width="60%"></div>

<h4 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h4><p>为了解决效率问题，于是就有了复制算法，它将内存一分为二划分为大小相等的两块内存区域。每次只使用其中的一块。当这一块用完时，就将还存活的对象复制到另一块上面，然后再把已使用过的内存空间一次清理掉。这样做的好处是不用考虑内存碎片问题了，简单高效。只不过这种算法代价也很高，内存因此缩小了一半。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/复制算法.png" width="60%"></div>

<p>现在的商业虚拟机都采用这种算法来回收新生代，在 IBM 的研究中新生代中的对象 98% 都是「朝生夕死」，所以并不需要按照 1:1 的比例来划分空间，而是将内存分为一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。当回收时，将 Eden 和 Survivor 中还存活的对象一次性复制到另一块 Survivor 空间上，最后清理掉 Eden 和刚才用过的 Survivor 空间。 HotSpot 默认 Eden 和 Survivor 的大小比例是 8:1，也就是每次新生代中可用的内存为整个新生代容量的 90%（80%+10%），只有 10% 会被浪费。当然，98% 的对象可回收只是一般场景下的数据，我们没办法保证每次回收后都只有不多于 10% 的对象存活，当 Survivor 空间不够用时，需要依赖其它内存（这里指老年代）进行分配担保。如果另外一块 Survivor 空间没有足够空间存放上一次新生代收集下来存活的对象时，这些对象将直接通过分配担保机制进入老年代。</p>
<h4 id="标记-整理算法"><a href="#标记-整理算法" class="headerlink" title="标记-整理算法"></a>标记-整理算法</h4><p>通过前面对复制-收集算法的介绍我们知道，其对老年代这种对象存活时间长的内存区域就不适用了，而标记整理的算法就比较适用这一场景。</p>
<p>标记-整理算法的标记过程与「标记-清除」算法一样，但是后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>
<div align="center"><img src="http://resources.baronzhang.com/blog/jvm/1/标记-整理算法.png" width="60%"></div>

<h4 id="分代回收算法"><a href="#分代回收算法" class="headerlink" title="分代回收算法"></a>分代回收算法</h4><p>当前商业虚拟机的垃圾搜集都采用「分代回收」算法，这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是将 Java 堆分为新生代和老年代，这样可以根据各个年代的特点采用最合适的搜集算法。</p>
<p>在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。</p>
<p>而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用「标记-清除」或者「标记-整理」算法来进行回收。</p>
<h3 id="3-3-内存分配与回收策略"><a href="#3-3-内存分配与回收策略" class="headerlink" title="3.3 内存分配与回收策略"></a>3.3 内存分配与回收策略</h3><p>所谓自动内存管理，最终要解决的也就是内存分配和内存回收两个问题。前面我们介绍了内存回收，这里我们再来聊聊内存分配。</p>
<p>对象的内存分配通常是在 Java 堆上分配（随着虚拟机优化技术的诞生，某些场景下也会在栈上分配，后面会详细介绍），对象主要分配在新生代的 Eden 区，如果启动了本地线程缓冲，将按照线程优先在 TLAB 上分配。少数情况下也会直接在老年代上分配。总的来说分配规则不是百分百固定的，其细节取决于哪一种垃圾收集器组合以及虚拟机相关参数有关，但是虚拟机对于内存的分配还是会遵循以下几种「普世」规则：</p>
<h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><p>多数情况，对象都在新生代 Eden 区分配。当 Eden 区分配没有足够的空间进行分配时，虚拟机将会发起一次 Minor GC。如果本次 GC 后还是没有足够的空间，则将启用分配担保机制在老年代中分配内存。</p>
<p>这里我们提到 Minor GC，如果你仔细观察过 GC 日常，通常我们还能从日志中发现 Major GC/Full GC。</p>
<ul>
<li><p><strong>Minor GC</strong> 是指发生在新生代的 GC，因为 Java 对象大多都是朝生夕死，所有 Minor GC 非常频繁，一般回收速度也非常快；</p>
</li>
<li><p><strong>Major GC/Full GC</strong> 是指发生在老年代的 GC，出现了 Major GC 通常会伴随至少一次 Minor GC。Major GC 的速度通常会比 Minor GC 慢 10 倍以上。</p>
</li>
</ul>
<h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>所谓大对象是指需要大量连续内存空间的对象，频繁出现大对象是致命的，会导致在内存还有不少空间的情况下提前触发 GC 以获取足够的连续空间来安置新对象。</p>
<p>前面我们介绍过新生代使用的是标记-清除算法来处理垃圾回收的，如果大对象直接在新生代分配就会导致 Eden 区和两个 Survivor 区之间发生大量的内存复制。因此对于大对象都会直接在老年代进行分配。</p>
<h4 id="长期存活对象将进入老年代"><a href="#长期存活对象将进入老年代" class="headerlink" title="长期存活对象将进入老年代"></a>长期存活对象将进入老年代</h4><p>虚拟机采用分代收集的思想来管理内存，那么内存回收时就必须判断哪些对象应该放在新生代，哪些对象应该放在老年代。因此虚拟机给每个对象定义了一个对象年龄的计数器，如果对象在 Eden 区出生，并且能够被 Survivor 容纳，将被移动到 Survivor 空间中，这时设置对象年龄为 1。对象在 Survivor 区中每「熬过」一次 Minor GC 年龄就加 1，当年龄达到一定程度（默认 15） 就会被晋升到老年代。</p>
<h4 id="动态对象年龄判断"><a href="#动态对象年龄判断" class="headerlink" title="动态对象年龄判断"></a>动态对象年龄判断</h4><p>为了更好的适应不同程序的内存情况，虚拟机并不是永远要求对象的年龄必需达到某个固定的值（比如前面说的 15）才会被晋升到老年代，而是会去动态的判断对象年龄。如果在 Survivor 区中相同年龄所有对象大小的总和大于 Survivor 空间的一半，年龄大于等于该年龄的对象就可以直接进入老年代。</p>
<h4 id="空间分配担保"><a href="#空间分配担保" class="headerlink" title="空间分配担保"></a>空间分配担保</h4><p>在新生代触发 Minor GC 后，如果 Survivor 中任然有大量的对象存活就需要老年队来进行分配担保，让 Survivor 区中无法容纳的对象直接进入到老年代。</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>对于我们 Java 程序员来说，虚拟机的自动内存管理机制为我们在编码过程中带来了极大的便利，不用像 C/C++ 等语言的开发者一样小心翼翼的去管理每一个对象的生命周期。但同时我们也丧失了内存控制的管理权限，一旦发生内存泄漏如果不了解虚拟机的内存管理原理，就很难排查问题。希望这篇文章能对大家理解 Java 虚拟机的内存管理机制有所帮助。如果想对 Java 虚拟机有更进一步的了解，推荐大家去读周志明老师的《深入理解 Java 虚拟机：JVM 高级特性与最佳实践》这本书。</p>
<p>好了，关于 Java 虚拟机的自动内存管理机制就介绍到这里，下一篇我们来聊聊「类文件结构」。</p>
<p><strong>参考资料：</strong></p>
<ul>
<li>《深入理解 Java 虚拟机：JVM 高级特性与最佳实践（第 2 版）》</li>
</ul>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;首发于微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，欢迎关注！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;书籍真的是常读常新，古人说「书读百遍其义自见」还是蛮有道理的。周志明老师的这本《深入理解 Java 虚拟机》我细读了不下三遍，每一次阅读都有新的收获，每一次阅读对 Java 虚拟机的理解就更进一步。因而萌生了将读书笔记整理成文的想法，一是想检验下自己的学习成果，对学习内容进行一次系统性的复盘；二是给还没接触过这部好作品的同学推荐下，在阅读这部佳作之前能通过我的文章一窥书中的精华。&lt;/p&gt;
&lt;p&gt;原想着一篇文章就够了，但写着写着就发现篇幅大大超出了预期。看来还是功力不够，索性拆成了六篇文章，分别从&lt;strong&gt;自动内存管理机制&lt;/strong&gt;、&lt;strong&gt;类文件结构&lt;/strong&gt;、&lt;strong&gt;类加载机制&lt;/strong&gt;、&lt;strong&gt;字节码执行引擎&lt;/strong&gt;、&lt;strong&gt;程序编译与代码优化&lt;/strong&gt;、&lt;strong&gt;高效并发&lt;/strong&gt;六个方面来做更加细致的介绍。本文先说说 Java 虚拟机的自动内存管理机制。&lt;/p&gt;
&lt;h2 id=&quot;一-运行时数据区&quot;&gt;&lt;a href=&quot;#一-运行时数据区&quot; class=&quot;headerlink&quot; title=&quot;一. 运行时数据区&quot;&gt;&lt;/a&gt;一. 运行时数据区&lt;/h2&gt;&lt;p&gt;Java 虚拟机在执行 Java 程序的过程中会把它所管理的内存区域划分为若干个不同的数据区域。这些区域都有各自的用途，以及创建和销毁的时间，有些区域随着虚拟机进程的启动而存在，有些区域则是依赖线程的启动和结束而建立和销毁。Java 虚拟机所管理的内存被划分为如下几个区域：&lt;/p&gt;
    
    </summary>
    
      <category term="JVM" scheme="http://baronzhang.com/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://baronzhang.com/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Android 性能监控系列一（原理篇）</title>
    <link href="http://baronzhang.com//blog/APM/Android-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"/>
    <id>http://baronzhang.com//blog/APM/Android-性能监控系列一（原理篇）/</id>
    <published>2018-06-06T02:52:00.000Z</published>
    <updated>2019-08-19T11:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/blog/framework/android/apm/apm1/header.jpg" alt="题图来自 https://unsplash.com"></p>
<blockquote>
<p>欢迎关注微信公众号：<strong>BaronTalk</strong>，获取更多精彩好文！</p>
</blockquote>
<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>性能问题是导致 App 用户流失的罪魁祸首之一，如果用户在使用我们 App 的时候遇到诸如页面卡顿、响应速度慢、发热严重、流量电量消耗大等问题的时候，很可能就会卸载掉我们的 App。而往往获取用户的成本是高昂的，因此因为性能问题导致用户流失的情况是我们要极力避免的，做不好这一点是我们开发人员的失职。</p>
<a id="more"></a>
<p>去年我们团队完成了整个项目架构方面的重构（有兴趣的同学可以参考我之前的文章<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483731&amp;idx=1&amp;sn=76bd5612ba723171b6ebac69aaf039f8&amp;chksm=fddca7d2caab2ec4eec8736cf4005615c401984e2218a0cfc71dddfe3a204495c4e8a7312b4a&amp;scene=38#wechat_redirect" target="_blank" rel="external">安居客 Android 项目架构演进 </a>与<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483732&amp;idx=1&amp;sn=b7ee1151b2c8ad2e997b8db39adf3267&amp;chksm=fddca7d5caab2ec33905cc3350f31c0c98794774b0d04a01845565e3989b1f20205c7f432cb9&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android 模块化探索与实践 </a> ），目前已经能够很好的支撑我们的业务，并对团队的开发效率也有了一定的提升、项目质量也有了大幅的进步。</p>
<p>但是项目上线后，到底有没有性能问题？用户体验到底怎么样？在用户的使用场景中到底会遇到哪些性能问题？我们项目的性能短板又在哪里？这些问题的答案我们都不得而知，因此开发一套完善的性能监控体系势在必行。我们团队在今年开始着手开发自己的性能监控组件 APM，希望通过它来采集线上性能数据，找到性能短板，针对性的优化用户体验。</p>
<blockquote>
<p>APM 全称 Application Performance Management &amp; Monitoring (应用性能管理/监控)  </p>
</blockquote>
<p>后面我会通过一系列的文章来介绍 APM 的原理、框架设计与实现等等。本篇就是这个系列的第一篇，主要从实现原理方面来介绍 APM。按照目前的计划，这个系列大致会从如下几个方面来展开：</p>
<ul>
<li><strong>原理篇</strong>：主要介绍 APM 的实现原理；</li>
<li><strong>设计篇</strong>：介绍整个 APM 框架设计；</li>
<li><strong>实现篇-Gradle Plugin</strong>：介绍 Gradle 插件在 APM 项目中的应用，以及如何开发一个 Gradle Plugin；</li>
<li><strong>实现篇-Javassist/ASM</strong>：Javassist、ASM 等字节码操作库的介绍，以及如何使用它们在编译时插入代码来采集各项性能数据；</li>
<li><strong>实现篇-数据存储及上报</strong>：介绍 APM 框架的存储上报机制及实现过程；</li>
<li><strong>发布集成</strong>：最后会介绍如何将库发布到 jCenter() 以及如何在生产项目中集成。</li>
</ul>
<p>这里要向大家交代一点是，之前的文章为了极力做到将复杂的问题用通俗易懂的方式解释清楚，又要面面俱到，往往篇幅过长；诸如之前写过的<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483727&amp;idx=3&amp;sn=f3d0ccfee85c26d8e49cfd22fbccb7f6&amp;chksm=fddca7cecaab2ed8be6e34288bcec23a34289f09fd22e5a06ecc547020a3474978b73366d94b&amp;scene=38#wechat_redirect" target="_blank" rel="external">RxJava系列6(从微观角度解读RxJava源码) </a>、<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483730&amp;idx=1&amp;sn=d308f7073182f8c48dd41e17f2fb7682&amp;chksm=fddca7d3caab2ec5c77884a3f8414d2668cd40627c9b3674dcbd3774deb31400ff34d5e6d11a&amp;scene=38#wechat_redirect" target="_blank" rel="external">神兵利器Dagger2 </a> 、<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483731&amp;idx=1&amp;sn=76bd5612ba723171b6ebac69aaf039f8&amp;chksm=fddca7d2caab2ec4eec8736cf4005615c401984e2218a0cfc71dddfe3a204495c4e8a7312b4a&amp;scene=38#wechat_redirect" target="_blank" rel="external">安居客 Android 项目架构演进 </a>、<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483732&amp;idx=1&amp;sn=b7ee1151b2c8ad2e997b8db39adf3267&amp;chksm=fddca7d5caab2ec33905cc3350f31c0c98794774b0d04a01845565e3989b1f20205c7f432cb9&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android 模块化探索与实践 </a> 、<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483735&amp;idx=1&amp;sn=202bcc94cc581d91e77728afe674fdfe&amp;chksm=fddca7d6caab2ec0c1a08e25dc1acf5aaf257365f64d5c50c37aae4ead919fdbc11062575f9f&amp;scene=38#wechat_redirect" target="_blank" rel="external">写给 Android 应用工程师的 Binder 原理剖析</a>等文章，篇幅通常都在 8000~10000字以上，通篇阅读下来可能需要近半个小时的时间，不太符合当下碎片化阅读的需求；因此在后面的写作上会控制篇幅，尽量控制在 10 分钟以内的长度。</p>
<p>这也是我为什么会将 APM 作为一个系列来介绍的原因，同时这也能保证后面在介绍 APM 的时候能够深入到实现细节，避免泛泛而谈。</p>
<h2 id="二-Android-APM-的基本原理"><a href="#二-Android-APM-的基本原理" class="headerlink" title="二. Android APM 的基本原理"></a>二. Android APM 的基本原理</h2><p>市场上有很多商业化的 APM 平台，比如著名的 NewRelic，还有国内的 听云、OneAPM 等等。这些平台的工作流程基本都是一致的：</p>
<ol>
<li>首先在客户端（Android、iOS、Web等）采集数据；</li>
<li>接着将采集到的数据整理上报到服务器；</li>
<li>服务器接收到数据后建模、存储、挖掘分析，让后将数据可视化，供用户使用。</li>
</ol>
<p>如下图：<br><img src="http://resources.baronzhang.com/blog/framework/android/apm/apm.png" alt="APM 工作流程"></p>
<p>我们介绍的 Android APM 框架其实就是在 Android 平台上应用的一个数据采集上报 SDK。主要包含三大模块：</p>
<ol>
<li>数据采集</li>
<li>数据存储</li>
<li>数据上报</li>
</ol>
<p>其中数据采集是整个 APM 框架的核心。</p>
<p>数据采集我们可以通过手动埋点的方式，但这种方式工作量巨大、不灵活，而且无法覆盖到所有场景；因此只能通过自动化的方式来采集数据。在应用构建期间，通过修改字节码的方式来进行字节码插桩就是实现自动化的方案之一。</p>
<h2 id="三-Android-打包流程及字节码插桩原理"><a href="#三-Android-打包流程及字节码插桩原理" class="headerlink" title="三. Android 打包流程及字节码插桩原理"></a>三. Android 打包流程及字节码插桩原理</h2><p>在谈字节码插桩的原理之前，首先我们看看 Android 的打包流程，如下图：<br><img src="http://resources.baronzhang.com/blog/framework/android/apm/apk-build.png" alt="Android 打包流程"></p>
<p>从上面这张打包流程图我们可以看到，一个 App 的所有 class 文件，包括第三方的 class 文件都会经过 dex 的过程打包成一个或者多个 dex 文件。</p>
<p>这其中涉及到两个很关键的环节：</p>
<ol>
<li><strong>javac</strong>：将 .java 格式的源代码文件编译成 class 文件；</li>
<li><strong>dex</strong>: 将 class 格式的文件打包汇总，组成一个或者多个 dex 文件。</li>
</ol>
<p>我们想要对字节码进行修改，只需要在 javac 之后 dex 之前遍历所有的字节码文件，并按照一定的规则过滤修改就好了，这里便是字节码插桩的入口。</p>
<p>那么我们到底如何介入打包过程，在 class 转换为 dex 文件的时候实现对字节码的修改呢？</p>
<p>答案是 <strong>transform api</strong></p>
<p>Android Gradle Plugin 1.5.0 及以上版本，Google 官方提供了 transform api 作为字节码插桩的入口。我们只需要实现一个自定义的 Gradle Plugin，然后在编译阶段去修改字节码文件。对于 Gradle Plugin 的具体实现后面的文章再做详细讲解。</p>
<h2 id="四-修改字节码"><a href="#四-修改字节码" class="headerlink" title="四. 修改字节码"></a>四. 修改字节码</h2><p>找到了插桩入口，接下来就要对字节码进行修改。对于字节码的修改，比较常用的框架有 Javassist 和 ASM。</p>
<ol>
<li><p><strong>Javassist</strong> 是一个开源的分析、编辑和创建 Java 字节码的类库,它提供了源码级别的 API 以及字节码级别的 API，源码级别的 API，直接使用 Java 编码的形式，而不需要深入了解虚拟机指令，就能动态改变类的结构或者动态生成类。</p>
</li>
<li><p><strong>ASM</strong> 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。</p>
</li>
</ol>
<p>ASM 和 Javassit 相比，API 贴近底层，比较难使用，需要对 Java 字节码和虚拟机方面有一定程度的了解。ASM 的优点就在于性能上的优势，且更加灵活；Javassist 的实现中大量使用的反射，所以性能偏低。</p>
<p>简单的说就是 ASM 虽然难以使用，但是功能强大效率高。是很多无痕埋点、APM框架的首选方案。</p>
<p>ASM 的具体时候我们放到这个系列后面的文章介绍。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>Android APM 的原理其实非常简单，用一句话总结就是：</p>
<p>依据打包原理，在 class 转换为 dex 的过程中，调用 gradle transform api 遍历 class 文件，借助 Javassist、ASM 等框架修改字节码，插入我们自己的代码实现性能数据的统计。</p>
<p>以上所有过程都是在编译期完成的。</p>
<p>其实 Android 上的无痕埋点也是同样的原理，区别只不过是我们 hook 的点不同，采集的数据不同，因此掌握了 APM 的实现原理同样可以实现无痕埋点系统。</p>
<p>原理很简单，难的是实现细节。比如如何插桩采集到页面帧率、流量、耗电量等等。这些具体细节我们放到后面一一介绍。至于为什么放到后面……因为很多东西自己没做过我也不知道啊……🤣</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/blog/framework/android/apm/apm1/header.jpg&quot; alt=&quot;题图来自 https://unsplash.com&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;欢迎关注微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，获取更多精彩好文！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h2&gt;&lt;p&gt;性能问题是导致 App 用户流失的罪魁祸首之一，如果用户在使用我们 App 的时候遇到诸如页面卡顿、响应速度慢、发热严重、流量电量消耗大等问题的时候，很可能就会卸载掉我们的 App。而往往获取用户的成本是高昂的，因此因为性能问题导致用户流失的情况是我们要极力避免的，做不好这一点是我们开发人员的失职。&lt;/p&gt;
    
    </summary>
    
      <category term="APM" scheme="http://baronzhang.com/categories/APM/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="APM" scheme="http://baronzhang.com/tags/APM/"/>
    
      <category term="性能" scheme="http://baronzhang.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>我们和优秀工程师的差距在哪儿</title>
    <link href="http://baronzhang.com//blog/Other/%E6%88%91%E4%BB%AC%E5%92%8C%E4%BC%98%E7%A7%80%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%B7%AE%E8%B7%9D%E5%9C%A8%E5%93%AA%E5%84%BF/"/>
    <id>http://baronzhang.com//blog/Other/我们和优秀工程师的差距在哪儿/</id>
    <published>2018-04-25T06:51:59.000Z</published>
    <updated>2019-08-19T12:56:35.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/blog/other/engineer/pic1.jpg" alt=""></p>
<blockquote>
<p>关注微信公众号：<strong>BaronTalk</strong>，获取更多精彩好文。</p>
</blockquote>
<p>我相信每个工程师都曾怀揣一个成为技术大牛的梦想，可是真正走向技术大牛这条路的少之又少。工作中我们常常会发现，有些同学工作没几年但成长迅速；很快就能走向团队核心岗位，成为一名优秀的工程师；而有些同学工作几年后却在公司里默默无闻，能力和职位上都没有太大提升，得过且过最终沦为一名普普通通的码农。所以我常常会有感慨，太多人（包括我自己）真的只不过是用一两年的经验在职场上混了五年十年甚至更久。</p>
<p>那么普通工程师和优秀工程师到底差距在哪儿？那些优秀工程师是怎么一步一步成长起来了的呢？以下就我自己的观察和思考来谈一谈，看看能不能一探究竟，了解通向优秀工程师的法门；然后与大家共勉，一起朝着优秀工程师的方向去努力。</p>
<a id="more"></a>
<h2 id="差距在哪儿？"><a href="#差距在哪儿？" class="headerlink" title="差距在哪儿？"></a>差距在哪儿？</h2><p>我们拿吴军老师在得到专栏中讲解的一道 Google 面试题来展开聊一聊，看看面对同样的问题，普通工程师和优秀工程师是如何思考解决问题的。</p>
<p><strong>问题如下：如何设计一个地图功能，找到离当前最近的加油站？</strong></p>
<p>在最近公司的招聘面试过程中，我也拿类似的问题去问过部分候选人，大部分候选人都把问题想的太简单。通常普通工程师给出的解决方案是：根据经纬度算出所有加油站到当前位置的距离，然后对这些加油站按照距离的远近进行排序，选择距离最近的几个加油站。</p>
<p>可问题是，在路面上行驶，从 A 点通往 B 点，往往不是直线距离。因为无论是驾车还是步行，我们都不可能穿过建筑直达目的地，A 点到 B 点的距离是很多距离片段的组合，这可能会有上千种组合，那么如何从这上千种组合的路线中选择距离最近的一条路线呢？使用动态规划算法能够很好的解决这个问题，在上千种组合中只需几十个步骤就能计算出最短路线。这对部分工程师已经是个门槛了。</p>
<p>接下来就需要按照距离排序，找到最近的几个加油站。</p>
<p>绝大部分工程师面对这样的问题都会想到排序，排序当然能够解决问题，但并不是最优方案。就算使用效率最高的快速排序，也需要 N 乘 LogN 的计算量。假设城市里有 1000 个加油站，那么 LogN 约等于 10，也就是说计算的复杂度差不多是 1000，当然 1000 的计算量对于计算机算不上什么，但是考虑到一个城市的路面上可能有上百万辆行驶的汽车，这个计算量的消耗就很可观了。</p>
<p>假设我们只需要最近的 5 个加油站，如果对所有的加油站排序那显然做了很多无用功。数据结构中有一种叫二叉树的数据结构，在二叉树中有一种更细的分类：“堆”，通过堆排序我们可以只用排出前几名，而不用管后面的名次。通过堆排序排出第一名的时间复杂度是N，排出第二名、第三名、第四名、第五名的时间复杂度都 LogN，比对 1000 个加油站排序要快的多。对于我们的需求：选出最近的 5 个加油站，差不多只需要 1000 的计算量，比快速排序快了近 10 倍。</p>
<p>到这里你是不是觉得问题已经解决的很完美了？</p>
<p>我们在解决问题的时候不由自主的做了一个假设，就是整个算法的优化过程是围绕一个使用者的某一次使用来进行的。但是在现实生活中，一个城市里有很多人会同时在不同的地方寻找加油站。类似的，同一个人在不同的时间不同的地点开车时也需要寻找加油站。考虑到这个现实场景，时时刻刻都有很多人在不停的寻找附近的加油站，那么很多计算其实是可以预先算好的，等到提供服务的时候直接把结果调出来就好了，避免重复计算。</p>
<p>比如我们可以把上海市所有路口点到点的距离事先计算好，当一个人要找加油站的时候，距离的计算就不再需要实时地采用动态规划来计算了，只需要计算从当前位置出发到附近几个路口的距离，再计算下某个加油站到它所在地附近路口的距离，由于各个路口点到点的距离是事先计算好的，因此做几次简单的加法即可，这样计算距离的时间就能省几十倍。这就是对上面的问题进行了全局优化的好处。</p>
<p>其实面对这样的问题，优秀的工程师并不会遇到问题就直接着手去解决，而是会更全面的去考虑问题。比如会考虑到目前的行车方向，比如在解决问题中其实距离要求并不需要太精准，因为对于开车的人来说 2.5 公里和 2.3 公里其实并没有什么差别，再考虑到道路拥堵的情况，200 米的距离更加可以忽略不计了。但如果是行人要寻找附近的便利店，200 米的距离就不得不考虑了。</p>
<p>那么从上述这个问题的解决上我们能看出普通工程师和优秀工程师的差距在哪儿呢？</p>
<p><strong>1. 优秀的工程师必然有着扎实的计算机基础知识，很好的掌握了如数据结构、算法这些工具，能够在工作中借助这些工具帮助自己解决问题；</strong></p>
<p><strong>2. 优秀的工程师会尽量避免做无用功</strong></p>
<p><strong>3. 优秀的工程师不会只满足于完成任务，他们会不断的去思考探索最佳的解决方案；</strong></p>
<p><strong>4. 优秀的工程师不会被思维所局限，考虑问题更加全面，懂得从全局角度优化解决方案。</strong></p>
<p>从这个例子我们也能看出来，一个优秀工程师解决问题的性能可能是普通工程师的几百上千倍，一个优秀的解决方案甚至能帮助公司节省几百万的服务器费用。</p>
<p>因此，<strong>在软件工程领域一百个臭皮匠也顶不了一个诸葛亮！</strong></p>
<h2 id="做为普通工程师的我们如何提升自己？"><a href="#做为普通工程师的我们如何提升自己？" class="headerlink" title="做为普通工程师的我们如何提升自己？"></a>做为普通工程师的我们如何提升自己？</h2><p><strong>学好数据结构、算法、操作系统原理、计算机体系结构等基本功，打好基础。</strong></p>
<p>如果你是天才，面对像上面这样的问题，即使你没有学过计算机理论知识，即使你不知道动态规划、二叉树、堆排序，可能也能依靠智力上的优势解决。但遗憾的是绝大多数人都不是天才，因此在解决问题的时候就需要借助各种工具以便事半功倍。对于开发人员来说，数据结构、算法以及各种数学知识就是我们手上的工具。</p>
<p><strong>要成为优秀的工程师需要我们静下来，沉下去，老老实实的吃透你所做的项目。做好简单的事，才有机会去做更有挑战的工作。</strong></p>
<p>很多工程师会抱怨自己一直在做业务，没什么挑战，感觉不到成长。可事实真的是这样吗？往往我们的业务需求就像这道面试题，看似简单其实想要做好，背后需要下很大功夫。就算平时做的业务真的很简单，我们是不是还可以想想，我的代码实现是否有更好的方式？面对类似的业务我的效率是否可以提升？线上出 Bug 了是否可以采集到线上 Log 快速定位并解决问题？你对自己开发的项目中用到的各种框架是否真的理解其原理，是否真的去翻过代码学习过这些优秀框架的实现？就拿 Android 开发来说，各种开源框架如 RxJava、Retrofit、OKHttp、ORM框架、热修复框架、插件化框架等等，如果你真的去认真学习过一遍，我相信已经远超行业里 90% 的工程师了。</p>
<p>同时在工作中要有不怕吃亏的心态，主动去承担更多的职责；做的更多往往也意味着接受了更多的挑战，获得了更多的锻炼机会。</p>
<p><strong>利用碎片时间系统化学习</strong></p>
<p>很多人反对碎片化学习，但我并不完全认同这种看法。碎片化的时间既可以用来碎片化的学习，也可以用来做系统化的学习。很多人都指望能够有一天，有一大片的时间，好好的、系统化的把计算机知识恶补一遍。所以买了算法导论、深入理解计算机系统等等经典书籍放在家里，等着有一天能够有一大片时间，沐浴更衣、正襟危坐来好好学习。但是学了不久很快又被其它事打断了，结果下一次又重新再来。最后往往只是把一本书的前几十页反复看了好多遍，其实这种才是真正的碎片化学习。</p>
<p>而所谓的利用碎片化时间系统化的学习是指制定好完善的学习计划，利用好每一个碎片时间，比如上下班的路上、等公交的时间、坐地铁的时间、排队的时间，甚至是蹲马桶的时间来按计划的、体系化的学习提高。</p>
<p><strong>持续学习，坚持阅读，保持输出</strong></p>
<p>技术更新迭代太快，而计算机科学之复杂也远不是在学校的几年学习就能完全学透的，这就要求我们保持持续学习。但往往很多人走出校门后就再也没有正儿八经的学习过、冲过电，这也是为什么我们毕业后会被那些优秀的工程师越甩越远的原因。而我认为最好的持续学习的方式就是坚持阅读了。你们看！优秀的工程师就算是挂着盐水也要坚持阅读的！！！🤣🤣🤣</p>
<p><img src="http://resources.baronzhang.com/blog/other/engineer/pic2.jpg" alt=""></p>
<p>另外学过的知识只有输出出来了，才是真正的学到肚子了。向别人讲述知识、写作等都是很好的知识输出方式。</p>
<p><strong>锻炼自己的综合能力</strong></p>
<p>要成为一名优秀的工程师，光有过硬的技术是不够的。出色的完成一项工作往往考研的是一个人的综合能力。良好的表达能力、出色的会议组织能力、事情的推动能力、个人的成熟度等等都是需要我们在工作中去刻意的培养和锻炼的。拿表达能力来说，如果觉得自己表达上有所欠缺，就可以通过写作、主动在团队内做技术分享等等方式来锻炼自己。有时候，不逼自己一把你都不知道自己到底有多棒！</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>作为一个技术上的菜鸟，写这样的文章实在是有点惭愧。且算是给自己定个基调，与大家共勉好了，这样也能督促自己不断进步。</p>
<p>哦，对了！还有一点！！！优秀的工程师是不会抱着手机抖音一刷一晚上的。🤣🤣🤣</p>
<blockquote>
<p>如果喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/blog/other/engineer/pic1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关注微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，获取更多精彩好文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我相信每个工程师都曾怀揣一个成为技术大牛的梦想，可是真正走向技术大牛这条路的少之又少。工作中我们常常会发现，有些同学工作没几年但成长迅速；很快就能走向团队核心岗位，成为一名优秀的工程师；而有些同学工作几年后却在公司里默默无闻，能力和职位上都没有太大提升，得过且过最终沦为一名普普通通的码农。所以我常常会有感慨，太多人（包括我自己）真的只不过是用一两年的经验在职场上混了五年十年甚至更久。&lt;/p&gt;
&lt;p&gt;那么普通工程师和优秀工程师到底差距在哪儿？那些优秀工程师是怎么一步一步成长起来了的呢？以下就我自己的观察和思考来谈一谈，看看能不能一探究竟，了解通向优秀工程师的法门；然后与大家共勉，一起朝着优秀工程师的方向去努力。&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://baronzhang.com/categories/Other/"/>
    
    
      <category term="算法" scheme="http://baronzhang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://baronzhang.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>写给 Android 应用工程师的 Binder 原理剖析</title>
    <link href="http://baronzhang.com//blog/Android/%E5%86%99%E7%BB%99-Android-%E5%BA%94%E7%94%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84-Binder-%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>http://baronzhang.com//blog/Android/写给-Android-应用工程师的-Binder-原理剖析/</id>
    <published>2018-04-10T15:11:37.000Z</published>
    <updated>2019-08-19T11:51:08.973Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/blog/android/binder/header.jpg" alt=""></p>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>这篇文章我酝酿了很久，参考了很多资料，读了很多源码，却依旧不敢下笔。生怕自己理解上还有偏差，对大家造成误解，贻笑大方。又怕自己理解不够透彻，无法用清晰直白的文字准确的表达出 Binder 的设计精髓。直到今天提笔写作时还依旧战战兢兢。</p>
<p>Binder 之复杂远远不是一篇文章就能说清楚的，本文想站在一个更高的维度来俯瞰 Binder 的设计，最终帮助大家形成一个完整的概念。对于应用层开发的同学来说，理解到本文这个程度也就差不多了。希望更加深入理解 Binder 实现机制的，可以阅读文末的参考资料以及相关源码。</p>
<a id="more"></a>
<h2 id="二-Binder-概述"><a href="#二-Binder-概述" class="headerlink" title="二. Binder 概述"></a>二. Binder 概述</h2><p>简单介绍下什么是 Binder。Binder 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。对于 Binder 更全面的定义，等我们介绍完 Binder 通信原理后再做详细说明。</p>
<h3 id="2-1-为什么必须理解-Binder-？"><a href="#2-1-为什么必须理解-Binder-？" class="headerlink" title="2.1 为什么必须理解 Binder ？"></a>2.1 为什么必须理解 Binder ？</h3><p>作为 Android 工程师的你，是不是常常会有这样的疑问：</p>
<ul>
<li>为什么 Activity 间传递对象需要序列化？</li>
<li>Activity 的启动流程是什么样的？</li>
<li>四大组件底层的通信机制是怎样的？</li>
<li>AIDL 内部的实现原理是什么？</li>
<li>插件化编程技术应该从何学起？等等…</li>
</ul>
<p>这些问题的背后都与 Binder 有莫大的关系，要弄懂上面这些问题理解 Bidner 通信机制是必须的。</p>
<p>我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provide 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要，毫不夸张的说理解 Binder 是迈向 Android 高级工程的第一步。</p>
<h3 id="2-2-为什么是-Binder"><a href="#2-2-为什么是-Binder" class="headerlink" title="2.2 为什么是 Binder ?"></a>2.2 为什么是 Binder ?</h3><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于<strong>性能</strong>、<strong>稳定性</strong>和<strong>安全性</strong>几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<p>注：各种IPC方式数据拷贝次数，此表来源于<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder 设计与实现 - 设计篇</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">IPC方式</th>
<th style="text-align:left">数据拷贝次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">共享内存</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">Binder</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">Socket/管道/消息队列</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<p><strong>最后用一张表格来总结下 Binder 的优势：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">优势</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">性能</td>
<td style="text-align:left">只需要一次数据拷贝，性能上仅次于共享内存</td>
</tr>
<tr>
<td style="text-align:left">稳定性</td>
<td style="text-align:left">基于 C/S 架构，职责明确、架构清晰，因此稳定性好</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">为每个 APP 分配 UID，进程的 UID 是鉴别进程身份的重要标志</td>
</tr>
</tbody>
</table>
<h2 id="三-Linux-下传统的进程间通信原理"><a href="#三-Linux-下传统的进程间通信原理" class="headerlink" title="三. Linux 下传统的进程间通信原理"></a>三. Linux 下传统的进程间通信原理</h2><p>了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。</p>
<h3 id="3-1-基本概念介绍"><a href="#3-1-基本概念介绍" class="headerlink" title="3.1 基本概念介绍"></a>3.1 基本概念介绍</h3><p>这里我们先从 Linux 中进程间通信涉及的一些基本概念开始介绍，然后逐步展开，向大家说明传统的进程间通信的原理。</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/linux_ipc_1.png" alt="Linux 背景知识"></p>
<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</li>
<li>系统调用：用户态/内核态</li>
</ul>
<h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><p>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
<h4 id="进程空间划分：用户空间-User-Space-内核空间-Kernel-Space"><a href="#进程空间划分：用户空间-User-Space-内核空间-Kernel-Space" class="headerlink" title="进程空间划分：用户空间(User Space)/内核空间(Kernel Space)"></a>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</h4><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<blockquote>
<p>简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/android/binder/process_space.png" alt="图片来自网络"></p>
<h4 id="系统调用：用户态与内核态"><a href="#系统调用：用户态与内核态" class="headerlink" title="系统调用：用户态与内核态"></a>系统调用：用户态与内核态</h4><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">copy_from_user() //将数据从用户空间拷贝到内核空间</div><div class="line">copy_to_user() //将数据从内核空间拷贝到用户空间</div></pre></td></tr></table></figure>
<h3 id="3-2-Linux-下的传统-IPC-通信原理"><a href="#3-2-Linux-下的传统-IPC-通信原理" class="headerlink" title="3.2 Linux 下的传统 IPC 通信原理"></a>3.2 Linux 下的传统 IPC 通信原理</h3><p>理解了上面的几个概念，我们再来看看传统的 IPC 方式中，进程之间是如何实现通信的。</p>
<p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/linux_ipc_2.png" alt="传统 IPC 通信原理"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<ol>
<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ol>
<h2 id="四-Binder-跨进程通信原理"><a href="#四-Binder-跨进程通信原理" class="headerlink" title="四. Binder 跨进程通信原理"></a>四. Binder 跨进程通信原理</h2><p>理解了 Linux IPC 相关概念和通信原理，接下来我们正式介绍下 Binder IPC 的原理。</p>
<h3 id="4-1-动态内核可加载模块-amp-amp-内存映射"><a href="#4-1-动态内核可加载模块-amp-amp-内存映射" class="headerlink" title="4.1 动态内核可加载模块 &amp;&amp; 内存映射"></a>4.1 动态内核可加载模块 &amp;&amp; 内存映射</h3><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>
</blockquote>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>
<p>这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>
<p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h3 id="4-2-Binder-IPC-实现原理"><a href="#4-2-Binder-IPC-实现原理" class="headerlink" title="4.2 Binder IPC 实现原理"></a>4.2 Binder IPC 实现原理</h3><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p>如下图：</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_1.png" alt="Binder IPC 原理"></p>
<h2 id="五-Binder-通信模型"><a href="#五-Binder-通信模型" class="headerlink" title="五. Binder 通信模型"></a>五. Binder 通信模型</h2><p>介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。</p>
<p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h3 id="5-1-Client-Server-ServiceManager-驱动"><a href="#5-1-Client-Server-ServiceManager-驱动" class="headerlink" title="5.1 Client/Server/ServiceManager/驱动"></a>5.1 Client/Server/ServiceManager/驱动</h3><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_2.png" alt=""></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 www.google.com 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 www.google.com 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到 www.google.com 对应的服务器。</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_3.png" alt="互联网通信模型"></p>
<p><em><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder 设计与实现</a>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<blockquote>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。 <br><br><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。<br><br>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER_SET_CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。<br><br><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
</blockquote>
<h3 id="5-2-Binder-通信过程"><a href="#5-2-Binder-通信过程" class="headerlink" title="5.2 Binder 通信过程"></a>5.2 Binder 通信过程</h3><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ol>
<li>首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_4.png" alt="Binder 通信模型"></p>
<h3 id="5-3-Binder-通信中的代理模式"><a href="#5-3-Binder-通信中的代理模式" class="headerlink" title="5.3 Binder 通信中的代理模式"></a>5.3 Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_5.png" alt=""></p>
<h3 id="5-4-Binder-的完整定义"><a href="#5-4-Binder-的完整定义" class="headerlink" title="5.4 Binder 的完整定义"></a>5.4 Binder 的完整定义</h3><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<ul>
<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>
<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>
<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理</li>
<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>
</ul>
<h2 id="六-手动编码实现跨进程调用"><a href="#六-手动编码实现跨进程调用" class="headerlink" title="六. 手动编码实现跨进程调用"></a>六. 手动编码实现跨进程调用</h2><p>通常我们在做开发时，实现进程间通信用的最多的就是 AIDL。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。借助 AIDL 编译以后的代码能帮助我们进一步理解 Binder IPC 的通信原理。</p>
<p>但是无论是从可读性还是可理解性上来看，编译器生成的代码对开发者并不友好。比如一个 BookManager.aidl 文件对应会生成一个 BookManager.java 文件，这个 java 文件包含了一个 BookManager 接口、一个 Stub 静态的抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。</p>
<blockquote>
<p>Android 之所以这样设计其实是有道理的，因为当有多个 AIDL 文件的时候把 BookManager、Stub、Proxy 放在同一个文件里能有效避免 Stub 和 Proxy 重名的问题。</p>
</blockquote>
<p>因此便于大家理解，下面我们来手动编写代码来实现跨进程调用。</p>
<h3 id="6-1-各-Java-类职责描述"><a href="#6-1-各-Java-类职责描述" class="headerlink" title="6.1 各 Java 类职责描述"></a>6.1 各 Java 类职责描述</h3><p>在正式编码实现跨进程调用之前，先介绍下实现过程中用到的一些类。了解了这些类的职责，有助于我们更好的理解和实现跨进程通信。</p>
<ul>
<li><p><strong>IBinder</strong> : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。</p>
</li>
<li><p><strong>IInterface</strong> :  IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</p>
</li>
<li><p><strong>Binder</strong> : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</p>
</li>
<li><p><strong>Stub</strong> : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。</p>
</li>
</ul>
<h3 id="6-2-实现过程讲解"><a href="#6-2-实现过程讲解" class="headerlink" title="6.2 实现过程讲解"></a>6.2 实现过程讲解</h3><p>一次跨进程通信必然会涉及到两个进程，在这个例子中 RemoteService 作为服务端进程，提供服务；ClientActivity 作为客户端进程，使用 RemoteService 提供的服务。如下图：</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/ipc_1.png" alt=""></p>
<p>那么服务端进程具备什么样的能力？能为客户端提供什么样的服务呢？还记得我们前面介绍过的 IInterface 吗，它代表的就是服务端进程具体什么样的能力。因此我们需要定义一个 BookManager 接口，BookManager 继承自 IIterface，表明服务端具备什么样的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这个类用来定义服务端 RemoteService 具备什么样的能力</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只定义服务端具备什么要的能力是不够的，既然是跨进程调用，那么接下来我们得实现一个跨进程调用对象 Stub。Stub 继承 Binder, 说明它是一个 Binder 本地对象；实现 IInterface 接口，表明具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要调用方自己实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">BookManager</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BookManager <span class="title">asInterface</span><span class="params">(IBinder binder)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (binder == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        IInterface iin = binder.queryLocalInterface(DESCRIPTOR);</div><div class="line">        <span class="keyword">if</span> (iin != <span class="keyword">null</span> &amp;&amp; iin <span class="keyword">instanceof</span> BookManager)</div><div class="line">            <span class="keyword">return</span> (BookManager) iin;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Proxy(binder);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (code) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION:</div><div class="line">                reply.writeString(DESCRIPTOR);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> TRANSAVTION_addBook:</div><div class="line">                data.enforceInterface(DESCRIPTOR);</div><div class="line">                Book arg0 = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (data.readInt() != <span class="number">0</span>) &#123;</div><div class="line">                    arg0 = Book.CREATOR.createFromParcel(data);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">this</span>.addBook(arg0);</div><div class="line">                reply.writeNoException();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Stub 类中我们重点介绍下 <code>asInterface</code> 和 <code>onTransact</code>。</p>
<p>先说说 <code>asInterface</code>，当 Client 端在创建和服务端的连接，调用 bindService 时需要创建一个 ServiceConnection 对象作为入参。在 ServiceConnection 的回调方法 onServiceConnected 中 会通过这个 asInterface(IBinder binder) 拿到 BookManager 对象，这个 IBinder 类型的入参 binder 是驱动传给我们的，正如你在代码中看到的一样，方法中会去调用 binder.queryLocalInterface() 去查找 Binder 本地对象，如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象，可以直接使用。否则说明是 binder 是个远程对象，也就是 BinderProxy。因此需要我们创建一个代理对象 Proxy，通过这个代理对象来是实现远程访问。</p>
<p>接下来我们就要实现这个代理类 Proxy 了，既然是代理类自然需要实现 BookManager 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">BookManager</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(IBinder remote)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.remote = remote;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line"></div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel replay = Parcel.obtain();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">            <span class="keyword">if</span> (book != <span class="keyword">null</span>) &#123;</div><div class="line">                data.writeInt(<span class="number">1</span>);</div><div class="line">                book.writeToParcel(data, <span class="number">0</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                data.writeInt(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            remote.transact(Stub.TRANSAVTION_addBook, data, replay, <span class="number">0</span>);</div><div class="line">            replay.readException();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            replay.recycle();</div><div class="line">            data.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看看 addBook() 的实现；在 Stub 类中，addBook(Book book) 是一个抽象方法，Client 端需要继承并实现它。</p>
<ul>
<li>如果 Client 和 Server 在同一个进程，那么直接就是调用这个方法。</li>
<li>如果是远程调用，Client 想要调用 Server 的方法就需要通过 Binder 代理来完成，也就是上面的 Proxy。</li>
</ul>
<p>在 Proxy 中的 addBook() 方法中首先通过 Parcel 将数据序列化，然后调用 remote.transact()。正如前文所述 Proxy 是在 Stub 的 asInterface 中创建，能走到创建 Proxy 这一步就说明 Proxy 构造函数的入参是 BinderProxy，即这里的 remote 是个 BinderProxy 对象。最终通过一系列的函数调用，Client 进程通过系统调用陷入内核态，Client 进程中执行 addBook() 的线程挂起等待返回；驱动完成一系列的操作之后唤醒 Server 进程，调用 Server 进程本地对象的 onTransact()。最终又走到了 Stub 中的 onTransact() 中，onTransact() 根据函数编号调用相关函数（在 Stub 类中为 BookManager 接口中的每个函数中定义了一个编号，只不过上面的源码中我们简化掉了；在跨进程调用的时候，不会传递函数而是传递编号来指明要调用哪个函数）；我们这个例子里面，调用了 Binder 本地对象的 addBook() 并将结果返回给驱动，驱动唤醒 Client 进程里刚刚挂起的线程并将结果返回。</p>
<p>这样一次跨进程调用就完成了。</p>
<p>完整的代码我放到 GitHub 上了，有兴趣的小伙伴可以去看看。源码地址：<a href="https://github.com/BaronZ88/HelloBinder" target="_blank" rel="external">https://github.com/BaronZ88/HelloBinder</a></p>
<p>最后建议大家在不借助 AIDL 的情况下手写实现 Client 和 Server 进程的通信，加深对 Binder 通信过程的理解。</p>
<blockquote>
<p>受个人能力水平限制，文章中难免会有错误。如果大家发现文章不足之处，欢迎与我沟通交流。</p>
</blockquote>
<p><strong>本文在写作过程中参考了很多文章、书籍和源码，其中有很多描述和图片都借鉴了下面的文章，在这里感谢大佬们的无私分享！</strong></p>
<p><strong>参考资料如下：</strong></p>
<ul>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder 设计与实现 - 设计篇</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">Android 进程间通信（IPC）机制 Binder 简要介绍和学习计划</a>、<a href="http://item.jd.com/12248208.html" target="_blank" rel="external">《Android 系统源代码情景分析》</a></li>
<li><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="external">Binder 学习指南</a></li>
<li><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="external">Binder 系列文章</a></li>
<li><a href="https://blog.csdn.net/carson_ho/article/details/73560642" target="_blank" rel="external">Android 图文详解 Binder 跨进程通信原理</a></li>
<li><a href="http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html" target="_blank" rel="external">Android 深入浅出之 Binder 机制</a></li>
<li><a href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="external">用户空间与内核空间</a></li>
<li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析 mmap ：是什么 为什么 怎么用</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/blog/android/binder/header.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h2&gt;&lt;p&gt;这篇文章我酝酿了很久，参考了很多资料，读了很多源码，却依旧不敢下笔。生怕自己理解上还有偏差，对大家造成误解，贻笑大方。又怕自己理解不够透彻，无法用清晰直白的文字准确的表达出 Binder 的设计精髓。直到今天提笔写作时还依旧战战兢兢。&lt;/p&gt;
&lt;p&gt;Binder 之复杂远远不是一篇文章就能说清楚的，本文想站在一个更高的维度来俯瞰 Binder 的设计，最终帮助大家形成一个完整的概念。对于应用层开发的同学来说，理解到本文这个程度也就差不多了。希望更加深入理解 Binder 实现机制的，可以阅读文末的参考资料以及相关源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://baronzhang.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="Binder" scheme="http://baronzhang.com/tags/Binder/"/>
    
      <category term="IPC" scheme="http://baronzhang.com/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>为 Retrofit2 提供的 FastJson 转换库</title>
    <link href="http://baronzhang.com//blog/Android/%E4%B8%BA-Retrofit2-%E6%8F%90%E4%BE%9B%E7%9A%84-FastJson-%E8%BD%AC%E6%8D%A2%E5%BA%93/"/>
    <id>http://baronzhang.com//blog/Android/为-Retrofit2-提供的-FastJson-转换库/</id>
    <published>2017-05-17T05:15:49.000Z</published>
    <updated>2019-08-19T12:56:35.811Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>为 Retrofit2 提供的 FastJson 转换器（Retrofit2-FastJson-Converter）</p>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Retrofit 是 Android 和 Java 平台上一款优秀且被广泛使用的 Http 客户端，GitHub 上 21K+ 的 Star 和 4.3K+ 的 Fork 充分证明了 Retrofit 的风靡程度。</p>
<p>Retrofit 在 Android 平台如此流行与它及其简洁的调用方式和优秀的可扩展、可配置性是分不开的。我们客户端在和服务端交互的时候通常采用 Json 格式来传递数据，客户端拿到服务端传递过来的 Json 格式的数据后需要对它进行解析；Retrofit2 并未提供 Json 解析功能，但可提供接口让客户端程序员配置 Json Converter以选择自己喜欢的 Json 解析库。</p>
<a id="more"></a>
<p>Json 解析库有很多：Gson、Jackson、FastJson等等。Retrofit 优秀的可配置性可以让我们客户端程序员随意选择心怡的 Json 解析库，Retrofit 针对 Gson 和 Jackson 都提供相应的 Converter；可能由于 FastJson 是国内程序员开发的原因，Retrofit 对于 FastJson 并没有提供对应的 Converter ，这对于使用 FastJson 的开发者是不友好的。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>好在 Retrofit 提供了接口来让开发者实现自己的 Json Converter 。实现 Converter 虽然简单，但每次使用 Retrofit2 + FastJson 组合时都实现一套显然是没必要的。我使用 FastJson 实现了一个 Converter: <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a> ，有同样需求的同学只需要使用我这个 Converter 库就好啦，不必再去自定义。使用方式如下：</p>
<h3 id="1、添加依赖配置"><a href="#1、添加依赖配置" class="headerlink" title="1、添加依赖配置"></a>1、添加依赖配置</h3><p><strong>Step 1</strong>. 由于 <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a>  是发布到 JitPack 的，因此首先需要在项目根目录的 build.gradle 中加入 JitPack 的仓库地址，具体配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">	repositories &#123;</div><div class="line">		...</div><div class="line">		maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Step 2</strong>. 在具体使用 <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a> 的 module 中加入依赖配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">	compile <span class="string">'com.github.BaronZ88:Retrofit2-FastJson-Converter:lastVersion'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、配置-Retrofit-Converter"><a href="#2、配置-Retrofit-Converter" class="headerlink" title="2、配置 Retrofit Converter"></a>2、配置 Retrofit Converter</h3><p>在 Retrofit.Builder 的 addConverterFactory 方法中传入 <code>FastJsonConverterFactory.create()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">      .baseUrl(baseUrl)</div><div class="line">      .addConverterFactory(FastJsonConverterFactory.create())</div><div class="line">      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">      .client(client)</div><div class="line">      .build();</div></pre></td></tr></table></figure>
<p>最后贴上 Retrofit2-FastJson-Converter 源码地址 ：<a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">https://github.com/BaronZ88/Retrofit2-FastJson-Converter</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>一直不满意各博客平台上的阅读体验，排版糟糕、布局混乱、字体丑陋、各种广告及杂七杂八的组件分散了读者宝贵的注意力；最最重要的是这年头竟然找不到一个优雅、简介、有美感的博客平台！！！我不能忍！为了赏脸阅读我文章的读者！为了我这仅剩的一点点审美！我采用 GitHub Pages + Hexo + NexT 搭建了个人博客 <a href="http://baronzhang.com">http://baronzhang.com</a> ，不过身为拖延症晚期患者的我，直到最近才将博客系统的各项功能陆续完善起来。之前的文章均已同步，之后所有的文章也会第一时间在个人博客上发布，追求更好阅读体验的同学可以移步 <a href="http://baronzhang.com">baronzhang.com</a> 。</strong></p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为 Retrofit2 提供的 FastJson 转换器（Retrofit2-FastJson-Converter）&lt;/p&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Retrofit 是 Android 和 Java 平台上一款优秀且被广泛使用的 Http 客户端，GitHub 上 21K+ 的 Star 和 4.3K+ 的 Fork 充分证明了 Retrofit 的风靡程度。&lt;/p&gt;
&lt;p&gt;Retrofit 在 Android 平台如此流行与它及其简洁的调用方式和优秀的可扩展、可配置性是分不开的。我们客户端在和服务端交互的时候通常采用 Json 格式来传递数据，客户端拿到服务端传递过来的 Json 格式的数据后需要对它进行解析；Retrofit2 并未提供 Json 解析功能，但可提供接口让客户端程序员配置 Json Converter以选择自己喜欢的 Json 解析库。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://baronzhang.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 模块化探索与实践</title>
    <link href="http://baronzhang.com//blog/Framework/Android-%E6%A8%A1%E5%9D%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://baronzhang.com//blog/Framework/Android-模块化探索与实践/</id>
    <published>2017-05-08T06:04:12.000Z</published>
    <updated>2019-08-19T12:56:35.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/blog/framework/android/2/header.jpg" alt=""></p>
<blockquote>
<p>首发于《程序员》杂志五月刊</p>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>万维网发明人 Tim Berners-Lee 谈到设计原理时说过：“简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。” 由此可见模块化之于软件工程领域的重要性。</p>
<p>从 2016 年开始，模块化在 Android 社区越来越多的被提及。随着移动平台的不断发展，移动平台上的软件慢慢走向复杂化，体积也变得臃肿庞大；为了降低大型软件复杂性和耦合度，同时也为了适应模块重用、多团队并行开发测试等等需求，模块化在 Android 平台上变得势在必行。阿里 Android 团队在年初开源了他们的容器化框架 Atlas 就很大程度说明了当前 Android 平台开发大型商业项目所面临的问题。</p>
<a id="more"></a>
<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>那么什么是模块化呢？《 Java 应用架构设计：模块化模式与 OSGi 》一书中对它的定义是：模块化是一种处理复杂系统分解为更好的可管理模块的方式。</p>
<p>上面这种描述太过生涩难懂，不够直观。下面这种类比的方式则可能加容易理解。</p>
<p>我们可以把软件看做是一辆汽车，开发一款软件的过程就是生产一辆汽车的过程。一辆汽车由车架、发动机、变数箱、车轮等一系列模块组成；同样，一款大型商业软件也是由各个不同的模块组成的。</p>
<p>汽车的这些模块是由不同的工厂生产的，一辆 BMW 的发动机可能是由位于德国的工厂生产的，它的自动变数箱可能是 Jatco（世界三大变速箱厂商之一）位于日本的工厂生产的，车轮可能是中国的工厂生产的，最后交给华晨宝马的工厂统一组装成一辆完整的汽车。这就类似于我们在软件工程领域里说的多团队并行开发，最后将各个团队开发的模块统一打包成我们可使用的 App 。</p>
<p>一款发动机、一款变数箱都不可能只应用于一个车型，比如同一款 Jatco 的 6AT 自动变速箱既可能被安装在 BMW 的车型上，也可能被安装在 Mazda 的车型上。这就如同软件开发领域里的模块重用。</p>
<p>到了冬天，特别是在北方我们可能需要开着车走雪路，为了安全起见往往我们会将汽车的公路胎升级为雪地胎；轮胎可以很轻易的更换，这就是我们在软件开发领域谈到的低耦合。一个模块的升级替换不会影响到其它模块，也不会受其它模块的限制；同时这也类似于我们在软件开发领域提到的可插拔。</p>
<h2 id="模块化分层设计"><a href="#模块化分层设计" class="headerlink" title="模块化分层设计"></a>模块化分层设计</h2><p>上面的类比很清晰的说明的模块化带来的好处：</p>
<ul>
<li>多团队并行开发测试；</li>
<li>模块间解耦、重用；</li>
<li>可单独编译打包某一模块，提升开发效率。</li>
</ul>
<p>在<a href="https://zhuanlan.zhihu.com/p/25420181" target="_blank" rel="external">《安居客 Android 项目架构演进》</a>这篇文章中，我介绍了安居客 Android 端的模块化设计方案，这里我还是拿它来举例。但首先要对本文中的<strong>组件</strong>和<strong>模块</strong>做个区别定义</p>
<ul>
<li><p><strong>组件</strong>：指的是单一的功能组件，如地图组件（MapSDK）、支付组件（AnjukePay）、路由组件（Router）等等；</p>
</li>
<li><p><strong>模块</strong>：指的是独立的业务模块，如新房模块（NewHouseModule）、二手房模块（SecondHouseModule）、即时通讯模块（InstantMessagingModule）等等；模块相对于组件来说粒度更大。</p>
</li>
</ul>
<p>具体设计方案如下图：</p>
<p><img src="http://resources.baronzhang.com/blog/framework/android/2/modularization.png" alt="Android 模块化设计方案"></p>
<p>整个项目分为三层，从下至上分别是：</p>
<ul>
<li>Basic Component Layer: 基础组件层，顾名思义就是一些基础组件，包含了各种开源库以及和业务无关的各种自研工具库；</li>
<li>Business Component Layer: 业务组件层，这一层的所有组件都是业务相关的，例如上图中的支付组件 AnjukePay、数据模拟组件 DataSimulator 等等；</li>
<li>Business Module Layer: 业务 Module 层，在 Android Studio 中每块业务对应一个单独的 Module。例如安居客用户 App 我们就可以拆分成新房 Module、二手房 Module、IM Module 等等，每个单独的 Business Module 都必须准遵守我们自己的 MVP 架构。</li>
</ul>
<p>我们在谈模块化的时候，其实就是将业务模块层的各个功能业务拆分层独立的业务模块。所以我们进行模块化的第一步就是业务模块划分，但是模块划分并没有一个业界通用的标准，因此划分的粒度需要根据项目情况进行合理把控，这就需要对业务和项目有较为透彻的理解。拿安居客来举例，我们会将项目划分为新房模块、二手房模块、IM 模块等等。</p>
<p>每个业务模块在 Android Studio 中的都是一个 Module ,因此在命名方面我们要求每个业务模块都以 Module 为后缀。如下图所示：<div align="left"><img src="http://resources.baronzhang.com/blog/framework/android/2/modules.png" width="40%" alt="图片名称" align="center"></div></p>
<p>对于模块化项目，每个单独的 Business Module 都可以单独编译成 APK。在开发阶段需要单独打包编译，项目发布的时候又需要它作为项目的一个 Module 来整体编译打包。简单的说就是开发时是 Application，发布时是 Library。因此需要在 Business Module 的 build.gradle 中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isBuildModule.toBoolean())&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>isBuildModule 在项目根目录的 gradle.properties 中定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; isBuildModule=<span class="keyword">false</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>同样 Manifest.xml 也需要有两套：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sourceSets &#123;</div><div class="line">   main &#123;</div><div class="line">       <span class="keyword">if</span> (isBuildModule.toBoolean()) &#123;</div><div class="line">           manifest.srcFile <span class="string">'src/main/debug/AndroidManifest.xml'</span></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           manifest.srcFile <span class="string">'src/main/release/AndroidManifest.xml'</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如图：<div align="left"><img src="http://resources.baronzhang.com/blog/framework/android/2/manifest.png" width="45%" alt="图片名称" align="center"></div></p>
<p>debug 模式下的 AndroidManifest.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span></span></div><div class="line">   <span class="attr">...</span></div><div class="line">   &gt;</div><div class="line">   <span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">       <span class="attr">android:name</span>=<span class="string">"com.baronzhang.android.newhouse.NewHouseMainActivity"</span></div><div class="line">       <span class="attr">android:label</span>=<span class="string">"@string/new_house_label_home_page"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></div></pre></td></tr></table></figure>
<p>realease 模式下的 AndroidManifest.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span></span></div><div class="line">   <span class="attr">...</span></div><div class="line">   &gt;</div><div class="line">   <span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">       <span class="attr">android:name</span>=<span class="string">"com.baronzhang.android.newhouse.NewHouseMainActivity"</span></div><div class="line">       <span class="attr">android:label</span>=<span class="string">"@string/new_house_label_home_page"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">"com.baronzhang.android.newhouse"</span></span></div><div class="line">               <span class="attr">android:scheme</span>=<span class="string">"router"</span> /&gt;</div><div class="line">       <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></div></pre></td></tr></table></figure>
<p>同时针对模块化我们也定义了一些自己的游戏规则:</p>
<ul>
<li>对于 Business Module Layer，各业务模块之间不允许存在相互依赖关系，它们之间的跳转通讯采用路由框架 Router 来实现（后面会介绍 Router 框架的实现）;</li>
<li>对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，个性化需求对外部提供接口让调用方定制;</li>
<li>合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分;</li>
<li>上层的公有业务或者功能模块可以逐步下放到下层，合理把握好度就好；</li>
<li>各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。</li>
</ul>
<h2 id="模块间跳转通讯（Router）"><a href="#模块间跳转通讯（Router）" class="headerlink" title="模块间跳转通讯（Router）"></a>模块间跳转通讯（Router）</h2><p>对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个 Bussiness Module 都是独立的模块，它们之间是没有依赖关系。那么各个模块间的跳转通讯如何实现呢？</p>
<p>比如业务上要求从<strong>新房的列表页</strong>跳转到<strong>二手房的列表页</strong>，那么由于是 NewHouseModule 和 SecondHouseModule 之间并不相互依赖，我们通过想如下这种显式跳转的方式来实现 Activity 跳转显然是不可能的实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(NewHouseListActivity.<span class="keyword">this</span>, SecondHouseListActivity.class);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>有的同学可能会想到用隐式跳转，通过 Intent 匹配规则来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, <span class="string">"&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;"</span>);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>但是这种代码写起来比较繁琐，且容易出错，出错也不太容易定位问题。因此一个简单易用、解放开发的路由框架是必须的了。<div align="left"><img src="http://resources.baronzhang.com/blog/framework/android/2/router2.png" width="45%" alt="图片名称" align="center"></div></p>
<p>我自己实现的路由框架分为<b>路由（Router）</b> 和<b>参数注入器（Injector）</b> 两部分：<div align="left"><img src="http://resources.baronzhang.com/blog/framework/android/2/router.png" width="45%" alt="图片名称" align="center"></div></p>
<blockquote>
<p>Router 提供 Activity 跳转传参的功能；Injector 提供参数注入功能，通过编译时生成代码的方式在 Activity 获取获取传递过来的参数，简化开发。</p>
</blockquote>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>路由（Router）部分通过 Java 注解结合动态代理来实现，这一点和 Retrofit 的实现原理是一样的。</p>
<p>首先需要定义我们自己的注解（篇幅有限，这里只列出少部分源码）。</p>
<p>用于定义跳转 URI 的注解 FullUri：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FullUri &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于定义跳转传参的 UriParam（ UriParam 注解的参数用于拼接到 URI 后面）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UriParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于定义跳转传参的 IntentExtrasParam（ IntentExtrasParam 注解的参数最终通过 Intent 来传递）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IntentExtrasParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实现 Router ,内部通过动态代理的方式来实现 Activity 跳转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class[]&#123;service&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"></div><div class="line">                FullUri fullUri = method.getAnnotation(FullUri.class);</div><div class="line">                StringBuilder urlBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">                urlBuilder.append(fullUri.value());</div><div class="line">                <span class="comment">//获取注解参数</span></div><div class="line">                Annotation[][] parameterAnnotations = method.getParameterAnnotations();</div><div class="line">                HashMap&lt;String, Object&gt; serializedParams = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">			    <span class="comment">//拼接跳转 URI</span></div><div class="line">                <span class="keyword">int</span> position = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</div><div class="line">                    Annotation[] annotations = parameterAnnotations[i];</div><div class="line">                    <span class="keyword">if</span> (annotations == <span class="keyword">null</span> || annotations.length == <span class="number">0</span>)</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    Annotation annotation = annotations[<span class="number">0</span>];</div><div class="line">                    <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> UriParam) &#123;</div><div class="line">                        <span class="comment">//拼接 URI 后的参数</span></div><div class="line">                        ...</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> IntentExtrasParam) &#123;</div><div class="line">                        <span class="comment">//Intent 传参处理</span></div><div class="line">                        ...</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//执行Activity跳转操作</span></div><div class="line">                performJump(urlBuilder.toString(), serializedParams);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是 Router 实现的部分代码，在使用 Router 来跳转的时候，首先需要定义一个 Interface（类似于 Retrofit 的使用方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouterService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@FullUri</span>(<span class="string">"router://com.baronzhang.android.router.FourthActivity"</span>)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startUserActivity</span><span class="params">(@UriParam(<span class="string">"cityName"</span>)</span></span></div><div class="line">    		String cityName, @<span class="title">IntentExtrasParam</span><span class="params">(<span class="string">"user"</span>)</span> User user);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们就可以通过如下方式实现 Activity 的跳转传参了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RouterService routerService = <span class="keyword">new</span> Router(<span class="keyword">this</span>).create(RouterService.class);</div><div class="line"></div><div class="line">User user = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">17</span>, <span class="number">165</span>, <span class="number">88</span>);</div><div class="line">routerService.startUserActivity(<span class="string">"上海"</span>, user);</div></pre></td></tr></table></figure>
<h3 id="Injector"><a href="#Injector" class="headerlink" title="Injector"></a>Injector</h3><p>通过 Router 跳转到目标 Activity 后，我们需要在目标 Activity 中获取通过 Intent 传过来的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getIntent().getIntExtra(<span class="string">"intParam"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">getIntent().getData().getQueryParameter(<span class="string">"preActivity"</span>);</div></pre></td></tr></table></figure>
<p>为了简化这部分工作，路由框架 Router 中提供了 Injector 模块在编译时生成上述代码。参数注入器（Injector）部分通过 Java 编译时注解来实现，实现思路和 ButterKnife 这类编译时注解框架类似。</p>
<p>首先定义我们的参数注解 InjectUriParam ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectUriParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实现一个注解处理器 InjectProcessor ，在编译阶段生成获取参数的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line">    ...</div><div class="line">   <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//解析注解</span></div><div class="line">        Map&lt;TypeElement, TargetClass&gt; targetClassMap = findAndParseTargets(roundEnvironment);</div><div class="line"></div><div class="line">        <span class="comment">//解析完成后，生成的代码的结构已经有了，它们存在InjectingClass中</span></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;TypeElement, TargetClass&gt; entry : targetClassMap.entrySet()) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方式类似于 ButterKnife ，在 Activity 中我们使用 Inject 来注解一个全局变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inject</span> User user;</div></pre></td></tr></table></figure>
<p>然后 onCreate 方法中需要调用 inject(Activity activity) 方法实现注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RouterInjector.inject(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>这样我们就可以获取到前面通过 Router 跳转的传参了。</p>
<blockquote>
<p>由于篇幅限制，加上为了便于理解，这里只贴出了极少部分 <a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 框架的源码。希望进一步了解 Router 实现原理的可以到 GiuHub 去翻阅源码，<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 的实现还比较简陋，后面会进一步完善功能和文档，之后也会有单独的文章详细介绍。源码地址：<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">https://github.com/BaronZ88/Router</a></p>
</blockquote>
<h2 id="问题及建议"><a href="#问题及建议" class="headerlink" title="问题及建议"></a>问题及建议</h2><h3 id="资源名冲突"><a href="#资源名冲突" class="headerlink" title="资源名冲突"></a>资源名冲突</h3><p>对于多个 Bussines Module 中资源名冲突的问题，可以通过在 build.gradle 定义前缀的方式解决：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">   ...</div><div class="line">   resourcePrefix <span class="string">"new_house_"</span></div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于 Module 中有些资源不想被外部访问的，我们可以创建 res/values/public.xml，添加到 public.xml 中的 resource 则可被外部访问，未添加的则视为私有：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">"new_house_settings"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="重复依赖"><a href="#重复依赖" class="headerlink" title="重复依赖"></a>重复依赖</h3><p>模块化的过程中我们常常会遇到重复依赖的问题，如果是通过 aar 依赖， gradle 会自动帮我们找出新版本，而抛弃老版本的重复依赖。如果是以 project 的方式依赖，则在打包的时候会出现重复类。对于这种情况我们可以在 build.gradle 中将 compile 改为 provided，只在最终的项目中 compile 对应的 library ；</p>
<p>其实从前面的安居客模块化设计图上能看出来，我们的设计方案能一定程度上规避重复依赖的问题。比如我们所有的第三方库的依赖都会放到 OpenSoureLibraries 中，其他需要用到相关类库的项目，只需要依赖 OpenSoureLibraries 就好了。</p>
<h3 id="模块化过程中的建议"><a href="#模块化过程中的建议" class="headerlink" title="模块化过程中的建议"></a>模块化过程中的建议</h3><p>对于大型的商业项目，在重构过程中可能会遇到业务耦合严重，难以拆分的问题。<strong>我们需要先理清业务，再动手拆分业务模块</strong>。比如可以先在原先的项目中根据业务分包，在一定程度上将各业务解耦后拆分到不同的 package 中。比如之前新房和二手房由于同属于 app module，因此他们之前是通过隐式的 intent 跳转的，现在可以先将他们改为通过 Router 来实现跳转。又比如新房和二手房中公用的模块可以先下放到 Business Component Layer 或者 Basic Component Layer 中。在这一系列工作完成后再将各个业务拆分成多个 module 。</p>
<p>模块化重构需要渐进式的展开，不可一触而就，不要想着将整个项目推翻重写。线上成熟稳定的业务代码，是经过了时间和大量用户考验的；全部推翻重写往往费时费力，实际的效果通常也很不理想，各种问题层出不穷得不偿失。对于这种项目的模块化重构，我们需要一点点的改进重构，可以分散到每次的业务迭代中去，逐步淘汰掉陈旧的代码。</p>
<p>各业务模块间肯定会有公用的部分，按照我前面的设计图，公用的部分我们会根据业务相关性下放到业务组件层（Business Component Layer）或者基础组件层（Common Component Layer）。对于太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分。过程中完美主义可以有，切记不可过度。</p>
<p>以上就是我在模块化探索实践方面的一些经验，不住之处还望大家指出。</p>
<ul>
<li>模块化示例项目 <a href="https://github.com/BaronZ88/ModularizationProject" target="_blank" rel="external">ModularizationProject</a> 源码地址：<a href="https://github.com/BaronZ88/ModularizationProject" target="_blank" rel="external">https://github.com/BaronZ88/ModularizationProject</a></li>
<li>路由框架 <a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 源码地址：<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">https://github.com/BaronZ88/Router</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/blog/framework/android/2/header.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首发于《程序员》杂志五月刊&lt;/p&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;万维网发明人 Tim Berners-Lee 谈到设计原理时说过：“简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。” 由此可见模块化之于软件工程领域的重要性。&lt;/p&gt;
&lt;p&gt;从 2016 年开始，模块化在 Android 社区越来越多的被提及。随着移动平台的不断发展，移动平台上的软件慢慢走向复杂化，体积也变得臃肿庞大；为了降低大型软件复杂性和耦合度，同时也为了适应模块重用、多团队并行开发测试等等需求，模块化在 Android 平台上变得势在必行。阿里 Android 团队在年初开源了他们的容器化框架 Atlas 就很大程度说明了当前 Android 平台开发大型商业项目所面临的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://baronzhang.com/categories/Framework/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://baronzhang.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>安居客 Android 项目架构演进</title>
    <link href="http://baronzhang.com//blog/Framework/%E5%AE%89%E5%B1%85%E5%AE%A2Android%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
    <id>http://baronzhang.com//blog/Framework/安居客Android项目架构演进/</id>
    <published>2017-02-24T09:59:16.000Z</published>
    <updated>2019-08-19T12:56:35.813Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/Blog/Framework/Android/header.jpg" alt=""></p>
<blockquote>
<p>本文已授权微信公众号 AndroidDeveloper 独家发布。</p>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>入职安居客三年从工程师到 Team Leader，见证了 Android 团队一路走来的发展历程。因此有心将这些记录下来与大家分享，也算是对自己三年来一部分工作的总结。希望对大家有所帮助，更希望能得到大家宝贵的建议。<br><a id="more"></a></p>
<h2 id="三网合并"><a href="#三网合并" class="headerlink" title="三网合并"></a>三网合并</h2><p>三年前入职时安居客在业务上刚完成了三网合并（新房、二手房、好租和商业地产多个平台多个网站合成现在的 anjuke.com，这在公司的历史上称之为三网合并）,因此移动端也将原先的新房、二手房、好租和商业地产多个 App 合并成为了现在的安居客 App。所谓的合并也差不多就是将多个项目的代码拷贝到了一起组成了新的 Anjuke Project。下面这张图能更加直观的呈现当时的状况：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/merge1.1.png" width="70%" alt="图片名称" align="center"></div></p>
<p>这一时期代码结构混乱、层次不清，各业务技术方案不统一，冗余代码充斥项目的各个角落；甚至连基本的包结构也是胡乱不堪，项目架构更是无从谈起。大家只不过是不停地往上堆砌代码添加新功能罢了。于是我进入公司的第一件事就是向 Leader 申请梳理了整个项目的结构。</p>
<p>而后随着项目的迭代，我们不断引入了 Retrofit、UniversalImageLoader、OKHttp、ButterKnife 等一系列成熟的开源库，同时我们也开发了自己的 UI 组件库 UIComponent、基础工具库 CommonUtils、基于第三方地图封装的 MapSDK、即时聊天模块 ChatLibrary 等等。这之后安居客项目架构大致演变成了由基础组件层、业务组件层和业务层组成的三层架构。如下图：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/merge2.1.png" width="50%" alt="图片名称" align="center"></div></p>
<p>其中业务层是一种非标准的 MVC 架构，Activity 和 Fragment 承担了 View 和 Controller 的职责：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/merge3.1.png" width="85%" alt="图片名称" align="center"></div></p>
<p>前面这种分层的架构本身是没太大问题的，即使到了现在我们的业务项目也已然是基于这种分层的架构来构建的，只不过在不断的迭代中我们做了些许调整（分层架构后面在介绍组件化和模块化的时候会详细介绍）。但是随着业务的不断迭代,我们慢慢发现业务层这种非标准的MVC架构带来了种种影响团队开发效率的问题：</p>
<ul>
<li>Activity 和 Fragment 越来越多的同时承担了 Controller 和 View 的职责，导致他们变得及其臃肿且难以维护；</li>
<li>由于 Controller 和 View 的揉合，导致单元测试起来很困难；</li>
<li>回调嵌套太多，面对负责业务时的代码逻辑不清晰，难以理解且不利于后期维护；</li>
<li>各层次模块之间职责不清晰等等</li>
</ul>
<blockquote>
<p>鉴于三网合并时期我还未加入安居客，所以对这一块的理解难免有偏差，如果有安居客的老同事发现文章中的描述有不对的地方还望批评指正。</p>
</blockquote>
<h2 id="由-RxJava-驱动的-MVP-架构"><a href="#由-RxJava-驱动的-MVP-架构" class="headerlink" title="由 RxJava 驱动的 MVP 架构"></a>由 RxJava 驱动的 MVP 架构</h2><p>一种技术架构无法满足所有的业务项目，更不可能有一种架构方案能够一劳永逸。正如上一节中提到的随着业务的不断迭代，现有架构的缺陷逐渐浮出水面，项目架构必需不断升级迭代才能更好地服务于业务。</p>
<h3 id="MVP-的设计与实现"><a href="#MVP-的设计与实现" class="headerlink" title="MVP 的设计与实现"></a>MVP 的设计与实现</h3><p>在研究了 Google 推出的基于 MVP 架构的 Demo 后，我们发现 MVP 架构能解决现在所面临过的很多问题，于是我们学习并引入到了我们的项目中来，并针对性的做了部分调整。下图呈现的是安居客 MVP 方案：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/mvp1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>以前面提到的三层架构的方案来看是这样的：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/mvp2.1.png" width="50%" alt="图片名称" align="center"></div></p>
<blockquote>
<p>基于此架构我在 GitHub 上开源了一个项目<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>，有兴趣的小伙伴可以去 Clone 下来看看，如果觉得对你有帮助就给个 Star 吧。  :)</p>
</blockquote>
<ul>
<li><strong>View Layer</strong>: 只负责 UI 的绘制呈现，包含 Fragment 和一些自定义的 UI 组件，View 层需要实现 ViewInterface 接口。Activity 在项目中不再负责 View 的职责，仅仅是一个全局的控制者，负责创建 View 和 Presenter 的实例；</li>
<li><strong>Model Layer</strong>: 负责检索、存储、操作数据，包括来自网络、数据库、磁盘文件和SharedPreferences的数据；</li>
<li><strong>Presenter Layer</strong>: 作为 View Layer 和 Module Layer 的之间的纽带，它从 Model 层中获取数据，然后调用 View 的接口去控制 View；</li>
<li><strong>Contract</strong>: 我们参照 Google 的 Demo 加入契约类 Contract 来统一管理 View 和 Presenter 的接口，使得某一功能模块的接口能更加直观的呈现出来，这样做是有利于后期维护的。</li>
</ul>
<p>另外这套MVP架构还为我们带来了一个额外的好处：<strong>我们有了足够明确的开发规范和标准</strong>。细致到了每一个类应该放到哪个包下，哪个类具体应该负责什么职责等等。这对于我们的 Code Review、接手他人的功能模块等都提供了极大的便利。前面提到的 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 就是为了定规范定标准而开发的。</p>
<p>这一时期我们还在项目中引入了 RxJava，很好的解决了前面提到的嵌套回调的问题，同时能够帮助我们简化复杂业务场景下的代码逻辑（当然 RxJava 的好处远远不止这么一点，对 RxJava 不了解的同学可以去翻翻我之前<a href="https://zhuanlan.zhihu.com/p/20687178?refer=baron" target="_blank" rel="external">一系列关于 RxJava 的文章</a>）。我们也将网络库升级到了 Retrofit2 + OKHttp3，它们和 RxJava 之间能更好的配合。</p>
<h3 id="MVP-带来的新问题及解决方案"><a href="#MVP-带来的新问题及解决方案" class="headerlink" title="MVP 带来的新问题及解决方案"></a>MVP 带来的新问题及解决方案</h3><p>是不是升级到了 MVP 架构就高枕无忧了呢？很明显不是这样！MVP 架构也会带来以下新的问题：</p>
<ul>
<li>由于大量的业务逻辑处理转移到了 Presenter 层，在一些复杂的业务场景中 Presenter 同样会变得臃肿难懂。细心的同学可能注意到了前面的架构图中的 Model 层有个 Data Repository 模块，Data Repository 在这里有两个作用：一是可以将原本由 Presenter 处理的部分逻辑转移到这里来处理，包括数据的校验、部分单纯只与数据相关的逻辑等等，向 Presenter 屏蔽数据处理细节，比如作为 Presenter 就不必关心 Model 层传递过来的数据到底是来至网络还是来至数据库还是来至本地文件等等；二是我们引入了 RxJava，但是只有网络层中的 Retrofit 能返回 Observable 对象，其他模块都是返回的还是一些非 Observable 的 Java 对象，为了能在整个 Presenter 层中都体验 RxJava 带来的美妙之处，因此可以通过 Data Repository 做一层转换；</li>
<li>现在的 MVP 架构中最重的部分就是 Model Layer 了，这一点从前面的架构图中就能体现。因此这就要求我们在 Model 层的设计过程中职责划分要足够清晰，分包更明确，耦合度更低。至于分包大家可以参考 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 的方案：db 包为数据库模块、http 包为网络模块、preference 包是对 SharedPreferences 的一些封装、repository 包就是前面提到的 Data Repository 模块；</li>
<li>同时还有一点需要注意，很多人在使用 RxJava 的过程中往往忘记了对生命周期的管理，这很容易造成内存泄露。<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 中采用了 CompositeSubscription 来管理，你也可以使用 RxLifecycle 这类开源库来管理生命周期。</li>
</ul>
<h2 id="组件化与模块化"><a href="#组件化与模块化" class="headerlink" title="组件化与模块化"></a>组件化与模块化</h2><p>去年下半年我们 Android 团队内部成立了技术小组，基础组件的开发是技术小组很重要的一部分工作，所以组件化是我们正在做的事；模块化更多的是现有的方案受到来自业务上的挑战以及受到了 Oasis Feng 在 MDCC 上的分享和整个大环境的启发，现在正处于设计规划和 Demo 开发的阶段。</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件化不是个新概念，通俗的讲组件化就是基于可重用的目的，将一个大的软件系统拆分成一个个独立组件。</p>
<p>组件化的带来的好处不言而喻：</p>
<ul>
<li>避免重复造轮子，节省开发维护成本；</li>
<li>降低项目复杂性，提升开发效率；</li>
<li>多个团队公用同一个组件，在一定层度上确保了技术方案的统一性。</li>
</ul>
<p>现在的安居客有是三个业务团队：安居客用户 App、经纪人 App、集客家 App。为了避免各个业务团队重复造轮子，团队中也需要有一定的技术沉淀，因此组件化是必须的。从本篇的第一节大家就能看到组件化的影子，只不过在这之前我们做的并不好。现在我们需要提供更多的、职能单一、性能更优的组件供业务团队使用。根据业务相关性，我们将这些组件分为：基础组件和业务组件。后面在介绍模块化的时候会有进一步的描述。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>自从 Oasis Feng 在去年的 MDCC2016 上分享了模块化的经验后，模块化在 Android 社区越来越多的被提起。我们自然也不落俗的去做了一些研究和探索。安居客现在面临很多问题：例如全量编译时间太长（我这台13款的 MacBook Pro 上打一次包得花十多分钟）；例如新房、二手房、租房等等模块间耦合严重，不利于多团队并行开发测试；另外在17年初公司重新将租房 App 捡起推广，单独让人来开发维护一个三年前的项目并不划算，所以我们希望能直接从现在的安居客用户端中拆分出租房模块作为一个单独的 App 发布上线。这样看来模块化似乎是一个不错的选择。</p>
<p>所以我们做模块化的目的大致是这样的：</p>
<ul>
<li>业务模块间解耦</li>
<li>单个业务模块单独编译打包，加快编译速度</li>
<li>多团队间并行开发、测试</li>
<li>解决好租App需要单独维护的问题，降低研发成本</li>
</ul>
<blockquote>
<p>15年 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 还在安居客的时候开发了一套插件化框架，但受限于当时的团队规模并且插件化对整个项目的改造太大，因此在安居客团队中插件化并未实施下来。而模块化其实是个很好的过渡方案，将项目按照模块拆分后各业务模块间解耦的问题不存在了，后续如有必要，再进行插件化改造只不过是水到渠成的事。</p>
</blockquote>
<p>来看看安居客用户 App 的模块化设计图：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/modularization1.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>整个项目分为三层，从下往上分别是：</p>
<ul>
<li>Basic Component Layer: 基础组件层，顾名思义就是一些基础组件，包含了各种开源库以及和业务无关的各种自研工具库；</li>
<li>Business Component Layer: 业务组件层，这一层的所有组件都是业务相关的，例如上图中的支付组件 AnjukePay、数据模拟组件 DataSimulator 等等；</li>
<li>Business Module Layer: 业务 Module 层，在 Android Studio 中每块业务对应一个单独的 Module。例如安居客用户 App 我们就可以拆分成新房 Module、二手房 Module、IM Module 等等，每个单独的 Business Module 都必须准遵守前面提到的 MVP 架构。</li>
</ul>
<p>同时针对模块化我们也需要定义一些自己的游戏规则:</p>
<ul>
<li>对于 Business Module Layer，各业务模块之间的通讯跳转采用路由框架 Router 来实现（可能会采用成熟的开源库，也可能会选择重复造轮子）;</li>
<li>对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，对于有个性化需求的对外部提供接口让调用方定制;</li>
<li>合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分（这一点的灵感来源于 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 的文章）;</li>
<li>上层的公有的业务或者功能模块可以逐步下放到下层，合理把握好度就好；</li>
<li>各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。</li>
</ul>
<p>对于模块化项目，每个单独的 Business Module 都可以单独编译成 APK。在开发阶段需要单独打包编译，项目发布的时候又需要它作为项目的一个 Module 来整体编译打包。简单的说就是开发时是 Application，发布时是 Library。因此需要你在 Business Module 的 Gradle 配置文件中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isBuildModule.toBoolean())&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们需要把租房模块打包成一个单独的租房 App，像下面这样就好：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/modularization2.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>我们可以把 Basic Component Layer 和 Business Component Layer 放在一起看做是 Anjuke SDK，新的业务或者项目只需要依赖 Anjuke SDK 就好（这一点同样是受到了 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 文章的启发）。甚至我们可以做得更极致一些，开发一套自己的组件管理平台，业务方可以根据自己的需求选择自己需要的组件，定制业务专属的 Anjuke SDK。业务端和 Anjuke SDK 的关系如下图所示：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/modularization3.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>最后看看安居客模块化的整体设计图：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/modularization4.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>模块化拆分对于安居客这种比较大型的商业项目而言，由于历史比较久远很多代码都运行五六年了；各个业务相互交叉耦合严重，所以实施起来还是有很大难度的。过程中难免会有预料不到的坑，这就需要我们对各个业务有较深的理解同时也要足够的耐心和细致。虽然辛苦，但是一旦完成模块化拆分对整个团队及公司业务上的帮助是很大的。</p>
<p>以上是我的简单总结以及对模块化的一些思考，不足之处还望大家批评指正。后面模块化的 Demo 完善后我会把它放到 GitHub，并再出一篇文章详细介绍模块化的设计实现细节。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://www.csdn.net/article/2015-12-16/2826499-android-app-architecture?locationNum=7&amp;fps=1" target="_blank" rel="external">http://www.csdn.net/article/2015-12-16/2826499-android-app-architecture?locationNum=7&amp;fps=1</a></li>
<li><a href="http://www.trinea.cn/android/didi-internationalization-android-evolution/" target="_blank" rel="external">http://www.trinea.cn/android/didi-internationalization-android-evolution/</a></li>
<li><a href="https://www.tianmaying.com/tutorial/AndroidMVC" target="_blank" rel="external">https://www.tianmaying.com/tutorial/AndroidMVC</a></li>
<li><a href="https://www.diycode.cc/topics/362" target="_blank" rel="external">https://www.diycode.cc/topics/362</a></li>
<li><a href="https://github.com/MDCC2016/Android-Session-Slides/blob/master/02-From.Containerization.To.Modularity.pdf" target="_blank" rel="external">https://github.com/MDCC2016/Android-Session-Slides/blob/master/02-From.Containerization.To.Modularity.pdf</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/Blog/Framework/Android/header.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文已授权微信公众号 AndroidDeveloper 独家发布。&lt;/p&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;入职安居客三年从工程师到 Team Leader，见证了 Android 团队一路走来的发展历程。因此有心将这些记录下来与大家分享，也算是对自己三年来一部分工作的总结。希望对大家有所帮助，更希望能得到大家宝贵的建议。&lt;br&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://baronzhang.com/categories/Framework/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://baronzhang.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>神兵利器Dagger2</title>
    <link href="http://baronzhang.com//blog/OpenSource/Java/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8Dagger2/"/>
    <id>http://baronzhang.com//blog/OpenSource/Java/神兵利器Dagger2/</id>
    <published>2017-02-06T10:58:18.000Z</published>
    <updated>2019-08-19T12:56:35.814Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。</p>
<p>Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。</p>
<p>起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。</p>
<a id="more"></a>
<h2 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h2><p>那么什么是依赖注入呢？在解释这个概念前我们先看一小段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</div><div class="line">		engine = <span class="keyword">new</span> Engine();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段Java代码中Car类持有了对Engine实例的引用，我们称之为Car类对Engine类有一个依赖。而依赖注入则是指通过注入的方式实现类与类之间的依赖，下面是常见的三种依赖注入的方式：</p>
<h3 id="1-构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。"><a href="#1-构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。" class="headerlink" title="1. 构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。"></a>1. 构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-接口注入：实现接口方法，同样以传参的方式实现注入。"><a href="#2-接口注入：实现接口方法，同样以传参的方式实现注入。" class="headerlink" title="2. 接口注入：实现接口方法，同样以传参的方式实现注入。"></a>2. 接口注入：实现接口方法，同样以传参的方式实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Injection</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Injection</span>&lt;<span class="title">Engine</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Engine engine)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。"><a href="#3-注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。" class="headerlink" title="3. 注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。"></a>3. 注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Inject</span></div><div class="line">	Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前两种注入方式需要我们编写大量的模板代码，而机智的Dagger2则是通过Java注解在编译期来实现依赖注入的。</p>
<h2 id="为什么需要依赖注入"><a href="#为什么需要依赖注入" class="headerlink" title="为什么需要依赖注入"></a>为什么需要依赖注入</h2><p>我们之所是要依赖注入，最重要的就是为了解耦，达到高内聚低耦合的目的，保证代码的健壮性、灵活性和可维护性。</p>
<p>下面我们看看同一个业务的两种实现方案：</p>
<h3 id="1-方案A"><a href="#1-方案A" class="headerlink" title="1. 方案A"></a>1. 方案A</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line">	<span class="keyword">private</span> List&lt;Wheel&gt; wheels;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</div><div class="line">		engine = <span class="keyword">new</span> Engine();</div><div class="line">		wheels = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</div><div class="line">			wheels.add(<span class="keyword">new</span> Wheel());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> start&#123;</div><div class="line">		System.out.println(<span class="string">"启动汽车"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarTest</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		Car car = <span class="keyword">new</span> Car();</div><div class="line">		car.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-方案B"><a href="#2-方案B" class="headerlink" title="2. 方案B"></a>2. 方案B</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line">	<span class="keyword">private</span> List&lt;Wheel&gt; wheels;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine, List&lt;Wheel&gt; wheels)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">		<span class="keyword">this</span>.wheels = wheels;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> start&#123;</div><div class="line">		System.out.println(<span class="string">"启动汽车"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarTest</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">		Engine engine = <span class="keyword">new</span> Engine();</div><div class="line">		List&lt;Wheel&gt; wheels = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</div><div class="line">			wheels.add(<span class="keyword">new</span> Wheel());</div><div class="line">		&#125;</div><div class="line">		Car car = <span class="keyword">new</span> Car(engine, wheels);</div><div class="line">		car.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方案A：由于没有依赖注入，因此需要我们自己是在Car的构造函数中创建Engine和Wheel对象。</p>
<p>方案B：我们手动以构造函数的方式注入依赖，将engine和wheels作为参数传入而不是在Car的构造函数中去显示的创建。</p>
<p>方案A明显丧失了灵活性，一切依赖都是在Car类的内部创建，Car与Engine和Wheel严重耦合。一旦Engine或者Wheel的创建方式发生了改变，我们就必须要去修改Car类的构造函数（比如说现在创建Wheel实例的构造函数改变了，需要传入Rubber（橡胶）了）；另外我们也没办法替换动态的替换依赖实例（比如我们想把Car的Wheel（轮胎）从邓禄普（轮胎品牌）换成米其林（轮胎品牌）的）。这类问题在大型的商业项目中则更加严重，往往A依赖B、B依赖C、C依赖D、D依赖E；一旦稍有改动便牵一发而动全身，想想都可怕！而依赖注入则很好的帮我们解决了这一问题。</p>
<h2 id="为什么是Dagger2"><a href="#为什么是Dagger2" class="headerlink" title="为什么是Dagger2"></a>为什么是Dagger2</h2><p>无论是构造函数注入还是接口注入，都避免不了要编写大量的模板代码。机智的猿猿们当然不开心做这些重复性的工作，于是各种依赖注入框架应用而生。但是这么多的依赖注入框架为什么我们却偏爱Dagger2呢？我们先从Spring中的控制反转（IOC）说起。</p>
<p>谈起依赖注入，做过J2EE开发的同学一定会想起Spring IOC，那通过迷之XML来配置依赖的方式真的很让人讨厌；而且XML与Java代码分离也导致代码链难以追踪。之后更加先进的Guice（Android端也有个RoboGuice）出现了，我们不再需要通过XML来配置依赖，但其运行时实现注入的方式让我们在追踪和定位错误的时候却又万分痛苦。开篇提到过Dagger就是受Guice的启发而开发出来的；Dagger继承了前辈的思想，在性能又碾压了它的前辈Guice，可谓是长江后浪推前浪，前浪死在沙滩上。</p>
<p>又如开篇我在简介中说到的，Dagger是一种半静态半运行时的DI框架，虽说依赖注入是完全静态的，但是生成有向无环图(DAG)还是基于反射来实现，这无论在大型的服务端应用还是在Android应用上都不是最优方案。升级版的Dagger2解决了这一问题，从半静态变为完全静态，从Map式的API变成申明式API（@Module），生成的代码更优雅高效；而且一旦出错我们在编译期间就能发现。所以Dagger2对开发者的更加友好了，当然Dagger2也因此丧失了一些灵活性，但总体来说利还是远远大于弊的。</p>
<p>前面提到这种A B C D E连续依赖的问题，一旦E的创建方式发生了改变就会引发连锁反应，可能会导致A B C D都需要做针对性的修改；但是骚年，你以为为这仅仅是工作量的问题吗？更可怕的是我们创建A时需要按顺序先创建E D C B四个对象，而且必须保证顺序上是正确的。Dagger2就很好的解决了这一问题（不只是Dagger2，在其他DI框架中开发者同样不需要关注这些问题）。</p>
<h2 id="Dagger2注解"><a href="#Dagger2注解" class="headerlink" title="Dagger2注解"></a>Dagger2注解</h2><p>开篇我们就提到Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。</p>
<ul>
<li><p>@Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；</p>
</li>
<li><p>@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。</p>
</li>
<li><p>@Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；</p>
</li>
<li><p>@Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入；</p>
</li>
<li><p>@Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。—-一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；</p>
</li>
<li><p>@Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例；</p>
</li>
<li><p>@Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。</p>
</li>
</ul>
<p>我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下：</p>
<ul>
<li>步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。</li>
<li>步骤2：若存在提供依赖的方法，查看该方法是否存在参数。<ul>
<li>a：若存在参数，则按从步骤1开始依次初始化每个参数；</li>
<li>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
</ul>
</li>
<li>步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。<ul>
<li>a：若存在参数，则从步骤1开始依次初始化每一个参数</li>
<li>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
</ul>
</li>
</ul>
<h2 id="Dagger2使用入门"><a href="#Dagger2使用入门" class="headerlink" title="Dagger2使用入门"></a>Dagger2使用入门</h2><p>前面长篇大论的基本都在介绍概念，下面我们看看Dagger2的基本应用。关于Dagger2的依赖配置就不在这里占用篇幅去描述了，大家可以到它的github主页下去查看官方教程<a href="https://github.com/google/dagger" target="_blank" rel="external">https://github.com/google/dagger</a>。接下来我们还是拿前面的Car和Engine来举例。</p>
<h3 id="1-案例A"><a href="#1-案例A" class="headerlink" title="1. 案例A"></a>1. 案例A</h3><p>Car类是需求依赖方，依赖了Engine类；因此我们需要在类变量Engine上添加@Inject来告诉Dagger2来为自己提供依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine engine;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engine;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Engine类是依赖提供方，因此我们需要在它的构造函数上添加@Inject</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine()&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"引擎转起来了~~~"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们需要创建一个用@Component标注的接口CarComponent，这个CarComponent其实就是一个注入器，这里用来将Engine注入到Car中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成这些之后我们需要Build下项目，让Dagger2帮我们生成相关的Java类。接着我们就可以在Car的构造函数中调用Dagger2生成的DaggerCarComponent来实现注入（这其实在前面Car类的代码中已经有了体现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">    DaggerCarComponent.builder().build().inject(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-案例B"><a href="#2-案例B" class="headerlink" title="2. 案例B"></a>2. 案例B</h3><p><strong>如果创建Engine的构造函数是带参数的呢？比如说制造一台引擎是需要齿轮(Gear)的。或者Eggine类是我们无法修改的呢？这时候就需要@Module和@Provide上场了。</strong></p>
<p>同样我们需要在Car类的成员变量Engine上加上@Inject表示自己需要Dagger2为自己提供依赖；Engine类的构造函数上的@Inject也需要去掉，应为现在不需要通过构造函数上的@Inject来提供依赖了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine engine;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engine;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们需要一个Module类来生成依赖对象。前面介绍的@Module就是用来标准这个类的，而@Provide则是用来标注具体提供依赖对象的方法（这里有个不成文的规定，被@Provide标注的方法命名我们一般以provide开头，这并不是强制的但有益于提升代码的可读性）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span> <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们还需要对CarComponent进行一点点修改，之前的@Component注解是不带参数的，现在我们需要加上<code>modules = {MarkCarModule.class}</code>，用来告诉Dagger2提供依赖的是<code>MarkCarModule</code>这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Car类的构造函数我们也需要修改，相比之前多了个<code>markCarModule(new MarkCarModule())</code>方法，这就相当于告诉了注入器<code>DaggerCarComponent</code>把<code>MarkCarModule</code>提供的依赖注入到了Car类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">   DaggerCarComponent.builder()</div><div class="line">           .markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">           .build().inject(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一个最最基本的依赖注入就完成了，接下来我们测试下我们的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line">    car.getEngine().run();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">引擎转起来了~~~</div></pre></td></tr></table></figure>
<h3 id="3-案例C"><a href="#3-案例C" class="headerlink" title="3. 案例C"></a>3. 案例C</h3><p>那么如果一台汽车有两个引擎（也就是说Car类中有两个Engine变量）怎么办呢？没关系，我们还有@Qulifier！首先我们需要使用Qulifier定义两个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> QualifierA &#123; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> QualifierB &#123; &#125;</div></pre></td></tr></table></figure>
<p>同时我们需要对依赖提供方做出修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierA</span></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngineA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gearA"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierB</span></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngineB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gearB"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来依赖需求方Car类同样需要修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierA</span> <span class="meta">@Inject</span> Engine engineA;</div><div class="line">    <span class="meta">@QualifierB</span> <span class="meta">@Inject</span> Engine engineB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineA;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineB;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们再对Engine类做些调整方便测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String gear;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String gear)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.gear = gear;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGearName</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"GearName:"</span> + gear);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line">    car.getEngineA().printGearName();</div><div class="line">    car.getEngineB().printGearName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GearName:gearA</div><div class="line">GearName:gearB</div></pre></td></tr></table></figure>
<h3 id="4-案例D"><a href="#4-案例D" class="headerlink" title="4. 案例D"></a>4. 案例D</h3><p>接下来我们看看@Scope是如何限定作用域，实现局部单例的。</p>
<p>首先我们需要通过@Scope定义一个CarScope注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scope</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CarScope &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们需要用这个@CarScope去标记依赖提供方MarkCarModule。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@CarScope</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时还需要使用@Scope去标注注入器Compoent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CarScope</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了便于测试我们对Car和Engine类做了一些改造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span> Engine engineA;</div><div class="line">    <span class="meta">@Inject</span> Engine engineB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder()</div><div class="line">                .markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String gear;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String gear)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Create Engine"</span>);</div><div class="line">        <span class="keyword">this</span>.gear = gear;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们不适用@Scope,上面的代码会实例化两次Engine类，因此会有两次\”Create Engine\”输出。现在我们在有@Scope的情况测试下劳动成果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line"></div><div class="line">    System.out.println(car.engineA.hashCode());</div><div class="line">    System.out.println(car.engineB.hashCode());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Create Engine</div></pre></td></tr></table></figure>
<p>bingo！我们确实通过@Scope实现了局部的单例。</p>
<h2 id="Dagger2原理分析"><a href="#Dagger2原理分析" class="headerlink" title="Dagger2原理分析"></a>Dagger2原理分析</h2><p>前面啰里啰嗦的介绍了Dagger2的基本使用，接下来我们再分析分析实现原理。这里不会分析Dagger2根据注解生成各种代码的原理，关于Java注解以后有机会再写一篇文章来介绍。后面主要分析的是Dagger2生成的各种类如何帮我们实现依赖注入，为了便于理解我这里选了前面相对简单的<strong>案例B</strong>来做分析。</p>
<p>Dagger2编译期生成的代码位于<code>build/generated/source/apt/debug/your package name/</code>下面:<br><img src="http://resources.baronzhang.com/Blog/OpenSource/Android/Dagger2/generated_code.png" alt="Generated Code"></p>
<p>首先我们看看Dagger2依据依赖提供方<code>MarkCarModule</code>生成的对应工厂类<code>MarkCarModule_ProvideEngineFactory</code>。为了方便大家理解对比，后面我一律会把自己写的类和Dagger2生成的类一并放出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 我们自己的类</div><div class="line">*/</div><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span> <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Dagger2生成的工厂类</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule_ProvideEngineFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Engine</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MarkCarModule <span class="keyword">module</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule_ProvideEngineFactory</span><span class="params">(MarkCarModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> <span class="keyword">module</span> != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = <span class="keyword">module</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Engine <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">        <span class="keyword">module</span>.provideEngine(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Engine&gt; <span class="title">create</span><span class="params">(MarkCarModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarkCarModule_ProvideEngineFactory(<span class="keyword">module</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Proxies &#123;<span class="doctag">@link</span> MarkCarModule#provideEngine()&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Engine <span class="title">proxyProvideEngine</span><span class="params">(MarkCarModule instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance.provideEngine();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到<code>MarkCarModule_ProvideEngineFactory</code>中的get()调用了<code>MarkCarModule</code>的<code>provideEngine()</code>方法来获取我们需要的依赖<code>Engine</code>，<code>MarkCarModule_ProvideEngineFactory</code>的实例化有<code>crate()</code>创建，并且<code>MarkCarModule</code>的实例也是通过<code>create()</code>方法传进来的。那么这个<code>create()</code>一定会在哪里调用的，我们接着往下看。</p>
<p>前面提到@Component是依赖提供方(MarkCarModule)和依赖需求方(Car)之前的桥梁，那我看看Dagger2是如何通过CarComponent将两者联系起来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 我们自己的类</div><div class="line">*/</div><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Dagger2生成的CarComponent实现类</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerCarComponent</span> <span class="keyword">implements</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Engine&gt; provideEngineProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;Car&gt; carMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerCarComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CarComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.provideEngineProvider = MarkCarModule_ProvideEngineFactory.create(builder.markCarModule);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.carMembersInjector = Car_MembersInjector.create(provideEngineProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span> </span>&#123;</div><div class="line">    carMembersInjector.injectMembers(car);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MarkCarModule markCarModule;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> CarComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (markCarModule == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.markCarModule = <span class="keyword">new</span> MarkCarModule();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerCarComponent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">markCarModule</span><span class="params">(MarkCarModule markCarModule)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.markCarModule = Preconditions.checkNotNull(markCarModule);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码我们看到Dagger2依据<code>CarComponent</code>接口生成了实现类<code>DaggerCarComponent</code>（没错这正是我们在Car的构造函数中使用DaggerCarComponent）。<code>DaggerCarComponent</code>在build的时候实例化了<code>DaggerCarComponent</code>对象，并首先调用<code>MarkCarModule_ProvideEngineFactory.create(builder.markCarModule)</code>始化了<code>provideEngineProvider</code>变量，接着调用<code>Car_MembersInjector.create(provideEngineProvider)</code>初始化了<code>carMembersInjector</code>变量。当我们手动在Car类的构造函数中调用<code>inject(Car car)</code>方法时会执行<code>carMembersInjector.injectMembers(car)</code>。所以接下来我们要看看<code>Car_MembersInjector</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Car_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;Engine&gt; engineProvider;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car_MembersInjector</span><span class="params">(Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> engineProvider != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.engineProvider = engineProvider;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MembersInjector&lt;Car&gt; <span class="title">create</span><span class="params">(Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car_MembersInjector(engineProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(Car instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</div><div class="line">    &#125;</div><div class="line">    instance.engine = engineProvider.get();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectEngine</span><span class="params">(Car instance, Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    instance.engine = engineProvider.get();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Car_MembersInjector</code>中的<code>create()</code>用于实例化自己，这个方法前面我们看到是在<code>DaggerCarComponent</code>中调用的。<code>injectMembers(Car instance)</code>将<code>engineProvider.get()</code>的返回值赋给了依赖需求方Car的engine变量，而<code>engineProvider.get()</code>正是本节一开始我们提到的<code>MarkCarModule_ProvideEngineFactory</code>中的<code>get()</code>方法。至此整个依赖注入的流程就完成了。更复杂的应用场景会生成更加复杂的代码，但原理都和前面分析的大同小异。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章只是通过一些简单的例子介绍了Dagger2的相关概念及使用，实际项目中的应用远比这里的例子要复杂。关于Dagger2在实际项目中的应用可以参照这个开源项目 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">https://github.com/BaronZ88/MinimalistWeather</a>（项目采用MVP架构，其中View层和Presenter层的解耦就是通过Dagger2来实现的）。</p>
<blockquote>
<p><a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>是一款开源天气App，开发此项目主要是为展示各种开源库的使用方式以及Android项目的架构方案，并作为团队开发规范的一部分。项目中每一个字母、每一个命名、每一行代码都是经过仔细考究的；但是由于时间精力有限，项目UI未做严格要求。本着精益求精、提供更好开源项目和更美天气应用的原则，因此期望有兴趣的开发和UED同学可以一起来完成这个项目。</p>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。&lt;/p&gt;
&lt;p&gt;Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。&lt;/p&gt;
&lt;p&gt;起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenSource" scheme="http://baronzhang.com/categories/OpenSource/"/>
    
      <category term="Java" scheme="http://baronzhang.com/categories/OpenSource/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="依赖注入" scheme="http://baronzhang.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="开源框架" scheme="http://baronzhang.com/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E4%B8%80%E4%B8%AARxJava%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例/</id>
    <published>2017-02-05T16:30:27.000Z</published>
    <updated>2019-08-19T12:56:35.813Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：</p>
<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>拿<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>这个开源的天气App来举例：</p>
<a id="more"></a>
<p>进入App首页后，首先我们需要从数据库中获取当前城市的天气数据，如果数据库中存在天气数据则在UI页面上展示天气数据；如果数据库中未存储当前城市的天气数据，或者已存储的天气数据的发布时间相比现在已经超过了一小时，并且网络属于连接状态则调用API从服务端获取天气数据。如果获取到到的天气数据发布时间和当前数据库中的天气数据发布时间一致则丢弃掉从服务端获取到的天气数据，如果不一致则更新数据库并且在页面上展示最新的天气信息。（同时天气数据源是可配置的，可选择是小米天气数据源还是Know天气数据源）</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先我们需要创建一个从数据库获取天气数据的Observable <code>observableForGetWeatherFromDB</code>，同时我们也需要创建一个从API获取天气数据的Observable <code>observableForGetWeatherFromNetWork</code>；为了在无网络状态下免于创建<code>observableForGetWeatherFromNetWork</code>我们在这之前需要首先判断下网络状态。最后使用<code>contact</code>操作符将两个Observable合并，同时使用<code>distinct</code>和<code>takeUntil</code>操作符来过滤筛选数据以符合业务需求，然后结合<code>subscribeOn</code>和<code>observeOn</code>做线程切换。上述这一套复杂的业务逻辑如果使用传统编码方式将是极其复杂的。下面我们来看看使用RxJava如何清晰简洁的来实现这个复杂的业务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class="line"><span class="comment">//首先创建一个从数据库获取天气数据的Observable</span></div><div class="line">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Weather weather = weatherDao.queryWeather(cityId);</div><div class="line">            subscriber.onNext(weather);</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class="line">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//接着创建一个从网络获取天气数据的Observable</span></div><div class="line">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span> (configuration.getDataSourceType()) &#123;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class="line">                    .map(<span class="keyword">new</span> Func1&lt;KnowWeather, Weather&gt;() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> Weather <span class="title">call</span><span class="params">(KnowWeather knowWeather)</span> </span>&#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> KnowWeatherAdapter(knowWeather).getWeather();</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class="line">                    .map(<span class="keyword">new</span> Func1&lt;MiWeather, Weather&gt;() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> Weather <span class="title">call</span><span class="params">(MiWeather miWeather)</span> </span>&#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> MiWeatherAdapter(miWeather).getWeather();</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> observableForGetWeatherFromNetWork != <span class="keyword">null</span>;</div><div class="line">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class="line">            .doOnNext(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            weatherDao.insertOrUpdateWeather(weather);</div><div class="line">                        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//使用concat操作符将两个Observable合并</span></div><div class="line">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class="line">            .filter(<span class="keyword">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> weather != <span class="keyword">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId());</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .distinct(<span class="keyword">new</span> Func1&lt;Weather, Long&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> weather.getRealTime().getTime();<span class="comment">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .takeUntil(<span class="keyword">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;<span class="comment">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                displayWeatherInformation();</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">                Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>上面的代码看起来比较复杂，我们采用Lambda表达式简化下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class="line"><span class="comment">//首先创建一个从数据库获取天气数据的Observable</span></div><div class="line">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Weather weather = weatherDao.queryWeather(cityId);</div><div class="line">            subscriber.onNext(weather);</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class="line">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//接着创建一个从网络获取天气数据的Observable</span></div><div class="line">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span> (configuration.getDataSourceType()) &#123;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class="line">                    .map(knowWeather -&gt; <span class="keyword">new</span> KnowWeatherAdapter(knowWeather).getWeather());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class="line">                    .map(miWeather -&gt; <span class="keyword">new</span> MiWeatherAdapter(miWeather).getWeather());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> observableForGetWeatherFromNetWork != <span class="keyword">null</span>;</div><div class="line">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class="line">            .doOnNext(weather -&gt; Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    weatherDao.insertOrUpdateWeather(weather);</div><div class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">                &#125;</div><div class="line">            &#125;));</div><div class="line"></div><div class="line">    <span class="comment">//使用concat操作符将两个Observable合并</span></div><div class="line">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class="line">            .filter(weather -&gt; weather != <span class="keyword">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId()))</div><div class="line">            .distinct(weather -&gt; weather.getRealTime().getTime())<span class="comment">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class="line">            .takeUntil(weather -&gt; System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);<span class="comment">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(weather -&gt; displayWeatherInformation(),</div><div class="line">                throwable -&gt; Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show());</div></pre></td></tr></table></figure>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>在上述的实现中有几点是我们需要注意的:</p>
<ol>
<li><p>为什么我需要在判断网络那块整个if else？这样看起来很不优雅，我们通过RxJava符完全可以实现同样的操作啊！之所以这样做是为了在无网络状况下去创建不必要的Observable <code>observableForGetWeatherFromNetWork</code>;</p>
</li>
<li><p>更新数据库的操作不应该阻塞更新UI，因此我们在<code>observableForGetWeatherFromNetWork</code>的<code>doOnNext</code>中需要通过<code>Schedulers.io().createWorker()</code>去另起一条线程，以此保证更新数据库不会阻塞更新UI的操作。</p>
<blockquote>
<p>有同学可能会问为什么不在<code>doOnNext</code>之后再调用一次<code>observeOn</code>把更新数据库的操作切换到一条新的子线程去操作呢？其实一开始我也是这样做的，后来想想不对。整个Observable的事件传递处理就像是在一条流水线上完成的，虽然我们可以通过<code>observeOn</code>来指定子线程去处理更新数据库的操作，但是只有等这条子线程完成了更新数据库的任务后事件才会继续往后传递，这样就阻塞了更新UI的操作。对此有疑问的同学可以去看看我之前关于RxJava源码分析的文章或者自己动手debug看看。</p>
</blockquote>
</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最后给大家留个两个问题：</p>
<ol>
<li>上述代码是最佳实现方案吗？还有什么更加合理的做法？</li>
<li>我们在<code>observableForGetWeatherData</code>中使用<code>distinct</code>和<code>takeUntil</code>过滤筛选天气数据的时候网络请求会不会已经发出去了？这样做还有意义吗？</li>
</ol>
<p>欢迎大家留言讨论。</p>
<blockquote>
<p>本文中的代码在<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>中的<code>WeatherDataRepository</code>类中有同样的实现，文章中为了更完整的将整个实现过程呈现出来，对代码做了部分改动。</p>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h2&gt;&lt;p&gt;拿&lt;a href=&quot;https://github.com/BaronZ88/MinimalistWeather&quot;&gt;MinimalistWeather&lt;/a&gt;这个开源的天气App来举例：&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列7(最佳实践)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%977-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列7-最佳实践/</id>
    <published>2017-02-05T16:22:03.000Z</published>
    <updated>2019-08-19T12:56:35.811Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<hr>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。</p>
<blockquote>
<p>按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。</p>
</blockquote>
<a id="more"></a>
<h2 id="示例一、获取手机上已安装的App"><a href="#示例一、获取手机上已安装的App" class="headerlink" title="示例一、获取手机上已安装的App"></a>示例一、获取手机上已安装的App</h2><p>第一个例子我们需要在Android设备上展示已安装的第三方app列表，关于环境搭建、依赖配置、RecyclerView的使用等这些基础内容我就不做陈述了。需要了解的同学可以去GitHub上把项目clone下来看看。这里我主要讲讲如何通过RxJava实现核心功能。</p>
<p>首选我们需要调用系统api来获取所有已安装的app，所以在<code>OnSubscribe</code>的<code>call</code>方法中调用<code>getApplicationInfoList()</code>。但是<code>getApplicationInfoList()</code>获取的数据并不能完全满足我们的业务需求：</p>
<ol>
<li>由于我们只需要展示手机上已安装的第三方App，因此需要通过<code>filter</code>操作符来过滤掉系统app；</li>
<li><code>ApplicationInfo</code>并不是我们所需要的类型，因此需要通过<code>map</code>操作符将其转换为<code>AppInfo</code>；</li>
<li>由于获取<code>ApplicationInfo</code>、过滤数据、转换数据相对比较耗时，因此需要通过<code>subscribeOn</code>操作符将这一系列操作放到子线程中来处理；</li>
<li>而要将信息展示在页面上涉及到UI操作，因此需要通过<code>observeOn</code>操作符将<code>onNext</code>、<code>onCompleted</code>、<code>onError</code>调度到主线程，接着我们在这些方法中更新UI。</li>
</ol>
<p>下面是核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> PackageManager pm = MainActivity.<span class="keyword">this</span>.getPackageManager();</div><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;ApplicationInfo&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> ApplicationInfo&gt; subscriber)</span> </span>&#123;</div><div class="line">            List&lt;ApplicationInfo&gt; infoList = getApplicationInfoList(pm);</div><div class="line">            <span class="keyword">for</span> (ApplicationInfo info : infoList) &#123;</div><div class="line">                subscriber.onNext(info);</div><div class="line">            &#125;</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125;</div><div class="line">    &#125;).filter(<span class="keyword">new</span> Func1&lt;ApplicationInfo, Boolean&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;).map(<span class="keyword">new</span> Func1&lt;ApplicationInfo, AppInfo&gt;() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> AppInfo <span class="title">call</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class="line">            AppInfo info = <span class="keyword">new</span> AppInfo();</div><div class="line">            info.setAppIcon(applicationInfo.loadIcon(pm));</div><div class="line">            info.setAppName(applicationInfo.loadLabel(pm).toString());</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125;</div><div class="line">    &#125;).subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;AppInfo&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            mAppListAdapter.notifyDataSetChanged();</div><div class="line">            mPullDownSRL.setRefreshing(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            mPullDownSRL.setRefreshing(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</div><div class="line">            mAppInfoList.add(appInfo);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>程序执行效果图：</p>
<div align="left"><img src="http://resources.baronzhang.com/rxjava/7/pic1.png" width="38%" alt="图片名称" align="center"></div>

<p>完整的代码我放到了GitHub上，有兴趣大家可以去clone下来自己运行看看。</p>
<p>源码地址：<a href="https://github.com/BaronZ88/HelloRxAndroid" target="_blank" rel="external">https://github.com/BaronZ88/HelloRxAndroid</a></p>
<h2 id="示例二、RxJava-Retrofit2实现获取天气数据"><a href="#示例二、RxJava-Retrofit2实现获取天气数据" class="headerlink" title="示例二、RxJava+Retrofit2实现获取天气数据"></a>示例二、RxJava+Retrofit2实现获取天气数据</h2><p>RxJava + Retrofit2几乎是Android应用开发的标配了，这个例子中我们就来聊聊这二者是如何配合起来帮助我们快速开发的。</p>
<p>Retrofit2中一个标准的接口定义是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"weather"</span>)</div><div class="line"><span class="function">Observable&lt;Weather&gt; <span class="title">getWeather</span><span class="params">(@Query(<span class="string">"cityId"</span>)</span> String cityId)</span>;</div></pre></td></tr></table></figure>
<p>现在有了RxJava，一个基本的网络请求我们便可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ApiClient.weatherService.getWeather(cityId)</div><div class="line">             	.subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                        weatherView.displayWeatherInformation(weather);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<p>但有时候可能一开始我们并不知道cityId，我们只知道cityName。所以就需要我们先访问服务器，拿到对应城市名的cityId，然后通过这个cityId再去获取天气数据。</p>
<p>同样的，我们需要定义一个获取cityId的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"city"</span>)</div><div class="line"><span class="function">Observable&lt;String&gt; <span class="title">getCityIdByName</span><span class="params">(@Query(<span class="string">"cityName"</span>)</span> String cityName)</span>;</div></pre></td></tr></table></figure>
<p>紧接着我们便可以使用无所不能的RxJava来实现需求了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ApiClient.weatherService.getCityIdByName(<span class="string">"上海"</span>)</div><div class="line">			 .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;Weather&gt;&gt;() &#123;</div><div class="line">			     <span class="meta">@Override</span></div><div class="line">			     <span class="function"><span class="keyword">public</span> Observable&lt;Weather&gt; <span class="title">call</span><span class="params">(String cityId)</span> </span>&#123;</div><div class="line">			         <span class="keyword">return</span> ApiClient.weatherService.getWeather(cityId);</div><div class="line">			     &#125;</div><div class="line">			 &#125;).subscribeOn(Schedulers.io())</div><div class="line">			 .observeOn(AndroidSchedulers.mainThread())</div><div class="line">			 .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">			     <span class="meta">@Override</span></div><div class="line">			     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">			         weatherView.displayWeatherInformation(weather);</div><div class="line">			     &#125;</div><div class="line">			 &#125;);</div></pre></td></tr></table></figure>
<p>哇哦！~ so easy！！！妈妈再也不用担心….</p>
<p>源码地址：<a href="https://github.com/BaronZ88/WeatherStyle" target="_blank" rel="external">https://github.com/BaronZ88/WeatherStyle</a></p>
<blockquote>
<p><a href="(https://github.com/BaronZ88/WeatherStyle">WeatherStyle</a>)这个项目还在开发中，这个项目不只包含了RxJava和Retrofit的使用，同时还包含MVP、ORMLite、RetroLambda、ButterKnife等等开源库的使用</p>
</blockquote>
<p>RxJava1.X的系列文章就到此结束了，由于本人对RxJava的理解有限，这一系列文章中如有错误还请大家指正。在使用RxJava过程中有任何疑问也欢迎大家和我交流。共同学习！共同进步！</p>
<p>好啦，我们RxJava2见！~</p>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列6(从微观角度解读RxJava源码)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%976-%E4%BB%8E%E5%BE%AE%E8%A7%82%E8%A7%92%E5%BA%A6%E8%A7%A3%E8%AF%BBRxJava%E6%BA%90%E7%A0%81/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/</id>
    <published>2017-02-05T16:21:05.000Z</published>
    <updated>2019-08-19T12:56:35.814Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<hr>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：</p>
<ul>
<li>RxJava基本流程分析</li>
<li>操作符原理分析</li>
<li>线程调度原理分析</li>
</ul>
<blockquote>
<p>本章节基于<strong>RxJava1.1.9</strong>版本的源码</p>
</blockquote>
<h2 id="一、RxJava执行流程分析"><a href="#一、RxJava执行流程分析" class="headerlink" title="一、RxJava执行流程分析"></a>一、RxJava执行流程分析</h2><p>在<a href="http://www.jianshu.com/p/ba61c047c230" target="_blank" rel="external">RxJava系列2(基本概念及使用介绍)</a>中我们介绍过，一个最基本的RxJava调用是这样的：</p>
<a id="more"></a>
<p><strong>示例A</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello RxJava!"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"completed!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>首先调用<code>Observable.create()</code>创建一个被观察者<code>Observable</code>，同时创建一个<code>OnSubscribe</code>作为<code>create()</code>方法的入参；接着创建一个观察者<code>Subscriber</code>，然后通过<code>subseribe()</code>实现二者的订阅关系。这里涉及到三个关键对象和一个核心的方法：</p>
<ul>
<li><strong>Observable</strong>（被观察者）</li>
<li><strong>OnSubscribe</strong> (从纯设计模式的角度来理解，<code>OnSubscribe.call()</code>可以看做是<a href="https://github.com/BaronZ88/Blog/blob/master/DesignPatterns/ObserverPattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="external">观察者模式</a>中被观察者用来通知观察者的<code>notifyObservers()</code>方法)</li>
<li><strong>Subscriber</strong> （观察者）</li>
<li><strong>subscribe()</strong> （实现观察者与被观察者订阅关系的方法）</li>
</ul>
<h3 id="1-Observable-create-源码分析"><a href="#1-Observable-create-源码分析" class="headerlink" title="1. Observable.create()源码分析"></a>1. Observable.create()源码分析</h3><p>首先我们来看看<code>Observable.create()</code>的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建了一个被观察者<code>Observable</code>，同时将<code>RxJavaHooks.onCreate(f)</code>作为构造函数的参数，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.onSubscribe = f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到源码中直接将参数<code>RxJavaHooks.onCreate(f)</code>赋值给了当前我们构造的被观察者<code>Observable</code>的成员变量<code>onSubscribe</code>。那么<code>RxJavaHooks.onCreate(f)</code>返回的又是什么呢？我们接着往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observable.<span class="function">OnSubscribe&lt;T&gt; <span class="title">onCreate</span><span class="params">(Observable.OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</div><div class="line">    Func1&lt;OnSubscribe, OnSubscribe&gt; f = onObservableCreate;</div><div class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> f.call(onSubscribe);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onSubscribe;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我们并没调用<code>RxJavaHooks.initCreate()</code>，所以上面代码中的<code>onObservableCreate</code>为null；因此<code>RxJavaHooks.onCreate(f)</code>最终返回的就是<code>f</code>，也就是我们在<code>Observable.create()</code>的时候new出来的<code>OnSubscribe</code>。（<em>由于对RxJavaHooks的理解并不影响我们对RxJava执行流程的分析，因此在这里我们不做进一步的探讨。为了方便理解我们只需要知道RxJavaHooks一系列方法的返回值就是入参本身就OK了，例如这里的<code>RxJavaHooks.onCreate(f)</code>返回的就是<code>f</code></em>）。</p>
<p>至此我们做下逻辑梳理：<strong><code>Observable.create()</code>方法构造了一个被观察者<code>Observable</code>对象，同时将new出来的<code>OnSubscribe</code>赋值给了该<code>Observable</code>的成员变量<code>onSubscribe</code>。</strong></p>
<h3 id="2-Subscriber源码分析"><a href="#2-Subscriber源码分析" class="headerlink" title="2. Subscriber源码分析"></a>2. Subscriber源码分析</h3><p>接着我们看下观察者<code>Subscriber</code>的源码，为了增加可读性，我去掉了源码中的注释和部分代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscriptionList subscriptions;<span class="comment">//订阅事件集，所有发送给当前Subscriber的事件都会保存在这里</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Subscriber</span><span class="params">(Subscriber&lt;?&gt; subscriber, <span class="keyword">boolean</span> shareSubscriptions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subscriber = subscriber;</div><div class="line">        <span class="keyword">this</span>.subscriptions = shareSubscriptions &amp;&amp; subscriber != <span class="keyword">null</span> ? subscriber.subscriptions : <span class="keyword">new</span> SubscriptionList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</div><div class="line">        subscriptions.unsubscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isUnsubscribed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> subscriptions.isUnsubscribed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isUnsubscribed</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Subscriber</code>实现了<code>Subscription</code>接口，从而对外提供<code>isUnsubscribed()</code>和<code>unsubscribe()</code>方法。前者用于判断是否已经取消订阅；后者用于将订阅事件列表(<em>也就是当前观察者的成员变量<code>subscriptions</code></em>)中的所有<code>Subscription</code>取消订阅，并且不再接受观察者<code>Observable</code>发送的后续事件。</p>
<h3 id="3-subscribe-源码分析"><a href="#3-subscribe-源码分析" class="headerlink" title="3. subscribe()源码分析"></a>3. subscribe()源码分析</h3><p>前面我们分析了观察者和被观察者相关的源码，那么接下来便是整个订阅流程中最最关键的环节了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">    subscriber.onStart();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</div><div class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>subscribe()</code>方法中将传进来的<code>subscriber</code>包装成了<code>SafeSubscriber</code>，<code>SafeSubscriber</code>其实是<code>subscriber</code>的一个代理，对<code>subscriber</code>的一系列方法做了更加严格的安全校验。保证了<code>onCompleted()</code>和<code>onError()</code>只会有一个被执行且只执行一次，一旦它们其中方法被执行过后<code>onNext()</code>就不在执行了。</p>
<p>上述代码中最关键的就是<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber)</code>。这里的RxJavaHooks和之前提到的一样，<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe)</code>返回的正是他的第二个入参<code>observable.onSubscribe</code>，也就是当前<code>observable</code>的成员变量<code>onSubscribe</code>。而这个成员变量我们前面提到过，它是我们在<code>Observable.create()</code>的时候new出来的。所以这段代码可以简化为<code>onSubscribe.call(subscriber)</code>。这也印证了我在<a href="http://www.jianshu.com/p/ba61c047c230" target="_blank" rel="external">RxJava系列2(基本概念及使用介绍)</a>中说的，<code>onSubscribe.call(subscriber)</code>中的<code>subscriber</code>正是我们在<code>subscribe()</code>方法中new出来的观察者。</p>
<p>到这里，我们对RxJava的执行流程做个总结：首先我们调用<code>crate()</code>创建一个观察者，同时创建一个<code>OnSubscribe</code>作为该方法的入参；接着调用<code>subscribe()</code>来订阅我们自己创建的观察者<code>Subscriber</code>。<br>一旦调用<code>subscribe()</code>方法后就会触发执行<code>OnSubscribe.call()</code>。然后我们就可以在call方法调用观察者<code>subscriber</code>的<code>onNext()</code>,<code>onCompleted()</code>,<code>onError()</code>。</p>
<p>最后我用张图来总结下之前的分析结果：</p>
<p><img src="http://resources.baronzhang.com/rxjava/6/OperatorProcess1.jpg" alt="RxJava基本流程分析"></p>
<h2 id="二、操作符原理分析"><a href="#二、操作符原理分析" class="headerlink" title="二、操作符原理分析"></a>二、操作符原理分析</h2><p>之前我们介绍过几十个操作符，要一一分析它们的源码显然不太现实。在这里我抛砖引玉，选取一个相对简单且常用的<code>map</code>操作符来分析。</p>
<p>我们先来看一个<code>map</code>操作符的简单应用：</p>
<p><strong>示例B</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="number">1</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"This is "</span> + integer;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onCompleted!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(e.getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了便于表述，我将上面的代码做了如下拆解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; observableA = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="number">1</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Subscriber&lt;String&gt; subscriberOne = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onCompleted!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(e.getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Observable&lt;String&gt; observableB =</div><div class="line">        observableA.map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">"This is "</span> + integer;;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">observableB.subscribe(subscriberOne);</div></pre></td></tr></table></figure>
<p><code>map()</code>的源码和上一小节介绍的<code>create()</code>一样位于<code>Observable</code>这个类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; func)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeMap&lt;T, R&gt;(<span class="keyword">this</span>, func));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过查看源码我们发现调用<code>map()</code>的时候实际上是创建了一个新的被观察者<code>Observable</code>，我们姑且称它为<code>ObservableB</code>；一开始通过<code>Observable.create()</code>创建的<code>Observable</code>我们称之为<code>ObservableA</code>。在创建<code>ObservableB</code>的时候同时创建了一个<code>OnSubscribeMap</code>，而<code>ObservableA</code>和变换函数<code>Func1</code>则作为构造<code>OnSubscribeMap</code>的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;<span class="comment">//ObservableA</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer;<span class="comment">//map操作符中的转换函数Func1。T为转换前的数据类型，在上面的例子中为Integer；R为转换后的数据类型，在该例中为String。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeMap</span><span class="params">(Observable&lt;T&gt; source, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">        <span class="keyword">this</span>.transformer = transformer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;<span class="comment">//结合第一小节的分析结果，我们知道这里的入参o其实就是我们自己new的观察者subscriberOne。</span></div><div class="line">        MapSubscriber&lt;T, R&gt; parent = <span class="keyword">new</span> MapSubscriber&lt;T, R&gt;(o, transformer);</div><div class="line">        o.add(parent);</div><div class="line">        source.unsafeSubscribe(parent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSubscriber</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; actual;<span class="comment">//这里的actual就是我们在调用subscribe()时创建的观察者mSubscriber</span></div><div class="line">        <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;<span class="comment">//变换函数</span></div><div class="line">        <span class="keyword">boolean</span> done;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MapSubscriber</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; actual, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.actual = actual;</div><div class="line">            <span class="keyword">this</span>.mapper = mapper;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">            R result;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                result = mapper.call(t);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                Exceptions.throwIfFatal(ex);</div><div class="line">                unsubscribe();</div><div class="line">                onError(OnErrorThrowable.addValueAsLastCause(ex, t));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            actual.onNext(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            actual.onError(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            actual.onCompleted();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(Producer p)</span> </span>&#123;</div><div class="line">            actual.setProducer(p);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OnSubscribeMap</code>实现了<code>OnSubscribe</code>接口，因此<code>OnSubscribeMap</code>就是一个<code>OnSubscribe</code>。在调用<code>map()</code>的时候创建了一个新的被观察者<code>ObservableB</code>，然后我们用<code>ObservableB.subscribe(subscriberOne)</code>订阅了观察者<code>subscriberOne</code>。结合我们在第一小节的分析结果，所以<code>OnSubscribeMap.call(o)</code>中的<code>o</code>就是<code>subscribe(subscriberOne)</code>中的<code>subscriberOne</code>；一旦调用了<code>ObservableB.subscribe(subscriberOne)</code>就会执行<code>OnSubscribeMap.call()</code>。</p>
<p>在<code>call()</code>方法中，首先通过我们的观察者<code>o</code>和转换函数<code>transformer</code>构造了一个<code>MapSubscriber</code>，最后调用了<code>source</code>也就是<code>observableA</code>的<code>unsafeSubscribe()</code>方法。即<code>observableA</code>订阅了一个观察者<code>MapSubscriber</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">unsafeSubscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ...</div><div class="line">        RxJavaHooks.onObservableStart(<span class="keyword">this</span>, onSubscribe).call(subscriber);</div><div class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码最终执行了<code>onSubscribe</code>也就是<code>OnSubscribeMap</code>的<code>call()</code>方法，<code>call()</code>方法中的参数就是之前在<code>OnSubscribeMap.call()</code>中new出来的<code>MapSubscriber</code>。最后在<code>call()</code>方法中执行了我们自己的业务代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subscriber.onNext(<span class="number">1</span>);</div><div class="line">subscriber.onCompleted();</div></pre></td></tr></table></figure>
<p>其实也就是执行了<code>MapSubscriber</code>的<code>onNext()</code>和<code>onCompleted()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    R result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = mapper.call(t);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    actual.onNext(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>onNext(T t)</code>方法中的的<code>mapper</code>就是变换函数，<code>actual</code>就是我们在调用<code>subscribe()</code>时创建的观察者<code>subscriberOne</code>。这个<code>T</code>就是我们例子中的<code>Integer</code>，<code>R</code>就是<code>String</code>。在<code>onNext()</code>中首先调用变换函数<code>mapper.call()</code>将<code>T</code>转换成<code>R</code>(在我们的例子中就是将<code>Integer</code>类型的<strong>1</strong>转换成了<code>String</code>类型的<strong>“This is 1”</strong>)；接着调用<code>subscriberOne.onNext(String result)</code>。同样在调用<code>MapSubscriber.onCompleted()</code>时会执行<code>subscriberOne.onCompleted()</code>。这样就完成了一直完成的调用流程。</p>
<p>我承认太啰嗦了，花费了这么大的篇幅才将<code>map()</code>的转换原理解释清楚。我也是希望尽量的将每个细节都呈现出来方便大家理解，如果看我啰嗦了这么久还是没能理解，请看下面我画的这张执行流程图。</p>
<p><img src="http://resources.baronzhang.com/rxjava/6/OperatorProcess3.jpg" alt="加入Map操作符后的执行流程"></p>
<h2 id="三、线程调度原理分析"><a href="#三、线程调度原理分析" class="headerlink" title="三、线程调度原理分析"></a>三、线程调度原理分析</h2><p>在前面的文章中我介绍过RxJava可以很方便的通过<code>subscribeOn()</code>和<code>observeOn()</code>来指定数据流的每一部分运行在哪个线程。其中<code>subscribeOn()</code>指定了处理<code>Observable</code>的全部的过程(包括发射数据和通知)的线程；<code>observeOn()</code>指定了观察者的<code>onNext()</code>, <code>onError()</code>和<code>onCompleted()</code>执行的线程。接下来我们就分析分析源码，看看线程调度是如何实现的。</p>
<p>在分析源码前我们先看看一段常见的通过RxJava实现的线程调度代码：</p>
<p><strong>示例C</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello RxJava!"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">.observeOn(AndroidSchedulers.mainThread())</div><div class="line">.subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"completed!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="1-subscribeOn-源码分析"><a href="#1-subscribeOn-源码分析" class="headerlink" title="1. subscribeOn()源码分析"></a>1. subscribeOn()源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码我们可以看到，<code>subscribeOn()</code>和<code>map()</code>一样是创建了一个新的被观察者<code>Observable</code>。因此我大致就能猜到<code>subscribeOn()</code>的执行流程应该和<code>map()</code>差不多，<code>OperatorSubscribeOn</code>肯定也是一个<code>OnSubscribe</code>。那我们接下来就看看<code>OperatorSubscribeOn</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Scheduler scheduler;<span class="comment">//线程调度器，用来指定订阅事件发送、处理等所在的线程</span></div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line">        subscriber.add(inner);</div><div class="line"></div><div class="line">        inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">final</span> Thread t = Thread.currentThread();</div><div class="line"></div><div class="line">                Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                        subscriber.onNext(t);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            subscriber.onError(e);</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            inner.unsubscribe();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            subscriber.onCompleted();</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            inner.unsubscribe();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(<span class="keyword">final</span> Producer p)</span> </span>&#123;</div><div class="line">                        subscriber.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">                                <span class="keyword">if</span> (t == Thread.currentThread()) &#123;</div><div class="line">                                    p.request(n);</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                                        <span class="meta">@Override</span></div><div class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                                            p.request(n);</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;);</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">                source.unsafeSubscribe(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorSubscribeOn</code>实现了<code>OnSubscribe</code>接口，<code>call()</code>中对<code>Subscriber</code>的处理也和<code>OperatorMap</code>对<code>Subscriber</code>的处理类似。首先通过<code>scheduler</code>构建了一个<code>Worker</code>；然后用传进来的<code>subscriber</code>构造了一个新的<code>Subscriber s</code>，并将<code>s</code>丢到<code>Worker.schedule()</code>中来处理；最后用原<code>Observable</code>去订阅观察者<code>s</code>。而这个<code>Worker</code>就是线程调度的关键！前面的例子中我们通过<code>subscribeOn(Schedulers.io())</code>指定了<code>Observable</code>发射处理事件以及通知观察者的一系列操作的执行线程，正是通过这个<code>Schedulers.io()</code>创建了我们前面提到的<code>Worker</code>。所以我们来看看<code>Schedulers.io()</code>的实现。</p>
<p>首先通过<code>Schedulers.io()</code>获得了<code>ioScheduler</code>并返回，上面的<code>OperatorSubscribeOn</code>通过这个的<code>Scheduler</code>的<code>createWorker()</code>方法创建了我们前面提到的<code>Worker</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">io</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> RxJavaHooks.onIOScheduler(getInstance().ioScheduler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们看看这个<code>ioScheduler</code>是怎么来的，下面的代码向我们展现了是如何在<code>Schedulers</code>的构造函数中通过<code>RxJavaSchedulersHook.createIoScheduler()</code>来初始化<code>ioScheduler</code>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Schedulers</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    Scheduler io = hook.getIOScheduler();</div><div class="line">    <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</div><div class="line">        ioScheduler = io;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ioScheduler = RxJavaSchedulersHook.createIoScheduler();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终<code>RxJavaSchedulersHook.createIoScheduler()</code>返回了一个<code>CachedThreadScheduler</code>，并赋值给了<code>ioScheduler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">createIoScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> createIoScheduler(<span class="keyword">new</span> RxThreadFactory(<span class="string">"RxIoScheduler-"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">createIoScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CachedThreadScheduler(threadFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这一步既然我们知道了<code>ioScheduler</code>就是一个<code>CachedThreadScheduler</code>，那我们就来看看它的<code>createWorker()</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码向我们赤裸裸的呈现了前面<code>OperatorSubscribeOn</code>中的<code>Worker</code>其实就是<code>EventLoopWorker</code>。我们重点要关注的是他的<code>scheduleActual()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeSubscription innerSubscription = <span class="keyword">new</span> CompositeSubscription();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</div><div class="line">    <span class="keyword">final</span> AtomicBoolean once;</div><div class="line"></div><div class="line">    EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class="line">        <span class="keyword">this</span>.pool = pool;</div><div class="line">        <span class="keyword">this</span>.once = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">        <span class="keyword">this</span>.threadWorker = pool.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        ScheduledAction s = threadWorker.scheduleActual(<span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (isUnsubscribed()) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                action.call();</div><div class="line">            &#125;</div><div class="line">        &#125;, delayTime, unit);</div><div class="line">        innerSubscription.add(s);</div><div class="line">        s.addParent(innerSubscription);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对源码的一步步追踪，我们知道了前面<code>OperatorSubscribeOn.call()</code>中的<code>inner.schedule()</code>最终会执行到<code>ThreadWorker</code>的<code>scheduleActual()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ScheduledAction <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class="line">    Action0 decoratedAction = RxJavaHooks.onScheduledAction(action);</div><div class="line">    ScheduledAction run = <span class="keyword">new</span> ScheduledAction(decoratedAction);</div><div class="line">    Future&lt;?&gt; f;</div><div class="line">    <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</div><div class="line">        f = executor.submit(run);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        f = executor.schedule(run, delayTime, unit);</div><div class="line">    &#125;</div><div class="line">    run.add(f);</div><div class="line">    <span class="keyword">return</span> run;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scheduleActual()</code>中的<code>ScheduledAction</code>实现了<code>Runnable</code>接口，通过线程池<code>executor</code>最终实现了线程切换。上面便是<code>subscribeOn(Schedulers.io())</code>实现线程切换的全部过程。</p>
<h3 id="2-observeOn-源码分析"><a href="#2-observeOn-源码分析" class="headerlink" title="2. observeOn()源码分析"></a>2. observeOn()源码分析</h3><p><code>observeOn()</code>切换线程是通过<code>lift</code>来实现的，相比<code>subscribeOn()</code>在实现原理上相对复杂些。不过本质上最终还是创建了一个新的<code>Observable</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorObserveOn</code>作为<code>OnSubscribeLift</code>构造函数的参数用来创建了一个新的<code>OnSubscribeLift</code>对象，接下来我们看看<code>OnSubscribeLift</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeLift</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; parent;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeLift</span><span class="params">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">        <span class="keyword">this</span>.operator = operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; st = RxJavaHooks.onObservableLift(operator).call(o);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                st.onStart();</div><div class="line">                parent.call(st);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                Exceptions.throwIfFatal(e);</div><div class="line">                st.onError(e);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            Exceptions.throwIfFatal(e);</div><div class="line">            o.onError(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OnSubscribeLift</code>继承自<code>OnSubscribe</code>，通过前面的分析我们知道一旦调用了<code>subscribe()</code>将观察者与被观察绑定后就会触发被观察者所对应的<code>OnSubscribe</code>的<code>call()</code>方法，所以这里会触发<code>OnSubscribeLift.call()</code>。在<code>call()</code>中调用了<code>OperatorObserveOn.call()</code>并返回了一个新的观察者<code>Subscriber st</code>，接着调用了前一级<code>Observable</code>对应<code>OnSubscriber.call(st)</code>。</p>
<p>我们再看看<code>OperatorObserveOn.call()</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">    ...</div><div class="line">    ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">    parent.init();</div><div class="line">    <span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorObserveOn.call()</code>中创建了一个<code>ObserveOnSubscriber</code>并调用<code>init()</code>进行了初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable e)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">            recursiveScheduler.schedule(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> missed = <span class="number">1L</span>;</div><div class="line">        <span class="keyword">long</span> currentEmission = emitted;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="keyword">this</span>.queue;</div><div class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = <span class="keyword">this</span>.child;</div><div class="line">        <span class="keyword">final</span> NotificationLite&lt;T&gt; localOn = <span class="keyword">this</span>.on;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">long</span> requestAmount = requested.get();</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</div><div class="line">                <span class="keyword">boolean</span> done = finished;</div><div class="line">                Object v = q.poll();</div><div class="line">                <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (checkTerminated(done, empty, localChild, q)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (empty) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                localChild.onNext(localOn.getValue(v));</div><div class="line"></div><div class="line">                currentEmission++;</div><div class="line">                <span class="keyword">if</span> (currentEmission == limit) &#123;</div><div class="line">                    requestAmount = BackpressureUtils.produced(requested, currentEmission);</div><div class="line">                    request(currentEmission);</div><div class="line">                    currentEmission = <span class="number">0L</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (requestAmount == currentEmission) &#123;</div><div class="line">                <span class="keyword">if</span> (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            emitted = currentEmission;</div><div class="line">            missed = counter.addAndGet(-missed);</div><div class="line">            <span class="keyword">if</span> (missed == <span class="number">0L</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ObserveOnSubscriber</code>继承自<code>Subscriber</code>，并实现了<code>Action0</code>接口。我们看到<code>ObserveOnSubscriber</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>都有个<code>schedule()</code>，这个方法就是我们线程调度的关键；通过<code>schedule()</code>将新观察者<code>ObserveOnSubscriber</code>发送给<code>subscriberOne</code>的所有事件都切换到了<code>recursiveScheduler</code>所对应的线程，简单的说就是把<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法丢到了<code>recursiveScheduler</code>对应的线程中来执行。</p>
<p>那么<code>schedule()</code>又是如何做到这一点的呢？他内部调用了<code>recursiveScheduler.schedule(this)</code>，<code>recursiveScheduler</code>其实就是一个<code>Worker</code>，和我们在介绍<code>subscribeOn()</code>时提到的<code>worker</code>一样，执行<code>schedule()</code>实际上最终是创建了一个<code>runable</code>，然后把这个<code>runnable</code>丢到了特定的线程池中去执行。在<code>runnable</code>的<code>run()</code>方法中调用了<code>ObserveOnSubscriber.call()</code>，看上面的代码大家就会发现在<code>call()</code>方法中最终调用了<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法。这便是它实现线程切换的原理。</p>
<p>好了，我们最后再看看<strong>示例C</strong>对应的执行流程图，帮助大家加深理解。</p>
<p><img src="http://resources.baronzhang.com/rxjava/6/OperatorProcess.jpg" alt="RxJava执行流程"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章以<strong>执行流程</strong>、<strong>操作符实现</strong>以及<strong>线程调度</strong>三个方面为切入点剖析了RxJava源码。下一章将站在更宏观的角度来分析整个RxJava的框架结构、设计思想等等。敬请期待~~ :)</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RxJava基本流程分析&lt;/li&gt;
&lt;li&gt;操作符原理分析&lt;/li&gt;
&lt;li&gt;线程调度原理分析&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;本章节基于&lt;strong&gt;RxJava1.1.9&lt;/strong&gt;版本的源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、RxJava执行流程分析&quot;&gt;&lt;a href=&quot;#一、RxJava执行流程分析&quot; class=&quot;headerlink&quot; title=&quot;一、RxJava执行流程分析&quot;&gt;&lt;/a&gt;一、RxJava执行流程分析&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;http://www.jianshu.com/p/ba61c047c230&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;中我们介绍过，一个最基本的RxJava调用是这样的：&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列5(组合操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%975-%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列5-组合操作符/</id>
    <published>2017-02-05T16:20:46.000Z</published>
    <updated>2019-08-19T12:56:35.813Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>   </li>
</ul>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<hr>
<p>这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： <strong><code>Merge</code></strong> <strong><code>StartWith</code></strong> <strong><code>Concat</code></strong> <strong><code>Zip</code></strong> <strong><code>CombineLatest</code></strong>  <strong><code>SwitchOnNext</code></strong> <strong><code>Join</code></strong>等等。</p>
<a id="more"></a>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><strong><code>merge(Observable, Observable)</code></strong>将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。</p>
<p><img src="http://resources.baronzhang.com/rxjava/operator/merge/MergeOperator.png" alt="merge(Observable, Observable)"></p>
<p>我们看下面的例子，一共有两个Observable：一个用来发送字母，另一个用来发送数字；现在我们需要两连个Observable发射的数据合并。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.merge(letterSequence, numberSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                System.out.print(serializable.toString()+<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A 0 B C 1 D E 2 F 3 G H 4
</code></pre><p><strong><code>merge(Observable[])</code></strong>将多个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。</p>
<p><img src="http://resources.baronzhang.com/rxjava/operator/merge/MergeIOOperator.png" alt="merge(Observable[])"></p>
<h3 id="StartWith"><a href="#StartWith" class="headerlink" title="StartWith"></a>StartWith</h3><p><strong><code>startWith(T)</code></strong>用于在源Observable发射的数据前插入数据。使用<strong><code>startWith(Iterable&lt;T&gt;)</code></strong>我们还可以在源Observable发射的数据前插入Iterable。官方示意图：<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/StartWithOperator.png" alt="startWith(T) startWith(Iterable&lt;T&gt;)"></p>
<p><strong><code>startWith(Observable&lt;T&gt;)</code></strong>用于在源Observable发射的数据前插入另一个Observable发射的数据（这些数据会被插入到<br>源Observable发射数据的前面）。官方示意图：<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/StartWithOOperator.png" alt="startWith(Observable&lt;T&gt;)"></p>
<h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p><strong><code>concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)</code></strong> <strong><code>concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;</code>)</strong>用于将多个obserbavle发射的的数据进行合并发射，concat严格按照顺序发射数据，前一个Observable没发射玩是不会发射后一个Observable的数据的。它和merge、startWitch和相似，不同之处在于：</p>
<ol>
<li>merge:合并后发射的数据是无序的；</li>
<li>startWitch:只能在源Observable发射的数据前插入数据。</li>
</ol>
<p><img src="http://resources.baronzhang.com/rxjava/operator/merge/ConcatOperator.png" alt="concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)、concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;)"></p>
<p>这里我们将前面Merge操作符的例子拿过来，并将操作符换成<code>Concat</code>，然后我们看看执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.concat(letterSequence, numberSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                System.out.print(serializable.toString() + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A B C D E F G H 0 1 2 3 4
</code></pre><h3 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h3><p><strong><code>zip(Observable, Observable, Func2)</code></strong>用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/ZipOperator.png" alt="zip(Observable, Observable, Func2)"></p>
<p>和前面的例子一样，我们将操作符换成了<code>zip</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">120</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">200</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.zip(letterSequence, numberSequence, <span class="keyword">new</span> Func2&lt;String, Long, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String letter, Long number)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> letter + number;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">        System.out.print(result + <span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A0 B1 C2 D3 E4
</code></pre><h3 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest"></a>CombineLatest</h3><p><strong><code>comnineLatest(Observable, Observable, Func2)</code></strong>用于将两个Observale最近发射的数据已经Func2函数的规则进展组合。下面是官方提供的原理图：<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/CombineLatestOperator.png" alt="comnineLatest(Observable, Observable, Func2)"></p>
<p>下面这张图应该更容易理解：<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/CombineLatest.png" alt="comnineLatest(Observable, Observable, Func2)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; communityNames = DataSimulator.getCommunityNames();</div><div class="line">List&lt;Location&gt; locations = DataSimulator.getLocations();</div><div class="line"></div><div class="line">Observable&lt;String&gt; communityNameSequence = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> communityNames.get(position.intValue());</div><div class="line">            &#125;</div><div class="line">        &#125;).take(communityNames.size());</div><div class="line">Observable&lt;Location&gt; locationSequence = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, Location&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Location <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> locations.get(position.intValue());</div><div class="line">            &#125;</div><div class="line">        &#125;).take(locations.size());</div><div class="line"></div><div class="line">Observable.combineLatest(</div><div class="line">        communityNameSequence,</div><div class="line">        locationSequence,</div><div class="line">        <span class="keyword">new</span> Func2&lt;String, Location, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String communityName, Location location)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"小区名:"</span> + communityName + <span class="string">", 经纬度:"</span> + location.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                System.out.println(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区名:竹园新村, 经纬度:(21.827, 23.323)
小区名:康桥半岛, 经纬度:(21.827, 23.323)
小区名:康桥半岛, 经纬度:(11.923, 16.309)
小区名:中粮·海景壹号, 经纬度:(11.923, 16.309)
小区名:中粮·海景壹号, 经纬度:(22.273, 53.623)
小区名:浦江名苑, 经纬度:(22.273, 53.623)
小区名:南辉小区, 经纬度:(22.273, 53.623)
</code></pre><h3 id="SwitchOnNext"><a href="#SwitchOnNext" class="headerlink" title="SwitchOnNext"></a>SwitchOnNext</h3><p><strong><code>switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;</code></strong>用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新<br>的小Observable所发射的数据。</p>
<p>结合下面的原理图大家应该很容易理解，我们可以看到下图中的黄色圆圈就被丢弃了。<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/SwitchOnNextOperator.png" alt="switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;)"></p>
<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p><strong><code>join(Observable, Func1, Func1, Func2)</code></strong>我们先介绍下join操作符的4个参数：</p>
<ul>
<li>Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；</li>
<li>Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；</li>
<li>Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；</li>
<li>Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。</li>
</ul>
<p>所以Join操作符的语法结构大致是这样的：<strong><code>onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)</code></strong></p>
<p>join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： <code>[0, B]</code> <code>[1, B]</code> <code>[2, B]</code> <code>[3, B]</code></p>
<p>再看看下面的图是不是好理解了呢？！<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/JoinOperator.png" alt="join(Observable, Func1, Func1, Func2)"></p>
<p>读懂了上面的文字，我们再来写段代码加深理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> List&lt;House&gt; houses = DataSimulator.getHouses();<span class="comment">//模拟的房源数据，用于测试</span></div><div class="line"></div><div class="line"><span class="comment">//用来每秒从houses总取出一套房源并发射出去</span></div><div class="line">Observable&lt;House&gt; houseSequence =</div><div class="line">        Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">                .map(<span class="keyword">new</span> Func1&lt;Long, House&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> House <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> houses.get(position.intValue());</div><div class="line">                    &#125;</div><div class="line">                &#125;).take(houses.size());<span class="comment">//这里的take是为了防止houses.get(position.intValue())数组越界</span></div><div class="line"></div><div class="line"><span class="comment">//用来实现每秒发送一个新的Long型数据</span></div><div class="line">Observable&lt;Long&gt; tictoc = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">houseSequence.join(tictoc,</div><div class="line">        <span class="keyword">new</span> Func1&lt;House, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">0</span>, TimeUnit.SECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func2&lt;House, Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house, Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> aLong + <span class="string">"--&gt;"</span> + house.getDesc();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Error:"</span>+e.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>0--&gt;中粮海景壹号新出大平层！总价4500W起
1--&gt;中粮海景壹号新出大平层！总价4500W起
1--&gt;满五唯一，黄金地段
2--&gt;中粮海景壹号新出大平层！总价4500W起
2--&gt;满五唯一，黄金地段
2--&gt;一楼自带小花园
3--&gt;一楼自带小花园
3--&gt;毗邻汤臣一品
4--&gt;毗邻汤臣一品
4--&gt;顶级住宅，给您总统般尊贵体验
5--&gt;顶级住宅，给您总统般尊贵体验
5--&gt;顶层户型，两室一厅
6--&gt;顶层户型，两室一厅
6--&gt;南北通透，豪华五房
7--&gt;南北通透，豪华五房
</code></pre><p>通过<a href="http://www.jianshu.com/p/5970280703b9" target="_blank" rel="external">转换操作符</a>、<a href="http://www.jianshu.com/p/3a188b995daa" target="_blank" rel="external">过滤操作符</a>、<a href="http://www.jianshu.com/p/546fe44a6e22" target="_blank" rel="external">组合操作符</a>三个篇幅将RxJava主要的操作符也介绍的七七八八了。更多操作符的介绍建议大家去查阅官方文档，并自己动手实践一下。这一系列的文章也会持续更新，欢迎大家保持关注！:)</p>
<p>Demo源码地址：<a href="https://github.com/BaronZ88/HelloRxJava" target="_blank" rel="external">https://github.com/BaronZ88/HelloRxJava</a></p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： &lt;strong&gt;&lt;code&gt;Merge&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;StartWith&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Concat&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;CombineLatest&lt;/code&gt;&lt;/strong&gt;  &lt;strong&gt;&lt;code&gt;SwitchOnNext&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Join&lt;/code&gt;&lt;/strong&gt;等等。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列4(过滤操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%974-%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列4-过滤操作符/</id>
    <published>2017-02-05T16:20:33.000Z</published>
    <updated>2019-08-19T12:56:35.814Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<hr>
<p>前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： <strong><code>Filter</code></strong> <strong><code>Take</code></strong> <strong><code>TakeLast</code></strong> <strong><code>TakeUntil</code></strong> <strong><code>Skip</code></strong> <strong><code>SkipLast</code></strong> <strong><code>ElementAt</code></strong> <strong><code>Debounce</code></strong> <strong><code>Distinct</code></strong> <strong><code>DistinctUntilChanged</code></strong> <strong><code>First</code></strong> <strong><code>Last</code></strong>等等。</p>
<a id="more"></a>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p><strong><code>filter(Func1)</code></strong>用来过滤观测序列中我们不想要的值，只返回满足条件的值，我们看下原理图：</p>
<p><img src="http://resources.baronzhang.com/rxjava/operator/filter/FilterOperator.png" alt="filter(Func1)"></p>
<p>还是拿前面文章中的小区<code>Community[] communities</code>来举例，假设我需要赛选出所有房源数大于10个的小区，我们可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .filter(<span class="keyword">new</span> Func1&lt;Community, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> community.houses.size()&gt;<span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">        System.out.println(community.name);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h3><p><strong><code>take(int)</code></strong>用一个整数n作为一个参数，从原始的序列中发射前n个元素.<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/TakeOperator.png" alt="take(int)"></p>
<p>现在我们需要取小区列表<code>communities</code>中的前10个小区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .take(10)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```     </div><div class="line"></div><div class="line">### TakeLast</div><div class="line">**`takeLast(int)`**同样用一个整数n作为参数，只不过它发射的是观测序列中后n个元素。</div><div class="line">![takeLast(int)](http://resources.baronzhang.com/rxjava/operator/filter/TakeLastNOperator.png)</div><div class="line"></div><div class="line">获取小区列表`communities`中的后3个小区</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .takeLast(3)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="TakeUntil"><a href="#TakeUntil" class="headerlink" title="TakeUntil"></a>TakeUntil</h3><p><strong><code>takeUntil(Observable)</code></strong>订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，<code>takeUntil()</code>返回的Observable会停止发射原始Observable并终止。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/TakeUntilOperator.png" alt="takeUntil(Observable)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Long&gt; observableA = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS);</div><div class="line">Observable&lt;Long&gt; observableB = Observable.interval(<span class="number">800</span>, TimeUnit.MILLISECONDS);</div><div class="line"></div><div class="line">observableA.takeUntil(observableB)</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                System.out.println(aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(Integer.MAX_VALUE);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>0
1
</code></pre><p><strong><code>takeUntil(Func1)</code></strong>通过Func1中的call方法来判断是否需要终止发射数据。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/TakeUntilPOperator.png" alt="takeUntil(Func1)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">                .takeUntil(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> integer &gt;= <span class="number">5</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                System.out.println(integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>1
2
3
4
5
</code></pre><p>###Skip<br><strong><code>skip(int)</code></strong>让我们可以忽略Observable发射的前n项数据。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/SkipOperator.png" alt="skip(int)"></p>
<p>过滤掉小区列表<code>communities</code>中的前5个小区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .skip(5)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```        </div><div class="line"></div><div class="line"></div><div class="line">### SkipLast</div><div class="line"></div><div class="line">**`skipLast(int)`**忽略Observable发射的后n项数据。</div><div class="line">![skipLast(int)](http://resources.baronzhang.com/rxjava/operator/filter/SkipLastOperator.png)</div><div class="line"></div><div class="line">### ElementAt</div><div class="line">**`elementAt(int)`**用来获取元素Observable发射的事件序列中的第n项数据，并当做唯一的数据发射出去。</div><div class="line">![elementAt(int)](http://resources.baronzhang.com/rxjava/operator/filter/ElementAtOperator.png)</div><div class="line"></div><div class="line">### Debounce</div><div class="line">**`debounce(long, TimeUnit)`**过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBing(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</div><div class="line">![debounce(long, TimeUnit)](http://resources.baronzhang.com/rxjava/operator/filter/DebounceOperator.png)</div><div class="line"></div><div class="line">**`debounce(Func1)`**可以根据Func1的call方法中的函数来过滤，Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。</div><div class="line">![debounce(Func1)](http://resources.baronzhang.com/rxjava/operator/filter/DebounceFOperator.png)</div><div class="line"></div><div class="line">### Distinct</div><div class="line">**`distinct()`**的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。</div><div class="line">![distinct()](http://resources.baronzhang.com/rxjava/operator/filter/DistinctOperator.png)</div><div class="line"></div><div class="line">过滤掉一段数字中的重复项：</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class="line">        .distinct()</div><div class="line">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer i) &#123;</div><div class="line">                System.out.print(i + " ");</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>2 1 3 4 5
</code></pre><p><strong><code>distinct(Func1)</code></strong>参数中的Func1中的call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是不是相同；如果判定为重复则会和<code>distinct()</code>一样过滤掉重复的数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/DistinctKeyOperator.png" alt="distinct(Func1)"></p>
<p>假设我们要过滤掉一堆房源中小区名重复的小区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//House构造函数中的第一个参数为该房源所属小区名，第二个参数为房源描述</span></div><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"中粮海景壹号新出大平层！总价4500W起"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"满五唯一，黄金地段"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"一楼自带小花园"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"毗邻汤臣一品"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"顶级住宅，给您总统般尊贵体验"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"顶层户型，两室一厅"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"南北通透，豪华五房"</span>));</div><div class="line">Observable.from(houses)</div><div class="line">        .distinct(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:竹园新村; 房源描述:满五唯一，黄金地段
</code></pre><h3 id="DistinctUntilChanged"><a href="#DistinctUntilChanged" class="headerlink" title="DistinctUntilChanged"></a>DistinctUntilChanged</h3><p><strong><code>distinctUntilChanged()</code></strong>和<code>distinct()</code>类似，只不过它判定的是Observable发射的当前数据项和前一个数据项是否相同。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/DistinctUntilChangedOperator.png" alt="distinctUntilChanged()"></p>
<p>同样还是上面过滤数字的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class="line">        .distinctUntilChanged()</div><div class="line">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer i) &#123;</div><div class="line">                System.out.print(i + &quot; &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>2 1 2 3 4 3 4 5
</code></pre><p><strong><code>distinctUntilChanged(Func1)</code></strong>和<code>distinct(Func1)</code>一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/DistinctUntilChangedKeyOperator.png" alt="distinctUntilChanged(Func1)"></p>
<p>我们还是拿前面的过滤房源的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .distinctUntilChanged(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:竹园新村; 房源描述:满五唯一，黄金地段
小区:中粮·海景壹号; 房源描述:毗邻汤臣一品
小区:竹园新村; 房源描述:顶层户型，两室一厅
小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
</code></pre><h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p><strong><code>first()</code></strong>顾名思义，它是的Observable只发送观测序列中的第一个数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/FirstOperator.png" alt="first()"></p>
<p>获取房源列表<code>houses</code>中的第一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .first()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;                </div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
</code></pre><p><strong><code>first(Func1)</code></strong>只发送符合条件的第一个数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/FirstNOperator.png" alt="first(Func1)"></p>
<p>现在我们要获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的第一套房源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .first(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"竹园新村"</span>.equals(house.communityName);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:竹园新村; 房源描述:满五唯一，黄金地段
</code></pre><h3 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h3><p><strong><code>last()</code></strong>只发射观测序列中的最后一个数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/LastOperator.png" alt="last()"></p>
<p>获取房源列表中的最后一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .last()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
</code></pre><p><strong><code>last(Func1)</code></strong>只发射观测序列中符合条件的最后一个数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/LastPOperator.png" alt="last(Func1)"></p>
<p>获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的最后一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .last(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"竹园新村"</span>.equals(house.communityName);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:竹园新村; 房源描述:顶层户型，两室一厅
</code></pre><p>这一章我们就先聊到这，更多的过滤类操作符的介绍大家可以去查阅官方文档和源码；在下一章我们将继续介绍组合类操作符。</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Take&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;TakeUntil&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Skip&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;SkipLast&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Debounce&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Distinct&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;DistinctUntilChanged&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;First&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Last&lt;/code&gt;&lt;/strong&gt;等等。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列3(转换操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%973-%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列3-转换操作符/</id>
    <published>2017-02-05T16:20:19.000Z</published>
    <updated>2019-08-19T12:56:35.814Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>   </li>
</ul>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<hr>
<p>前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：</p>
<ol>
<li><strong>转换类操作符</strong></li>
<li><strong>过滤类操作符</strong></li>
<li><strong>组合类操作符</strong></li>
</ol>
<p>这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。</p>
<a id="more"></a>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong><code>map(Func1)</code></strong>函数接受一个Func1类型的参数(就像这样<code>map(Func1&lt;? super T, ? extends R&gt; func)</code>),然后吧这个Func1应用到每一个由Observable发射的值上，将发射的只转换为我们期望的值。这种狗屁定义我相信你也听不懂，我们来看一下官方给出的原理图：</p>
<p><img src="http://resources.baronzhang.com/rxjava/operator/map/MapOperator.png" alt="map(Func1)"></p>
<p>假设我们需要将一组数字装换成字符串，我们可以通过map这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"This is "</span> + i;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                System.out.println(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>Func1构造函数中的两个参数分别是Observable发射值当前的类型和map转换后的类型，上面这个例子中发射值当前的类型是Integer,转换后的类型是String。</p>
</blockquote>
<h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p><strong><code>flatMap(Func1)</code></strong>函数同样也是做转换的，但是作用却不一样。flatMap不太好理解，我们直接看例子（<em>我们公司是个房产平台，那我就拿房子举例</em>）：假设我们有一组小区数据<code>Community[] communites</code>,现在我们要输出每个小区的名字；我们可以这样实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Community, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> community.name;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Community name : "</span> + name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>现在我们需求有变化，需要打印出每个小区下面每一套房子的价格。于是我可以这样实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">Community[] communities = &#123;&#125;;</div><div class="line">Observable.from(communities)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                for (House house : community.houses) &#123;</div><div class="line">                    System.out.println("House price : " + house.price);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```            </div><div class="line"></div><div class="line">如果我不想在Subscriber中使用for循环，而是希望Subscriber中直接传入单个的House对象呢？用map()显然是不行的，因为map()是一对一的转化，而我现在的要求是一对多的转化。那么我们可以使用flatMap()把一个Community转化成多个House。</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;House&gt; call(Community community) &#123;</div><div class="line">                return Observable.from(community.houses);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(House house) &#123;</div><div class="line">                System.out.println("House price : " + house.price);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```            </div><div class="line"></div><div class="line">从前面的例子中我们发现，flatMap()和map()都是把传入的参数转化之后返回另一个对象。但和map()不同的是，flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到 Subscriber的回调方法中。</div><div class="line"></div><div class="line">flatMap(Func1)的原理是这样的：</div><div class="line"></div><div class="line">1. 将传入的事件对象装换成一个Observable对象；</div><div class="line">2. 这是不会直接发送这个Observable, 而是将这个Observable激活让它自己开始发送事件；</div><div class="line">3. 每一个创建出来的Observable发送的事件，都被汇入同一个Observable，这个Observable负责将这些事件统一交给Subscriber的回调方法。</div><div class="line"></div><div class="line">这三个步骤，把事件拆成了两级，通过一组新创建的Observable将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是flatMap()所谓的flat。</div><div class="line"></div><div class="line">最后我们来看看flatMap的原理图：</div><div class="line">![flatMap(Func1)](http://resources.baronzhang.com/rxjava/operator/map/FlatMapOperator.png)</div><div class="line"></div><div class="line">### ConcatMap</div><div class="line">**`concatMap(Func1)`**解决了`flatMap()`的交叉问题，它能够把发射的值连续在一起，就像这样：</div><div class="line">![concatMap(Func1)](http://resources.baronzhang.com/rxjava/operator/map/ConcatMapOperator.png)</div><div class="line"></div><div class="line">### flatMapIterable</div><div class="line">**`flatMapIterable(Func1)`**和`flatMap()`几乎是一样的，不同的是`flatMapIterable()`它转化的多个Observable是使用Iterable作为源数据的。</div><div class="line">![flatMapIterable(Func1)](http://resources.baronzhang.com/rxjava/operator/map/FlatMapIterableOperator.png)</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .flatMapIterable(new Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Iterable&lt;House&gt; call(Community community) &#123;</div><div class="line">                return community.houses;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void call(House house) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="SwitchMap"><a href="#SwitchMap" class="headerlink" title="SwitchMap"></a>SwitchMap</h3><p><strong><code>switchMap(Func1)</code></strong>和<code>flatMap(Func1)</code>很像，除了一点：每当源<code>Observable</code>发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的<code>Observable</code>，并开始监视当前发射的这一个。<br><img src="http://resources.baronzhang.com/rxjava/operator/map/SwitchMapOperator.png" alt="switchMap(Func1)"></p>
<h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h3><p><strong><code>scan(Func2)</code></strong>对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用合格函数时的第一个参数使用。<br><img src="http://resources.baronzhang.com/rxjava/operator/map/ScanOperator.png" alt="scan(Func2)"></p>
<p>我们来看个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .scan(<span class="keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer integer, Integer integer2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer + integer2;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        System.out.print(integer+“ ”);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>输出结果为：</p>
<pre><code>1 3 6 10 15  
</code></pre><h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><p><strong><code>groupBy(Func1)</code></strong>将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小Observable分别发射其所包含的的数据，和SQL中的groupBy类似。实际使用中，我们需要提供一个生成key的规则（也就是Func1中的call方法），所有key相同的数据会包含在同一个小的Observable中。另外我们还可以提供一个函数来对这些数据进行转化，有点类似于集成了flatMap。<br><img src="http://resources.baronzhang.com/rxjava/operator/map/GroupByOperator.png" alt="groupBy(Func1)"></p>
<p>单纯的文字描述和图片解释可能难以理解，我们来看个例子：假设我现在有一组房源<code>List&lt;House&gt; houses</code>,每套房子都属于某一个小区，现在我们需要根据小区名来对房源进行分类，然后依次将房源信息输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"中粮海景壹号新出大平层！总价4500W起"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"满五唯一，黄金地段"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"毗邻汤臣一品"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"顶层户型，两室一厅"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"南北通透，豪华五房"</span>));</div><div class="line">Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable.from(houses)</div><div class="line">        .groupBy(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>通过上面的代码我们创建了一个新的Observable:<code>groupByCommunityNameObservable</code>，它将会发送一个带有<code>GroupedObservable</code>的序列（也就是指发送的数据项的类型为GroupedObservable）。<code>GroupedObservable</code>是一个特殊的<code>Observable</code>，它基于一个分组的key，在这个例子中的key就是小区名。现在我们需要将分类后的房源依次输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.concat(groupByCommunityNameObservable)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span>+house.communityName+<span class="string">"; 房源描述:"</span>+house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:中粮·海景壹号; 房源描述:毗邻汤臣一品
小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
小区:竹园新村; 房源描述:满五唯一，黄金地段
小区:竹园新村; 房源描述:顶层户型，两室一厅
</code></pre><p>转换类的操作符就先介绍到这，后续还会继续介绍组合、过滤类的操作符及源码分析，敬请期待！</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;转换类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
</feed>
