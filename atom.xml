<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>技术男的后花园</title>
  <subtitle>公众号：BaronTalk</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://baronzhang.com/"/>
  <updated>2019-08-19T11:26:51.803Z</updated>
  <id>http://baronzhang.com/</id>
  
  <author>
    <name>张磊</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android 性能监控系列一（原理篇）</title>
    <link href="http://baronzhang.com//blog/APM/Android-%E6%80%A7%E8%83%BD%E7%9B%91%E6%8E%A7%E7%B3%BB%E5%88%97%E4%B8%80%EF%BC%88%E5%8E%9F%E7%90%86%E7%AF%87%EF%BC%89/"/>
    <id>http://baronzhang.com//blog/APM/Android-性能监控系列一（原理篇）/</id>
    <published>2018-06-06T02:52:00.000Z</published>
    <updated>2019-08-19T11:26:51.803Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/blog/framework/android/apm/apm1/header.jpg" alt="题图来自 https://unsplash.com"></p>
<blockquote>
<p>欢迎关注微信公众号：<strong>BaronTalk</strong>，获取更多精彩好文！</p>
</blockquote>
<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>性能问题是导致 App 用户流失的罪魁祸首之一，如果用户在使用我们 App 的时候遇到诸如页面卡顿、响应速度慢、发热严重、流量电量消耗大等问题的时候，很可能就会卸载掉我们的 App。而往往获取用户的成本是高昂的，因此因为性能问题导致用户流失的情况是我们要极力避免的，做不好这一点是我们开发人员的失职。</p>
<a id="more"></a>
<p>去年我们团队完成了整个项目架构方面的重构（有兴趣的同学可以参考我之前的文章<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483731&amp;idx=1&amp;sn=76bd5612ba723171b6ebac69aaf039f8&amp;chksm=fddca7d2caab2ec4eec8736cf4005615c401984e2218a0cfc71dddfe3a204495c4e8a7312b4a&amp;scene=38#wechat_redirect" target="_blank" rel="external">安居客 Android 项目架构演进 </a>与<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483732&amp;idx=1&amp;sn=b7ee1151b2c8ad2e997b8db39adf3267&amp;chksm=fddca7d5caab2ec33905cc3350f31c0c98794774b0d04a01845565e3989b1f20205c7f432cb9&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android 模块化探索与实践 </a> ），目前已经能够很好的支撑我们的业务，并对团队的开发效率也有了一定的提升、项目质量也有了大幅的进步。</p>
<p>但是项目上线后，到底有没有性能问题？用户体验到底怎么样？在用户的使用场景中到底会遇到哪些性能问题？我们项目的性能短板又在哪里？这些问题的答案我们都不得而知，因此开发一套完善的性能监控体系势在必行。我们团队在今年开始着手开发自己的性能监控组件 APM，希望通过它来采集线上性能数据，找到性能短板，针对性的优化用户体验。</p>
<blockquote>
<p>APM 全称 Application Performance Management &amp; Monitoring (应用性能管理/监控)  </p>
</blockquote>
<p>后面我会通过一系列的文章来介绍 APM 的原理、框架设计与实现等等。本篇就是这个系列的第一篇，主要从实现原理方面来介绍 APM。按照目前的计划，这个系列大致会从如下几个方面来展开：</p>
<ul>
<li><strong>原理篇</strong>：主要介绍 APM 的实现原理；</li>
<li><strong>设计篇</strong>：介绍整个 APM 框架设计；</li>
<li><strong>实现篇-Gradle Plugin</strong>：介绍 Gradle 插件在 APM 项目中的应用，以及如何开发一个 Gradle Plugin；</li>
<li><strong>实现篇-Javassist/ASM</strong>：Javassist、ASM 等字节码操作库的介绍，以及如何使用它们在编译时插入代码来采集各项性能数据；</li>
<li><strong>实现篇-数据存储及上报</strong>：介绍 APM 框架的存储上报机制及实现过程；</li>
<li><strong>发布集成</strong>：最后会介绍如何将库发布到 jCenter() 以及如何在生产项目中集成。</li>
</ul>
<p>这里要向大家交代一点是，之前的文章为了极力做到将复杂的问题用通俗易懂的方式解释清楚，又要面面俱到，往往篇幅过长；诸如之前写过的<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483727&amp;idx=3&amp;sn=f3d0ccfee85c26d8e49cfd22fbccb7f6&amp;chksm=fddca7cecaab2ed8be6e34288bcec23a34289f09fd22e5a06ecc547020a3474978b73366d94b&amp;scene=38#wechat_redirect" target="_blank" rel="external">RxJava系列6(从微观角度解读RxJava源码) </a>、<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483730&amp;idx=1&amp;sn=d308f7073182f8c48dd41e17f2fb7682&amp;chksm=fddca7d3caab2ec5c77884a3f8414d2668cd40627c9b3674dcbd3774deb31400ff34d5e6d11a&amp;scene=38#wechat_redirect" target="_blank" rel="external">神兵利器Dagger2 </a> 、<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483731&amp;idx=1&amp;sn=76bd5612ba723171b6ebac69aaf039f8&amp;chksm=fddca7d2caab2ec4eec8736cf4005615c401984e2218a0cfc71dddfe3a204495c4e8a7312b4a&amp;scene=38#wechat_redirect" target="_blank" rel="external">安居客 Android 项目架构演进 </a>、<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483732&amp;idx=1&amp;sn=b7ee1151b2c8ad2e997b8db39adf3267&amp;chksm=fddca7d5caab2ec33905cc3350f31c0c98794774b0d04a01845565e3989b1f20205c7f432cb9&amp;scene=38#wechat_redirect" target="_blank" rel="external">Android 模块化探索与实践 </a> 、<a href="https://mp.weixin.qq.com/s?__biz=MzU4ODM2MjczNA==&amp;mid=2247483735&amp;idx=1&amp;sn=202bcc94cc581d91e77728afe674fdfe&amp;chksm=fddca7d6caab2ec0c1a08e25dc1acf5aaf257365f64d5c50c37aae4ead919fdbc11062575f9f&amp;scene=38#wechat_redirect" target="_blank" rel="external">写给 Android 应用工程师的 Binder 原理剖析</a>等文章，篇幅通常都在 8000~10000字以上，通篇阅读下来可能需要近半个小时的时间，不太符合当下碎片化阅读的需求；因此在后面的写作上会控制篇幅，尽量控制在 10 分钟以内的长度。</p>
<p>这也是我为什么会将 APM 作为一个系列来介绍的原因，同时这也能保证后面在介绍 APM 的时候能够深入到实现细节，避免泛泛而谈。</p>
<h2 id="二-Android-APM-的基本原理"><a href="#二-Android-APM-的基本原理" class="headerlink" title="二. Android APM 的基本原理"></a>二. Android APM 的基本原理</h2><p>市场上有很多商业化的 APM 平台，比如著名的 NewRelic，还有国内的 听云、OneAPM 等等。这些平台的工作流程基本都是一致的：</p>
<ol>
<li>首先在客户端（Android、iOS、Web等）采集数据；</li>
<li>接着将采集到的数据整理上报到服务器；</li>
<li>服务器接收到数据后建模、存储、挖掘分析，让后将数据可视化，供用户使用。</li>
</ol>
<p>如下图：<br><img src="http://resources.baronzhang.com/blog/framework/android/apm/apm.png" alt="APM 工作流程"></p>
<p>我们介绍的 Android APM 框架其实就是在 Android 平台上应用的一个数据采集上报 SDK。主要包含三大模块：</p>
<ol>
<li>数据采集</li>
<li>数据存储</li>
<li>数据上报</li>
</ol>
<p>其中数据采集是整个 APM 框架的核心。</p>
<p>数据采集我们可以通过手动埋点的方式，但这种方式工作量巨大、不灵活，而且无法覆盖到所有场景；因此只能通过自动化的方式来采集数据。在应用构建期间，通过修改字节码的方式来进行字节码插桩就是实现自动化的方案之一。</p>
<h2 id="三-Android-打包流程及字节码插桩原理"><a href="#三-Android-打包流程及字节码插桩原理" class="headerlink" title="三. Android 打包流程及字节码插桩原理"></a>三. Android 打包流程及字节码插桩原理</h2><p>在谈字节码插桩的原理之前，首先我们看看 Android 的打包流程，如下图：<br><img src="http://resources.baronzhang.com/blog/framework/android/apm/apk-build.png" alt="Android 打包流程"></p>
<p>从上面这张打包流程图我们可以看到，一个 App 的所有 class 文件，包括第三方的 class 文件都会经过 dex 的过程打包成一个或者多个 dex 文件。</p>
<p>这其中涉及到两个很关键的环节：</p>
<ol>
<li><strong>javac</strong>：将 .java 格式的源代码文件编译成 class 文件；</li>
<li><strong>dex</strong>: 将 class 格式的文件打包汇总，组成一个或者多个 dex 文件。</li>
</ol>
<p>我们想要对字节码进行修改，只需要在 javac 之后 dex 之前遍历所有的字节码文件，并按照一定的规则过滤修改就好了，这里便是字节码插桩的入口。</p>
<p>那么我们到底如何介入打包过程，在 class 转换为 dex 文件的时候实现对字节码的修改呢？</p>
<p>答案是 <strong>transform api</strong></p>
<p>Android Gradle Plugin 1.5.0 及以上版本，Google 官方提供了 transform api 作为字节码插桩的入口。我们只需要实现一个自定义的 Gradle Plugin，然后在编译阶段去修改字节码文件。对于 Gradle Plugin 的具体实现后面的文章再做详细讲解。</p>
<h2 id="四-修改字节码"><a href="#四-修改字节码" class="headerlink" title="四. 修改字节码"></a>四. 修改字节码</h2><p>找到了插桩入口，接下来就要对字节码进行修改。对于字节码的修改，比较常用的框架有 Javassist 和 ASM。</p>
<ol>
<li><p><strong>Javassist</strong> 是一个开源的分析、编辑和创建 Java 字节码的类库,它提供了源码级别的 API 以及字节码级别的 API，源码级别的 API，直接使用 Java 编码的形式，而不需要深入了解虚拟机指令，就能动态改变类的结构或者动态生成类。</p>
</li>
<li><p><strong>ASM</strong> 是一个 Java 字节码操控框架。它能被用来动态生成类或者增强既有类的功能。ASM 可以直接产生二进制 class 文件，也可以在类被加载入 Java 虚拟机之前动态改变类行为。</p>
</li>
</ol>
<p>ASM 和 Javassit 相比，API 贴近底层，比较难使用，需要对 Java 字节码和虚拟机方面有一定程度的了解。ASM 的优点就在于性能上的优势，且更加灵活；Javassist 的实现中大量使用的反射，所以性能偏低。</p>
<p>简单的说就是 ASM 虽然难以使用，但是功能强大效率高。是很多无痕埋点、APM框架的首选方案。</p>
<p>ASM 的具体时候我们放到这个系列后面的文章介绍。</p>
<h2 id="五-总结"><a href="#五-总结" class="headerlink" title="五. 总结"></a>五. 总结</h2><p>Android APM 的原理其实非常简单，用一句话总结就是：</p>
<p>依据打包原理，在 class 转换为 dex 的过程中，调用 gradle transform api 遍历 class 文件，借助 Javassist、ASM 等框架修改字节码，插入我们自己的代码实现性能数据的统计。</p>
<p>以上所有过程都是在编译期完成的。</p>
<p>其实 Android 上的无痕埋点也是同样的原理，区别只不过是我们 hook 的点不同，采集的数据不同，因此掌握了 APM 的实现原理同样可以实现无痕埋点系统。</p>
<p>原理很简单，难的是实现细节。比如如何插桩采集到页面帧率、流量、耗电量等等。这些具体细节我们放到后面一一介绍。至于为什么放到后面……因为很多东西自己没做过我也不知道啊……🤣</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>

]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/blog/framework/android/apm/apm1/header.jpg&quot; alt=&quot;题图来自 https://unsplash.com&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;欢迎关注微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，获取更多精彩好文！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h2&gt;&lt;p&gt;性能问题是导致 App 用户流失的罪魁祸首之一，如果用户在使用我们 App 的时候遇到诸如页面卡顿、响应速度慢、发热严重、流量电量消耗大等问题的时候，很可能就会卸载掉我们的 App。而往往获取用户的成本是高昂的，因此因为性能问题导致用户流失的情况是我们要极力避免的，做不好这一点是我们开发人员的失职。&lt;/p&gt;
    
    </summary>
    
      <category term="APM" scheme="http://baronzhang.com/categories/APM/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="APM" scheme="http://baronzhang.com/tags/APM/"/>
    
      <category term="性能" scheme="http://baronzhang.com/tags/%E6%80%A7%E8%83%BD/"/>
    
  </entry>
  
  <entry>
    <title>我们和优秀工程师的差距在哪儿</title>
    <link href="http://baronzhang.com//blog/Other/%E6%88%91%E4%BB%AC%E5%92%8C%E4%BC%98%E7%A7%80%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E5%B7%AE%E8%B7%9D%E5%9C%A8%E5%93%AA%E5%84%BF/"/>
    <id>http://baronzhang.com//blog/Other/我们和优秀工程师的差距在哪儿/</id>
    <published>2018-04-25T06:51:59.000Z</published>
    <updated>2019-08-19T06:53:46.661Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/blog/other/engineer/pic1.jpg" alt=""></p>
<blockquote>
<p>关注微信公众号：<strong>BaronTalk</strong>，获取更多精彩好文。</p>
</blockquote>
<p>我相信每个工程师都曾怀揣一个成为技术大牛的梦想，可是真正走向技术大牛这条路的少之又少。工作中我们常常会发现，有些同学工作没几年但成长迅速；很快就能走向团队核心岗位，成为一名优秀的工程师；而有些同学工作几年后却在公司里默默无闻，能力和职位上都没有太大提升，得过且过最终沦为一名普普通通的码农。所以我常常会有感慨，太多人（包括我自己）真的只不过是用一两年的经验在职场上混了五年十年甚至更久。</p>
<p>那么普通工程师和优秀工程师到底差距在哪儿？那些优秀工程师是怎么一步一步成长起来了的呢？以下就我自己的观察和思考来谈一谈，看看能不能一探究竟，了解通向优秀工程师的法门；然后与大家共勉，一起朝着优秀工程师的方向去努力。</p>
<a id="more"></a>
<h2 id="差距在哪儿？"><a href="#差距在哪儿？" class="headerlink" title="差距在哪儿？"></a>差距在哪儿？</h2><p>我们拿吴军老师在得到专栏中讲解的一道 Google 面试题来展开聊一聊，看看面对同样的问题，普通工程师和优秀工程师是如何思考解决问题的。</p>
<p><strong>问题如下：如何设计一个地图功能，找到离当前最近的加油站？</strong></p>
<p>在最近公司的招聘面试过程中，我也拿类似的问题去问过部分候选人，大部分候选人都把问题想的太简单。通常普通工程师给出的解决方案是：根据经纬度算出所有加油站到当前位置的距离，然后对这些加油站按照距离的远近进行排序，选择距离最近的几个加油站。</p>
<p>可问题是，在路面上行驶，从 A 点通往 B 点，往往不是直线距离。因为无论是驾车还是步行，我们都不可能穿过建筑直达目的地，A 点到 B 点的距离是很多距离片段的组合，这可能会有上千种组合，那么如何从这上千种组合的路线中选择距离最近的一条路线呢？使用动态规划算法能够很好的解决这个问题，在上千种组合中只需几十个步骤就能计算出最短路线。这对部分工程师已经是个门槛了。</p>
<p>接下来就需要按照距离排序，找到最近的几个加油站。</p>
<p>绝大部分工程师面对这样的问题都会想到排序，排序当然能够解决问题，但并不是最优方案。就算使用效率最高的快速排序，也需要 N 乘 LogN 的计算量。假设城市里有 1000 个加油站，那么 LogN 约等于 10，也就是说计算的复杂度差不多是 1000，当然 1000 的计算量对于计算机算不上什么，但是考虑到一个城市的路面上可能有上百万辆行驶的汽车，这个计算量的消耗就很可观了。</p>
<p>假设我们只需要最近的 5 个加油站，如果对所有的加油站排序那显然做了很多无用功。数据结构中有一种叫二叉树的数据结构，在二叉树中有一种更细的分类：“堆”，通过堆排序我们可以只用排出前几名，而不用管后面的名次。通过堆排序排出第一名的时间复杂度是N，排出第二名、第三名、第四名、第五名的时间复杂度都 LogN，比对 1000 个加油站排序要快的多。对于我们的需求：选出最近的 5 个加油站，差不多只需要 1000 的计算量，比快速排序快了近 10 倍。</p>
<p>到这里你是不是觉得问题已经解决的很完美了？</p>
<p>我们在解决问题的时候不由自主的做了一个假设，就是整个算法的优化过程是围绕一个使用者的某一次使用来进行的。但是在现实生活中，一个城市里有很多人会同时在不同的地方寻找加油站。类似的，同一个人在不同的时间不同的地点开车时也需要寻找加油站。考虑到这个现实场景，时时刻刻都有很多人在不停的寻找附近的加油站，那么很多计算其实是可以预先算好的，等到提供服务的时候直接把结果调出来就好了，避免重复计算。</p>
<p>比如我们可以把上海市所有路口点到点的距离事先计算好，当一个人要找加油站的时候，距离的计算就不再需要实时地采用动态规划来计算了，只需要计算从当前位置出发到附近几个路口的距离，再计算下某个加油站到它所在地附近路口的距离，由于各个路口点到点的距离是事先计算好的，因此做几次简单的加法即可，这样计算距离的时间就能省几十倍。这就是对上面的问题进行了全局优化的好处。</p>
<p>其实面对这样的问题，优秀的工程师并不会遇到问题就直接着手去解决，而是会更全面的去考虑问题。比如会考虑到目前的行车方向，比如在解决问题中其实距离要求并不需要太精准，因为对于开车的人来说 2.5 公里和 2.3 公里其实并没有什么差别，再考虑到道路拥堵的情况，200 米的距离更加可以忽略不计了。但如果是行人要寻找附近的便利店，200 米的距离就不得不考虑了。</p>
<p>那么从上述这个问题的解决上我们能看出普通工程师和优秀工程师的差距在哪儿呢？</p>
<p><strong>1. 优秀的工程师必然有着扎实的计算机基础知识，很好的掌握了如数据结构、算法这些工具，能够在工作中借助这些工具帮助自己解决问题；</strong></p>
<p><strong>2. 优秀的工程师会尽量避免做无用功</strong></p>
<p><strong>3. 优秀的工程师不会只满足于完成任务，他们会不断的去思考探索最佳的解决方案；</strong></p>
<p><strong>4. 优秀的工程师不会被思维所局限，考虑问题更加全面，懂得从全局角度优化解决方案。</strong></p>
<p>从这个例子我们也能看出来，一个优秀工程师解决问题的性能可能是普通工程师的几百上千倍，一个优秀的解决方案甚至能帮助公司节省几百万的服务器费用。</p>
<p>因此，<strong>在软件工程领域一百个臭皮匠也顶不了一个诸葛亮！</strong></p>
<h2 id="做为普通工程师的我们如何提升自己？"><a href="#做为普通工程师的我们如何提升自己？" class="headerlink" title="做为普通工程师的我们如何提升自己？"></a>做为普通工程师的我们如何提升自己？</h2><p><strong>学好数据结构、算法、操作系统原理、计算机体系结构等基本功，打好基础。</strong></p>
<p>如果你是天才，面对像上面这样的问题，即使你没有学过计算机理论知识，即使你不知道动态规划、二叉树、堆排序，可能也能依靠智力上的优势解决。但遗憾的是绝大多数人都不是天才，因此在解决问题的时候就需要借助各种工具以便事半功倍。对于开发人员来说，数据结构、算法以及各种数学知识就是我们手上的工具。</p>
<p><strong>要成为优秀的工程师需要我们静下来，沉下去，老老实实的吃透你所做的项目。做好简单的事，才有机会去做更有挑战的工作。</strong></p>
<p>很多工程师会抱怨自己一直在做业务，没什么挑战，感觉不到成长。可事实真的是这样吗？往往我们的业务需求就像这道面试题，看似简单其实想要做好，背后需要下很大功夫。就算平时做的业务真的很简单，我们是不是还可以想想，我的代码实现是否有更好的方式？面对类似的业务我的效率是否可以提升？线上出 Bug 了是否可以采集到线上 Log 快速定位并解决问题？你对自己开发的项目中用到的各种框架是否真的理解其原理，是否真的去翻过代码学习过这些优秀框架的实现？就拿 Android 开发来说，各种开源框架如 RxJava、Retrofit、OKHttp、ORM框架、热修复框架、插件化框架等等，如果你真的去认真学习过一遍，我相信已经远超行业里 90% 的工程师了。</p>
<p>同时在工作中要有不怕吃亏的心态，主动去承担更多的职责；做的更多往往也意味着接受了更多的挑战，获得了更多的锻炼机会。</p>
<p><strong>利用碎片时间系统化学习</strong></p>
<p>很多人反对碎片化学习，但我并不完全认同这种看法。碎片化的时间既可以用来碎片化的学习，也可以用来做系统化的学习。很多人都指望能够有一天，有一大片的时间，好好的、系统化的把计算机知识恶补一遍。所以买了算法导论、深入理解计算机系统等等经典书籍放在家里，等着有一天能够有一大片时间，沐浴更衣、正襟危坐来好好学习。但是学了不久很快又被其它事打断了，结果下一次又重新再来。最后往往只是把一本书的前几十页反复看了好多遍，其实这种才是真正的碎片化学习。</p>
<p>而所谓的利用碎片化时间系统化的学习是指制定好完善的学习计划，利用好每一个碎片时间，比如上下班的路上、等公交的时间、坐地铁的时间、排队的时间，甚至是蹲马桶的时间来按计划的、体系化的学习提高。</p>
<p><strong>持续学习，坚持阅读，保持输出</strong></p>
<p>技术更新迭代太快，而计算机科学之复杂也远不是在学校的几年学习就能完全学透的，这就要求我们保持持续学习。但往往很多人走出校门后就再也没有正儿八经的学习过、冲过电，这也是为什么我们毕业后会被那些优秀的工程师越甩越远的原因。而我认为最好的持续学习的方式就是坚持阅读了。你们看！优秀的工程师就算是挂着盐水也要坚持阅读的！！！🤣🤣🤣</p>
<p><img src="http://resources.baronzhang.com/blog/other/engineer/pic2.jpg" alt=""></p>
<p>另外学过的知识只有输出出来了，才是真正的学到肚子了。向别人讲述知识、写作等都是很好的知识输出方式。</p>
<p><strong>锻炼自己的综合能力</strong></p>
<p>要成为一名优秀的工程师，光有过硬的技术是不够的。出色的完成一项工作往往考研的是一个人的综合能力。良好的表达能力、出色的会议组织能力、事情的推动能力、个人的成熟度等等都是需要我们在工作中去刻意的培养和锻炼的。拿表达能力来说，如果觉得自己表达上有所欠缺，就可以通过写作、主动在团队内做技术分享等等方式来锻炼自己。有时候，不逼自己一把你都不知道自己到底有多棒！</p>
<h2 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h2><p>作为一个技术上的菜鸟，写这样的文章实在是有点惭愧。且算是给自己定个基调，与大家共勉好了，这样也能督促自己不断进步。</p>
<p>哦，对了！还有一点！！！优秀的工程师是不会抱着手机抖音一刷一晚上的。🤣🤣🤣</p>
<blockquote>
<p>如果喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/blog/other/engineer/pic1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关注微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;，获取更多精彩好文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我相信每个工程师都曾怀揣一个成为技术大牛的梦想，可是真正走向技术大牛这条路的少之又少。工作中我们常常会发现，有些同学工作没几年但成长迅速；很快就能走向团队核心岗位，成为一名优秀的工程师；而有些同学工作几年后却在公司里默默无闻，能力和职位上都没有太大提升，得过且过最终沦为一名普普通通的码农。所以我常常会有感慨，太多人（包括我自己）真的只不过是用一两年的经验在职场上混了五年十年甚至更久。&lt;/p&gt;
&lt;p&gt;那么普通工程师和优秀工程师到底差距在哪儿？那些优秀工程师是怎么一步一步成长起来了的呢？以下就我自己的观察和思考来谈一谈，看看能不能一探究竟，了解通向优秀工程师的法门；然后与大家共勉，一起朝着优秀工程师的方向去努力。&lt;/p&gt;
    
    </summary>
    
      <category term="Other" scheme="http://baronzhang.com/categories/Other/"/>
    
    
      <category term="算法" scheme="http://baronzhang.com/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="数据结构" scheme="http://baronzhang.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>写给 Android 应用工程师的 Binder 原理剖析</title>
    <link href="http://baronzhang.com//blog/Android/%E5%86%99%E7%BB%99-Android-%E5%BA%94%E7%94%A8%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84-Binder-%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/"/>
    <id>http://baronzhang.com//blog/Android/写给-Android-应用工程师的-Binder-原理剖析/</id>
    <published>2018-04-10T15:11:37.000Z</published>
    <updated>2019-08-19T11:51:08.973Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/blog/android/binder/header.jpg" alt=""></p>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="一-前言"><a href="#一-前言" class="headerlink" title="一. 前言"></a>一. 前言</h2><p>这篇文章我酝酿了很久，参考了很多资料，读了很多源码，却依旧不敢下笔。生怕自己理解上还有偏差，对大家造成误解，贻笑大方。又怕自己理解不够透彻，无法用清晰直白的文字准确的表达出 Binder 的设计精髓。直到今天提笔写作时还依旧战战兢兢。</p>
<p>Binder 之复杂远远不是一篇文章就能说清楚的，本文想站在一个更高的维度来俯瞰 Binder 的设计，最终帮助大家形成一个完整的概念。对于应用层开发的同学来说，理解到本文这个程度也就差不多了。希望更加深入理解 Binder 实现机制的，可以阅读文末的参考资料以及相关源码。</p>
<a id="more"></a>
<h2 id="二-Binder-概述"><a href="#二-Binder-概述" class="headerlink" title="二. Binder 概述"></a>二. Binder 概述</h2><p>简单介绍下什么是 Binder。Binder 是一种进程间通信机制，基于开源的 OpenBinder 实现；OpenBinder 起初由 Be Inc. 开发，后由 Plam Inc. 接手。从字面上来解释 Binder 有胶水、粘合剂的意思，顾名思义就是粘和不同的进程，使之实现通信。对于 Binder 更全面的定义，等我们介绍完 Binder 通信原理后再做详细说明。</p>
<h3 id="2-1-为什么必须理解-Binder-？"><a href="#2-1-为什么必须理解-Binder-？" class="headerlink" title="2.1 为什么必须理解 Binder ？"></a>2.1 为什么必须理解 Binder ？</h3><p>作为 Android 工程师的你，是不是常常会有这样的疑问：</p>
<ul>
<li>为什么 Activity 间传递对象需要序列化？</li>
<li>Activity 的启动流程是什么样的？</li>
<li>四大组件底层的通信机制是怎样的？</li>
<li>AIDL 内部的实现原理是什么？</li>
<li>插件化编程技术应该从何学起？等等…</li>
</ul>
<p>这些问题的背后都与 Binder 有莫大的关系，要弄懂上面这些问题理解 Bidner 通信机制是必须的。</p>
<p>我们知道 Android 应用程序是由 Activity、Service、Broadcast Receiver 和 Content Provide 四大组件中的一个或者多个组成的。有时这些组件运行在同一进程，有时运行在不同的进程。这些进程间的通信就依赖于 Binder IPC 机制。不仅如此，Android 系统对应用层提供的各种服务如：ActivityManagerService、PackageManagerService 等都是基于 Binder IPC 机制来实现的。Binder 机制在 Android 中的位置非常重要，毫不夸张的说理解 Binder 是迈向 Android 高级工程的第一步。</p>
<h3 id="2-2-为什么是-Binder"><a href="#2-2-为什么是-Binder" class="headerlink" title="2.2 为什么是 Binder ?"></a>2.2 为什么是 Binder ?</h3><p>Android 系统是基于 Linux 内核的，Linux 已经提供了管道、消息队列、共享内存和 Socket 等 IPC 机制。那为什么 Android 还要提供 Binder 来实现 IPC 呢？主要是基于<strong>性能</strong>、<strong>稳定性</strong>和<strong>安全性</strong>几方面的原因。</p>
<h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>首先说说性能上的优势。Socket 作为一款通用接口，其传输效率低，开销大，主要用在跨网络的进程间通信和本机上进程间的低速通信。消息队列和管道采用存储-转发方式，即数据先从发送方缓存区拷贝到内核开辟的缓存区中，然后再从内核缓存区拷贝到接收方缓存区，至少有两次拷贝过程。共享内存虽然无需拷贝，但控制复杂，难以使用。Binder 只需要一次数据拷贝，性能上仅次于共享内存。</p>
<p>注：各种IPC方式数据拷贝次数，此表来源于<a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder 设计与实现 - 设计篇</a></p>
<table>
<thead>
<tr>
<th style="text-align:left">IPC方式</th>
<th style="text-align:left">数据拷贝次数</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">共享内存</td>
<td style="text-align:left">0</td>
</tr>
<tr>
<td style="text-align:left">Binder</td>
<td style="text-align:left">1</td>
</tr>
<tr>
<td style="text-align:left">Socket/管道/消息队列</td>
<td style="text-align:left">2</td>
</tr>
</tbody>
</table>
<h4 id="稳定性"><a href="#稳定性" class="headerlink" title="稳定性"></a>稳定性</h4><p>再说说稳定性，Binder 基于 C/S 架构，客户端（Client）有什么需求就丢给服务端（Server）去完成，架构清晰、职责明确又相互独立，自然稳定性更好。共享内存虽然无需拷贝，但是控制负责，难以使用。从稳定性的角度讲，Binder 机制是优于内存共享的。</p>
<h4 id="安全性"><a href="#安全性" class="headerlink" title="安全性"></a>安全性</h4><p>另一方面就是安全性。Android 作为一个开放性的平台，市场上有各类海量的应用供用户选择安装，因此安全性对于 Android 平台而言极其重要。作为用户当然不希望我们下载的 APP 偷偷读取我的通信录，上传我的隐私数据，后台偷跑流量、消耗手机电量。传统的 IPC 没有任何安全措施，完全依赖上层协议来确保。首先传统的 IPC 接收方无法获得对方可靠的进程用户ID/进程ID（UID/PID），从而无法鉴别对方身份。Android 为每个安装好的 APP 分配了自己的 UID，故而进程的 UID 是鉴别进程身份的重要标志。传统的 IPC 只能由用户在数据包中填入 UID/PID，但这样不可靠，容易被恶意程序利用。可靠的身份标识只有由 IPC 机制在内核中添加。其次传统的 IPC 访问接入点是开放的，只要知道这些接入点的程序都可以和对端建立连接，不管怎样都无法阻止恶意程序通过猜测接收方地址获得连接。同时 Binder 既支持实名 Binder，又支持匿名 Binder，安全性高。</p>
<p>基于上述原因，Android 需要建立一套新的 IPC 机制来满足系统对稳定性、传输性能和安全性方面的要求，这就是 Binder。</p>
<p><strong>最后用一张表格来总结下 Binder 的优势：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">优势</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">性能</td>
<td style="text-align:left">只需要一次数据拷贝，性能上仅次于共享内存</td>
</tr>
<tr>
<td style="text-align:left">稳定性</td>
<td style="text-align:left">基于 C/S 架构，职责明确、架构清晰，因此稳定性好</td>
</tr>
<tr>
<td style="text-align:left">安全性</td>
<td style="text-align:left">为每个 APP 分配 UID，进程的 UID 是鉴别进程身份的重要标志</td>
</tr>
</tbody>
</table>
<h2 id="三-Linux-下传统的进程间通信原理"><a href="#三-Linux-下传统的进程间通信原理" class="headerlink" title="三. Linux 下传统的进程间通信原理"></a>三. Linux 下传统的进程间通信原理</h2><p>了解 Linux IPC 相关的概念和原理有助于我们理解 Binder 通信原理。因此，在介绍 Binder 跨进程通信原理之前，我们先聊聊 Linux 系统下传统的进程间通信是如何实现。</p>
<h3 id="3-1-基本概念介绍"><a href="#3-1-基本概念介绍" class="headerlink" title="3.1 基本概念介绍"></a>3.1 基本概念介绍</h3><p>这里我们先从 Linux 中进程间通信涉及的一些基本概念开始介绍，然后逐步展开，向大家说明传统的进程间通信的原理。</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/linux_ipc_1.png" alt="Linux 背景知识"></p>
<p>上图展示了 Liunx 中跨进程通信涉及到的一些基本概念：</p>
<ul>
<li>进程隔离</li>
<li>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</li>
<li>系统调用：用户态/内核态</li>
</ul>
<h4 id="进程隔离"><a href="#进程隔离" class="headerlink" title="进程隔离"></a>进程隔离</h4><p>简单的说就是操作系统中，进程与进程间内存是不共享的。两个进程就像两个平行的世界，A 进程没法直接访问 B 进程的数据，这就是进程隔离的通俗解释。A 进程和 B 进程之间要进行数据交互就得采用特殊的通信机制：进程间通信（IPC）。</p>
<h4 id="进程空间划分：用户空间-User-Space-内核空间-Kernel-Space"><a href="#进程空间划分：用户空间-User-Space-内核空间-Kernel-Space" class="headerlink" title="进程空间划分：用户空间(User Space)/内核空间(Kernel Space)"></a>进程空间划分：用户空间(User Space)/内核空间(Kernel Space)</h4><p>现在操作系统都是采用的虚拟存储器，对于 32 位系统而言，它的寻址空间（虚拟存储空间）就是 2 的 32 次方，也就是 4GB。操作系统的核心是内核，独立于普通的应用程序，可以访问受保护的内存空间，也可以访问底层硬件设备的权限。为了保护用户进程不能直接操作内核，保证内核的安全，操作系统从逻辑上将虚拟空间划分为用户空间（User Space）和内核空间（Kernel Space）。针对 Linux 操作系统而言，将最高的 1GB 字节供内核使用，称为内核空间；较低的 3GB 字节供各进程使用，称为用户空间。</p>
<blockquote>
<p>简单的说就是，内核空间（Kernel）是系统内核运行的空间，用户空间（User Space）是用户程序运行的空间。为了保证安全性，它们之间是隔离的。</p>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/android/binder/process_space.png" alt="图片来自网络"></p>
<h4 id="系统调用：用户态与内核态"><a href="#系统调用：用户态与内核态" class="headerlink" title="系统调用：用户态与内核态"></a>系统调用：用户态与内核态</h4><p>虽然从逻辑上进行了用户空间和内核空间的划分，但不可避免的用户空间需要访问内核资源，比如文件操作、访问网络等等。为了突破隔离限制，就需要借助<strong>系统调用</strong>来实现。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性。</p>
<p>Linux 使用两级保护机制：0 级供系统内核使用，3 级供用户程序使用。</p>
<p>当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于<strong>内核运行态（内核态）</strong>。此时处理器处于特权级最高的（0级）内核代码中执行。当进程处于内核态时，执行的内核代码会使用当前进程的内核栈。每个进程都有自己的内核栈。</p>
<p>当进程在执行用户自己的代码的时候，我们称其处于<strong>用户运行态（用户态）</strong>。此时处理器在特权级最低的（3级）用户代码中运行。</p>
<p>系统调用主要通过如下两个函数来实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">copy_from_user() //将数据从用户空间拷贝到内核空间</div><div class="line">copy_to_user() //将数据从内核空间拷贝到用户空间</div></pre></td></tr></table></figure>
<h3 id="3-2-Linux-下的传统-IPC-通信原理"><a href="#3-2-Linux-下的传统-IPC-通信原理" class="headerlink" title="3.2 Linux 下的传统 IPC 通信原理"></a>3.2 Linux 下的传统 IPC 通信原理</h3><p>理解了上面的几个概念，我们再来看看传统的 IPC 方式中，进程之间是如何实现通信的。</p>
<p>通常的做法是消息发送方将要发送的数据存放在内存缓存区中，通过系统调用进入内核态。然后内核程序在内核空间分配内存，开辟一块内核缓存区，调用 copy_from_user() 函数将数据从用户空间的内存缓存区拷贝到内核空间的内核缓存区中。同样的，接收方进程在接收数据时在自己的用户空间开辟一块内存缓存区，然后内核程序调用 copy_to_user() 函数将数据从内核缓存区拷贝到接收进程的内存缓存区。这样数据发送方进程和数据接收方进程就完成了一次数据传输，我们称完成了一次进程间通信。如下图：</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/linux_ipc_2.png" alt="传统 IPC 通信原理"></p>
<p>这种传统的 IPC 通信方式有两个问题：</p>
<ol>
<li>性能低下，一次数据传递需要经历：内存缓存区 –&gt; 内核缓存区 –&gt; 内存缓存区，需要 2 次数据拷贝；</li>
<li>接收数据的缓存区由数据接收进程提供，但是接收进程并不知道需要多大的空间来存放将要传递过来的数据，因此只能开辟尽可能大的内存空间或者先调用 API 接收消息头来获取消息体的大小，这两种做法不是浪费空间就是浪费时间。</li>
</ol>
<h2 id="四-Binder-跨进程通信原理"><a href="#四-Binder-跨进程通信原理" class="headerlink" title="四. Binder 跨进程通信原理"></a>四. Binder 跨进程通信原理</h2><p>理解了 Linux IPC 相关概念和通信原理，接下来我们正式介绍下 Binder IPC 的原理。</p>
<h3 id="4-1-动态内核可加载模块-amp-amp-内存映射"><a href="#4-1-动态内核可加载模块-amp-amp-内存映射" class="headerlink" title="4.1 动态内核可加载模块 &amp;&amp; 内存映射"></a>4.1 动态内核可加载模块 &amp;&amp; 内存映射</h3><p>正如前面所说，跨进程通信是需要内核空间做支持的。传统的 IPC 机制如管道、Socket 都是内核的一部分，因此通过内核支持来实现进程间通信自然是没问题的。但是 Binder 并不是 Linux 系统内核的一部分，那怎么办呢？这就得益于 Linux 的<strong>动态内核可加载模块</strong>（Loadable Kernel Module，LKM）的机制；模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。</p>
<blockquote>
<p>在 Android 系统中，这个运行在内核空间，负责各个用户进程通过 Binder 实现通信的内核模块就叫 <strong>Binder 驱动</strong>（Binder Dirver）。</p>
</blockquote>
<p>那么在 Android 系统中用户进程之间是如何通过这个内核模块（Binder 驱动）来实现通信的呢？难道是和前面说的传统 IPC 机制一样，先将数据从发送方进程拷贝到内核缓存区，然后再将数据从内核缓存区拷贝到接收方进程，通过两次拷贝来实现吗？显然不是，否则也不会有开篇所说的 Binder 在性能方面的优势了。</p>
<p>这就不得不通道 Linux 下的另一个概念：<strong>内存映射</strong>。</p>
<p>Binder IPC 机制中涉及到的内存映射通过 mmap() 来实现，mmap() 是操作系统中一种内存映射的方法。内存映射简单的讲就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。</p>
<p>内存映射能减少数据拷贝次数，实现用户空间和内核空间的高效互动。两个空间各自的修改能直接反映在映射的内存区域，从而被对方空间及时感知。也正因为如此，内存映射能够提供对进程间通信的支持。</p>
<h3 id="4-2-Binder-IPC-实现原理"><a href="#4-2-Binder-IPC-实现原理" class="headerlink" title="4.2 Binder IPC 实现原理"></a>4.2 Binder IPC 实现原理</h3><p>Binder IPC 正是基于内存映射（mmap）来实现的，但是 mmap() 通常是用在有物理介质的文件系统上的。</p>
<p>比如进程中的用户区域是不能直接和物理设备打交道的，如果想要把磁盘上的数据读取到进程的用户区域，需要两次拷贝（磁盘–&gt;内核空间–&gt;用户空间）；通常在这种场景下 mmap() 就能发挥作用，通过在物理介质和用户空间之间建立映射，减少数据的拷贝次数，用内存读写取代I/O读写，提高文件读取效率。</p>
<p>而 Binder 并不存在物理介质，因此 Binder 驱动使用 mmap() 并不是为了在物理介质和用户空间之间建立映射，而是用来在内核空间创建数据接收的缓存空间。</p>
<p>一次完整的 Binder IPC 通信过程通常是这样：</p>
<ol>
<li>首先 Binder 驱动在内核空间创建一个数据接收缓存区；</li>
<li>接着在内核空间开辟一块内核缓存区，建立<strong>内核缓存区</strong>和<strong>内核中数据接收缓存区</strong>之间的映射关系，以及<strong>内核中数据接收缓存区</strong>和<strong>接收进程用户空间地址</strong>的映射关系；</li>
<li>发送方进程通过系统调用 copy_from_user() 将数据 copy 到内核中的<strong>内核缓存区</strong>，由于内核缓存区和接收进程的用户空间存在内存映射，因此也就相当于把数据发送到了接收进程的用户空间，这样便完成了一次进程间的通信。</li>
</ol>
<p>如下图：</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_1.png" alt="Binder IPC 原理"></p>
<h2 id="五-Binder-通信模型"><a href="#五-Binder-通信模型" class="headerlink" title="五. Binder 通信模型"></a>五. Binder 通信模型</h2><p>介绍完 Binder IPC 的底层通信原理，接下来我们看看实现层面是如何设计的。</p>
<p>一次完整的进程间通信必然至少包含两个进程，通常我们称通信的双方分别为客户端进程（Client）和服务端进程（Server），由于进程隔离机制的存在，通信双方必然需要借助 Binder 来实现。</p>
<h3 id="5-1-Client-Server-ServiceManager-驱动"><a href="#5-1-Client-Server-ServiceManager-驱动" class="headerlink" title="5.1 Client/Server/ServiceManager/驱动"></a>5.1 Client/Server/ServiceManager/驱动</h3><p>前面我们介绍过，Binder 是基于 C/S 架构的。由一系列的组件组成，包括 Client、Server、ServiceManager、Binder 驱动。其中 Client、Server、Service Manager 运行在用户空间，Binder 驱动运行在内核空间。其中 Service Manager 和 Binder 驱动由系统提供，而 Client、Server 由应用程序来实现。Client、Server 和 ServiceManager 均是通过系统调用 open、mmap 和 ioctl 来访问设备文件 /dev/binder，从而实现与 Binder 驱动的交互来间接的实现跨进程通信。</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_2.png" alt=""></p>
<p>Client、Server、ServiceManager、Binder 驱动这几个组件在通信过程中扮演的角色就如同互联网中服务器（Server）、客户端（Client）、DNS域名服务器（ServiceManager）以及路由器（Binder 驱动）之前的关系。</p>
<p>通常我们访问一个网页的步骤是这样的：首先在浏览器输入一个地址，如 www.google.com 然后按下回车键。但是并没有办法通过域名地址直接找到我们要访问的服务器，因此需要首先访问 DNS 域名服务器，域名服务器中保存了 www.google.com 对应的 ip 地址 10.249.23.13，然后通过这个 ip 地址才能放到到 www.google.com 对应的服务器。</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_3.png" alt="互联网通信模型"></p>
<p><em><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder 设计与实现</a>一文中对 Client、Server、ServiceManager、Binder 驱动有很详细的描述，以下是部分摘录：</em></p>
<blockquote>
<p><strong>Binder 驱动</strong><br>Binder 驱动就如同路由器一样，是整个通信的核心；驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持。 <br><br><strong>ServiceManager 与实名 Binder</strong><br>ServiceManager 和 DNS 类似，作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。注册了名字的 Binder 叫实名 Binder，就像网站一样除了除了有 IP 地址意外还有自己的网址。Server 创建了 Binder，并为它起一个字符形式，可读易记得名字，将这个 Binder 实体连同名字一起以数据包的形式通过 Binder 驱动发送给 ServiceManager ，通知 ServiceManager 注册一个名为“张三”的 Binder，它位于某个 Server 中。驱动为这个穿越进程边界的 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager。ServiceManger 收到数据后从中取出名字和引用填入查找表。<br><br>细心的读者可能会发现，ServierManager 是一个进程，Server 是另一个进程，Server 向 ServiceManager 中注册 Binder 必然涉及到进程间通信。当前实现进程间通信又要用到进程间通信，这就好像蛋可以孵出鸡的前提却是要先找只鸡下蛋！Binder 的实现比较巧妙，就是预先创造一只鸡来下蛋。ServiceManager 和其他进程同样采用 Bidner 通信，ServiceManager 是 Server 端，有自己的 Binder 实体，其他进程都是 Client，需要通过这个 Binder 的引用来实现 Binder 的注册，查询和获取。ServiceManager 提供的 Binder 比较特殊，它没有名字也不需要注册。当一个进程使用 BINDER_SET_CONTEXT_MGR 命令将自己注册成 ServiceManager 时 Binder 驱动会自动为它创建 Binder 实体（<strong>这就是那只预先造好的那只鸡</strong>）。其次这个 Binder 实体的引用在所有 Client 中都固定为 0 而无需通过其它手段获得。也就是说，一个 Server 想要向 ServiceManager 注册自己的 Binder 就必须通过这个 0 号引用和 ServiceManager 的 Binder 通信。类比互联网，0 号引用就好比是域名服务器的地址，你必须预先动态或者手工配置好。要注意的是，这里说的 Client 是相对于 ServiceManager 而言的，一个进程或者应用程序可能是提供服务的 Server，但对于 ServiceManager 来说它仍然是个 Client。<br><br><strong>Client 获得实名 Binder 的引用</strong><br>Server 向 ServiceManager 中注册了 Binder 以后， Client 就能通过名字获得 Binder 的引用了。Client 也利用保留的 0 号引用向 ServiceManager 请求访问某个 Binder: 我申请访问名字叫张三的 Binder 引用。ServiceManager 收到这个请求后从请求数据包中取出 Binder 名称，在查找表里找到对应的条目，取出对应的 Binder 引用作为回复发送给发起请求的 Client。从面向对象的角度看，Server 中的 Binder 实体现在有两个引用：一个位于 ServiceManager 中，一个位于发起请求的 Client 中。如果接下来有更多的 Client 请求该 Binder，系统中就会有更多的引用指向该 Binder ，就像 Java 中一个对象有多个引用一样。</p>
</blockquote>
<h3 id="5-2-Binder-通信过程"><a href="#5-2-Binder-通信过程" class="headerlink" title="5.2 Binder 通信过程"></a>5.2 Binder 通信过程</h3><p>至此，我们大致能总结出 Binder 通信过程：</p>
<ol>
<li>首先，一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册成为 ServiceManager；</li>
<li>Server 通过驱动向 ServiceManager 中注册 Binder（Server 中的 Binder 实体），表明可以对外提供服务。驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过名字，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
</ol>
<p>我们看到整个通信过程都需要 Binder 驱动的接入。下图能更加直观的展现整个通信过程(为了进一步抽象通信过程以及呈现上的方便，下图我们忽略了 Binder 实体及其引用的概念)：</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_4.png" alt="Binder 通信模型"></p>
<h3 id="5-3-Binder-通信中的代理模式"><a href="#5-3-Binder-通信中的代理模式" class="headerlink" title="5.3 Binder 通信中的代理模式"></a>5.3 Binder 通信中的代理模式</h3><p>我们已经解释清楚 Client、Server 借助 Binder 驱动完成跨进程通信的实现机制了，但是还有个问题会让我们困惑。A 进程想要 B 进程中某个对象（object）是如何实现的呢？毕竟它们分属不同的进程，A 进程 没法直接使用 B 进程中的 object。</p>
<p>前面我们介绍过跨进程通信的过程都有 Binder 驱动的参与，因此在数据流经 Binder 驱动的时候驱动会对数据做一层转换。当 A 进程想要获取 B 进程中的 object 时，驱动并不会真的把 object 返回给 A，而是返回了一个跟 object 看起来一模一样的代理对象 objectProxy，这个 objectProxy 具有和 object 一摸一样的方法，但是这些方法并没有 B 进程中 object 对象那些方法的能力，这些方法只需要把把请求参数交给驱动即可。对于 A 进程来说和直接调用 object 中的方法是一样的。</p>
<p>当 Binder 驱动接收到 A 进程的消息后，发现这是个 objectProxy 就去查询自己维护的表单，一查发现这是 B 进程 object 的代理对象。于是就会去通知 B 进程调用 object 的方法，并要求 B 进程把返回结果发给自己。当驱动拿到 B 进程的返回结果后就会转发给 A 进程，一次通信就完成了。</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/binder_ipc_5.png" alt=""></p>
<h3 id="5-4-Binder-的完整定义"><a href="#5-4-Binder-的完整定义" class="headerlink" title="5.4 Binder 的完整定义"></a>5.4 Binder 的完整定义</h3><p>现在我们可以对 Binder 做个更加全面的定义了：</p>
<ul>
<li>从进程间通信的角度看，Binder 是一种进程间通信的机制；</li>
<li>从 Server 进程的角度看，Binder 指的是 Server 中的 Binder 实体对象；</li>
<li>从 Client 进程的角度看，Binder 指的是对 Binder 代理对象，是 Binder 实体对象的一个远程代理</li>
<li>从传输过程的角度看，Binder 是一个可以跨进程传输的对象；Binder 驱动会对这个跨越进程边界的对象对一点点特殊处理，自动完成代理对象和本地对象之间的转换。</li>
</ul>
<h2 id="六-手动编码实现跨进程调用"><a href="#六-手动编码实现跨进程调用" class="headerlink" title="六. 手动编码实现跨进程调用"></a>六. 手动编码实现跨进程调用</h2><p>通常我们在做开发时，实现进程间通信用的最多的就是 AIDL。当我们定义好 AIDL 文件，在编译时编译器会帮我们生成代码实现 IPC 通信。借助 AIDL 编译以后的代码能帮助我们进一步理解 Binder IPC 的通信原理。</p>
<p>但是无论是从可读性还是可理解性上来看，编译器生成的代码对开发者并不友好。比如一个 BookManager.aidl 文件对应会生成一个 BookManager.java 文件，这个 java 文件包含了一个 BookManager 接口、一个 Stub 静态的抽象类和一个 Proxy 静态类。Proxy 是 Stub 的静态内部类，Stub 又是 BookManager 的静态内部类，这就造成了可读性和可理解性的问题。</p>
<blockquote>
<p>Android 之所以这样设计其实是有道理的，因为当有多个 AIDL 文件的时候把 BookManager、Stub、Proxy 放在同一个文件里能有效避免 Stub 和 Proxy 重名的问题。</p>
</blockquote>
<p>因此便于大家理解，下面我们来手动编写代码来实现跨进程调用。</p>
<h3 id="6-1-各-Java-类职责描述"><a href="#6-1-各-Java-类职责描述" class="headerlink" title="6.1 各 Java 类职责描述"></a>6.1 各 Java 类职责描述</h3><p>在正式编码实现跨进程调用之前，先介绍下实现过程中用到的一些类。了解了这些类的职责，有助于我们更好的理解和实现跨进程通信。</p>
<ul>
<li><p><strong>IBinder</strong> : IBinder 是一个接口，代表了一种跨进程通信的能力。只要实现了这个借口，这个对象就能跨进程传输。</p>
</li>
<li><p><strong>IInterface</strong> :  IInterface 代表的就是 Server 进程对象具备什么样的能力（能提供哪些方法，其实对应的就是 AIDL 文件中定义的接口）</p>
</li>
<li><p><strong>Binder</strong> : Java 层的 Binder 类，代表的其实就是 Binder 本地对象。BinderProxy 类是 Binder 类的一个内部类，它代表远程进程的 Binder 对象的本地代理；这两个类都继承自 IBinder, 因而都具有跨进程传输的能力；实际上，在跨越进程的时候，Binder 驱动会自动完成这两个对象的转换。</p>
</li>
<li><p><strong>Stub</strong> : AIDL 的时候，编译工具会给我们生成一个名为 Stub 的静态内部类；这个类继承了 Binder, 说明它是一个 Binder 本地对象，它实现了 IInterface 接口，表明它具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要开发者自己实现。</p>
</li>
</ul>
<h3 id="6-2-实现过程讲解"><a href="#6-2-实现过程讲解" class="headerlink" title="6.2 实现过程讲解"></a>6.2 实现过程讲解</h3><p>一次跨进程通信必然会涉及到两个进程，在这个例子中 RemoteService 作为服务端进程，提供服务；ClientActivity 作为客户端进程，使用 RemoteService 提供的服务。如下图：</p>
<p><img src="http://resources.baronzhang.com/blog/android/binder/ipc_1.png" alt=""></p>
<p>那么服务端进程具备什么样的能力？能为客户端提供什么样的服务呢？还记得我们前面介绍过的 IInterface 吗，它代表的就是服务端进程具体什么样的能力。因此我们需要定义一个 BookManager 接口，BookManager 继承自 IIterface，表明服务端具备什么样的能力。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 这个类用来定义服务端 RemoteService 具备什么样的能力</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BookManager</span> <span class="keyword">extends</span> <span class="title">IInterface</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>只定义服务端具备什么要的能力是不够的，既然是跨进程调用，那么接下来我们得实现一个跨进程调用对象 Stub。Stub 继承 Binder, 说明它是一个 Binder 本地对象；实现 IInterface 接口，表明具有 Server 承诺给 Client 的能力；Stub 是一个抽象类，具体的 IInterface 的相关实现需要调用方自己实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">BookManager</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> BookManager <span class="title">asInterface</span><span class="params">(IBinder binder)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (binder == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">        IInterface iin = binder.queryLocalInterface(DESCRIPTOR);</div><div class="line">        <span class="keyword">if</span> (iin != <span class="keyword">null</span> &amp;&amp; iin <span class="keyword">instanceof</span> BookManager)</div><div class="line">            <span class="keyword">return</span> (BookManager) iin;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Proxy(binder);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, Parcel data, Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line">        <span class="keyword">switch</span> (code) &#123;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> INTERFACE_TRANSACTION:</div><div class="line">                reply.writeString(DESCRIPTOR);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">            <span class="keyword">case</span> TRANSAVTION_addBook:</div><div class="line">                data.enforceInterface(DESCRIPTOR);</div><div class="line">                Book arg0 = <span class="keyword">null</span>;</div><div class="line">                <span class="keyword">if</span> (data.readInt() != <span class="number">0</span>) &#123;</div><div class="line">                    arg0 = Book.CREATOR.createFromParcel(data);</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">this</span>.addBook(arg0);</div><div class="line">                reply.writeNoException();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line"></div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Stub 类中我们重点介绍下 <code>asInterface</code> 和 <code>onTransact</code>。</p>
<p>先说说 <code>asInterface</code>，当 Client 端在创建和服务端的连接，调用 bindService 时需要创建一个 ServiceConnection 对象作为入参。在 ServiceConnection 的回调方法 onServiceConnected 中 会通过这个 asInterface(IBinder binder) 拿到 BookManager 对象，这个 IBinder 类型的入参 binder 是驱动传给我们的，正如你在代码中看到的一样，方法中会去调用 binder.queryLocalInterface() 去查找 Binder 本地对象，如果找到了就说明 Client 和 Server 在同一进程，那么这个 binder 本身就是 Binder 本地对象，可以直接使用。否则说明是 binder 是个远程对象，也就是 BinderProxy。因此需要我们创建一个代理对象 Proxy，通过这个代理对象来是实现远程访问。</p>
<p>接下来我们就要实现这个代理类 Proxy 了，既然是代理类自然需要实现 BookManager 接口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">BookManager</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Proxy</span><span class="params">(IBinder remote)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.remote = remote;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBook</span><span class="params">(Book book)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</div><div class="line"></div><div class="line">        Parcel data = Parcel.obtain();</div><div class="line">        Parcel replay = Parcel.obtain();</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            data.writeInterfaceToken(DESCRIPTOR);</div><div class="line">            <span class="keyword">if</span> (book != <span class="keyword">null</span>) &#123;</div><div class="line">                data.writeInt(<span class="number">1</span>);</div><div class="line">                book.writeToParcel(data, <span class="number">0</span>);</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                data.writeInt(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line">            remote.transact(Stub.TRANSAVTION_addBook, data, replay, <span class="number">0</span>);</div><div class="line">            replay.readException();</div><div class="line">        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">            replay.recycle();</div><div class="line">            data.recycle();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看看 addBook() 的实现；在 Stub 类中，addBook(Book book) 是一个抽象方法，Client 端需要继承并实现它。</p>
<ul>
<li>如果 Client 和 Server 在同一个进程，那么直接就是调用这个方法。</li>
<li>如果是远程调用，Client 想要调用 Server 的方法就需要通过 Binder 代理来完成，也就是上面的 Proxy。</li>
</ul>
<p>在 Proxy 中的 addBook() 方法中首先通过 Parcel 将数据序列化，然后调用 remote.transact()。正如前文所述 Proxy 是在 Stub 的 asInterface 中创建，能走到创建 Proxy 这一步就说明 Proxy 构造函数的入参是 BinderProxy，即这里的 remote 是个 BinderProxy 对象。最终通过一系列的函数调用，Client 进程通过系统调用陷入内核态，Client 进程中执行 addBook() 的线程挂起等待返回；驱动完成一系列的操作之后唤醒 Server 进程，调用 Server 进程本地对象的 onTransact()。最终又走到了 Stub 中的 onTransact() 中，onTransact() 根据函数编号调用相关函数（在 Stub 类中为 BookManager 接口中的每个函数中定义了一个编号，只不过上面的源码中我们简化掉了；在跨进程调用的时候，不会传递函数而是传递编号来指明要调用哪个函数）；我们这个例子里面，调用了 Binder 本地对象的 addBook() 并将结果返回给驱动，驱动唤醒 Client 进程里刚刚挂起的线程并将结果返回。</p>
<p>这样一次跨进程调用就完成了。</p>
<p>完整的代码我放到 GitHub 上了，有兴趣的小伙伴可以去看看。源码地址：<a href="https://github.com/BaronZ88/HelloBinder" target="_blank" rel="external">https://github.com/BaronZ88/HelloBinder</a></p>
<p>最后建议大家在不借助 AIDL 的情况下手写实现 Client 和 Server 进程的通信，加深对 Binder 通信过程的理解。</p>
<blockquote>
<p>受个人能力水平限制，文章中难免会有错误。如果大家发现文章不足之处，欢迎与我沟通交流。</p>
</blockquote>
<p><strong>本文在写作过程中参考了很多文章、书籍和源码，其中有很多描述和图片都借鉴了下面的文章，在这里感谢大佬们的无私分享！</strong></p>
<p><strong>参考资料如下：</strong></p>
<ul>
<li><a href="http://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder 设计与实现 - 设计篇</a></li>
<li><a href="http://blog.csdn.net/luoshengyang/article/details/6618363" target="_blank" rel="external">Android 进程间通信（IPC）机制 Binder 简要介绍和学习计划</a>、<a href="http://item.jd.com/12248208.html" target="_blank" rel="external">《Android 系统源代码情景分析》</a></li>
<li><a href="http://weishu.me/2016/01/12/binder-index-for-newer/" target="_blank" rel="external">Binder 学习指南</a></li>
<li><a href="http://gityuan.com/2015/10/31/binder-prepare/" target="_blank" rel="external">Binder 系列文章</a></li>
<li><a href="https://blog.csdn.net/carson_ho/article/details/73560642" target="_blank" rel="external">Android 图文详解 Binder 跨进程通信原理</a></li>
<li><a href="http://www.cnblogs.com/innost/archive/2011/01/09/1931456.html" target="_blank" rel="external">Android 深入浅出之 Binder 机制</a></li>
<li><a href="http://www.cnblogs.com/Anker/p/3269106.html" target="_blank" rel="external">用户空间与内核空间</a></li>
<li><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="external">认真分析 mmap ：是什么 为什么 怎么用</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<div align="center"><img src="http://resources.baronzhang.com/blog/common/gzh3.png" width="85%"></div>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/blog/android/binder/header.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一-前言&quot;&gt;&lt;a href=&quot;#一-前言&quot; class=&quot;headerlink&quot; title=&quot;一. 前言&quot;&gt;&lt;/a&gt;一. 前言&lt;/h2&gt;&lt;p&gt;这篇文章我酝酿了很久，参考了很多资料，读了很多源码，却依旧不敢下笔。生怕自己理解上还有偏差，对大家造成误解，贻笑大方。又怕自己理解不够透彻，无法用清晰直白的文字准确的表达出 Binder 的设计精髓。直到今天提笔写作时还依旧战战兢兢。&lt;/p&gt;
&lt;p&gt;Binder 之复杂远远不是一篇文章就能说清楚的，本文想站在一个更高的维度来俯瞰 Binder 的设计，最终帮助大家形成一个完整的概念。对于应用层开发的同学来说，理解到本文这个程度也就差不多了。希望更加深入理解 Binder 实现机制的，可以阅读文末的参考资料以及相关源码。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://baronzhang.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="Binder" scheme="http://baronzhang.com/tags/Binder/"/>
    
      <category term="IPC" scheme="http://baronzhang.com/tags/IPC/"/>
    
  </entry>
  
  <entry>
    <title>为 Retrofit2 提供的 FastJson 转换库</title>
    <link href="http://baronzhang.com//blog/Android/%E4%B8%BA-Retrofit2-%E6%8F%90%E4%BE%9B%E7%9A%84-FastJson-%E8%BD%AC%E6%8D%A2%E5%BA%93/"/>
    <id>http://baronzhang.com//blog/Android/为-Retrofit2-提供的-FastJson-转换库/</id>
    <published>2017-05-17T05:15:49.000Z</published>
    <updated>2019-08-19T06:53:46.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>为 Retrofit2 提供的 FastJson 转换器（Retrofit2-FastJson-Converter）</p>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Retrofit 是 Android 和 Java 平台上一款优秀且被广泛使用的 Http 客户端，GitHub 上 21K+ 的 Star 和 4.3K+ 的 Fork 充分证明了 Retrofit 的风靡程度。</p>
<p>Retrofit 在 Android 平台如此流行与它及其简洁的调用方式和优秀的可扩展、可配置性是分不开的。我们客户端在和服务端交互的时候通常采用 Json 格式来传递数据，客户端拿到服务端传递过来的 Json 格式的数据后需要对它进行解析；Retrofit2 并未提供 Json 解析功能，但可提供接口让客户端程序员配置 Json Converter以选择自己喜欢的 Json 解析库。</p>
<a id="more"></a>
<p>Json 解析库有很多：Gson、Jackson、FastJson等等。Retrofit 优秀的可配置性可以让我们客户端程序员随意选择心怡的 Json 解析库，Retrofit 针对 Gson 和 Jackson 都提供相应的 Converter；可能由于 FastJson 是国内程序员开发的原因，Retrofit 对于 FastJson 并没有提供对应的 Converter ，这对于使用 FastJson 的开发者是不友好的。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>好在 Retrofit 提供了接口来让开发者实现自己的 Json Converter 。实现 Converter 虽然简单，但每次使用 Retrofit2 + FastJson 组合时都实现一套显然是没必要的。我使用 FastJson 实现了一个 Converter: <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a> ，有同样需求的同学只需要使用我这个 Converter 库就好啦，不必再去自定义。使用方式如下：</p>
<h3 id="1、添加依赖配置"><a href="#1、添加依赖配置" class="headerlink" title="1、添加依赖配置"></a>1、添加依赖配置</h3><p><strong>Step 1</strong>. 由于 <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a>  是发布到 JitPack 的，因此首先需要在项目根目录的 build.gradle 中加入 JitPack 的仓库地址，具体配置如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">allprojects &#123;</div><div class="line">	repositories &#123;</div><div class="line">		...</div><div class="line">		maven &#123; url <span class="string">'https://jitpack.io'</span> &#125;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>Step 2</strong>. 在具体使用 <a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">Retrofit2-FastJson-Converter</a> 的 module 中加入依赖配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">dependencies &#123;</div><div class="line">	compile <span class="string">'com.github.BaronZ88:Retrofit2-FastJson-Converter:lastVersion'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2、配置-Retrofit-Converter"><a href="#2、配置-Retrofit-Converter" class="headerlink" title="2、配置 Retrofit Converter"></a>2、配置 Retrofit Converter</h3><p>在 Retrofit.Builder 的 addConverterFactory 方法中传入 <code>FastJsonConverterFactory.create()</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</div><div class="line">      .baseUrl(baseUrl)</div><div class="line">      .addConverterFactory(FastJsonConverterFactory.create())</div><div class="line">      .addCallAdapterFactory(RxJavaCallAdapterFactory.create())</div><div class="line">      .client(client)</div><div class="line">      .build();</div></pre></td></tr></table></figure>
<p>最后贴上 Retrofit2-FastJson-Converter 源码地址 ：<a href="https://github.com/BaronZ88/Retrofit2-FastJson-Converter" target="_blank" rel="external">https://github.com/BaronZ88/Retrofit2-FastJson-Converter</a></p>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p><strong>一直不满意各博客平台上的阅读体验，排版糟糕、布局混乱、字体丑陋、各种广告及杂七杂八的组件分散了读者宝贵的注意力；最最重要的是这年头竟然找不到一个优雅、简介、有美感的博客平台！！！我不能忍！为了赏脸阅读我文章的读者！为了我这仅剩的一点点审美！我采用 GitHub Pages + Hexo + NexT 搭建了个人博客 <a href="http://baronzhang.com">http://baronzhang.com</a> ，不过身为拖延症晚期患者的我，直到最近才将博客系统的各项功能陆续完善起来。之前的文章均已同步，之后所有的文章也会第一时间在个人博客上发布，追求更好阅读体验的同学可以移步 <a href="http://baronzhang.com">baronzhang.com</a> 。</strong></p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;为 Retrofit2 提供的 FastJson 转换器（Retrofit2-FastJson-Converter）&lt;/p&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;Retrofit 是 Android 和 Java 平台上一款优秀且被广泛使用的 Http 客户端，GitHub 上 21K+ 的 Star 和 4.3K+ 的 Fork 充分证明了 Retrofit 的风靡程度。&lt;/p&gt;
&lt;p&gt;Retrofit 在 Android 平台如此流行与它及其简洁的调用方式和优秀的可扩展、可配置性是分不开的。我们客户端在和服务端交互的时候通常采用 Json 格式来传递数据，客户端拿到服务端传递过来的 Json 格式的数据后需要对它进行解析；Retrofit2 并未提供 Json 解析功能，但可提供接口让客户端程序员配置 Json Converter以选择自己喜欢的 Json 解析库。&lt;/p&gt;
    
    </summary>
    
      <category term="Android" scheme="http://baronzhang.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android 模块化探索与实践</title>
    <link href="http://baronzhang.com//blog/Framework/Android-%E6%A8%A1%E5%9D%97%E5%8C%96%E6%8E%A2%E7%B4%A2%E4%B8%8E%E5%AE%9E%E8%B7%B5/"/>
    <id>http://baronzhang.com//blog/Framework/Android-模块化探索与实践/</id>
    <published>2017-05-08T06:04:12.000Z</published>
    <updated>2019-08-19T06:53:46.660Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/blog/framework/android/2/header.jpg" alt=""></p>
<blockquote>
<p>首发于《程序员》杂志五月刊</p>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>万维网发明人 Tim Berners-Lee 谈到设计原理时说过：“简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。” 由此可见模块化之于软件工程领域的重要性。</p>
<p>从 2016 年开始，模块化在 Android 社区越来越多的被提及。随着移动平台的不断发展，移动平台上的软件慢慢走向复杂化，体积也变得臃肿庞大；为了降低大型软件复杂性和耦合度，同时也为了适应模块重用、多团队并行开发测试等等需求，模块化在 Android 平台上变得势在必行。阿里 Android 团队在年初开源了他们的容器化框架 Atlas 就很大程度说明了当前 Android 平台开发大型商业项目所面临的问题。</p>
<a id="more"></a>
<h2 id="什么是模块化"><a href="#什么是模块化" class="headerlink" title="什么是模块化"></a>什么是模块化</h2><p>那么什么是模块化呢？《 Java 应用架构设计：模块化模式与 OSGi 》一书中对它的定义是：模块化是一种处理复杂系统分解为更好的可管理模块的方式。</p>
<p>上面这种描述太过生涩难懂，不够直观。下面这种类比的方式则可能加容易理解。</p>
<p>我们可以把软件看做是一辆汽车，开发一款软件的过程就是生产一辆汽车的过程。一辆汽车由车架、发动机、变数箱、车轮等一系列模块组成；同样，一款大型商业软件也是由各个不同的模块组成的。</p>
<p>汽车的这些模块是由不同的工厂生产的，一辆 BMW 的发动机可能是由位于德国的工厂生产的，它的自动变数箱可能是 Jatco（世界三大变速箱厂商之一）位于日本的工厂生产的，车轮可能是中国的工厂生产的，最后交给华晨宝马的工厂统一组装成一辆完整的汽车。这就类似于我们在软件工程领域里说的多团队并行开发，最后将各个团队开发的模块统一打包成我们可使用的 App 。</p>
<p>一款发动机、一款变数箱都不可能只应用于一个车型，比如同一款 Jatco 的 6AT 自动变速箱既可能被安装在 BMW 的车型上，也可能被安装在 Mazda 的车型上。这就如同软件开发领域里的模块重用。</p>
<p>到了冬天，特别是在北方我们可能需要开着车走雪路，为了安全起见往往我们会将汽车的公路胎升级为雪地胎；轮胎可以很轻易的更换，这就是我们在软件开发领域谈到的低耦合。一个模块的升级替换不会影响到其它模块，也不会受其它模块的限制；同时这也类似于我们在软件开发领域提到的可插拔。</p>
<h2 id="模块化分层设计"><a href="#模块化分层设计" class="headerlink" title="模块化分层设计"></a>模块化分层设计</h2><p>上面的类比很清晰的说明的模块化带来的好处：</p>
<ul>
<li>多团队并行开发测试；</li>
<li>模块间解耦、重用；</li>
<li>可单独编译打包某一模块，提升开发效率。</li>
</ul>
<p>在<a href="https://zhuanlan.zhihu.com/p/25420181" target="_blank" rel="external">《安居客 Android 项目架构演进》</a>这篇文章中，我介绍了安居客 Android 端的模块化设计方案，这里我还是拿它来举例。但首先要对本文中的<strong>组件</strong>和<strong>模块</strong>做个区别定义</p>
<ul>
<li><p><strong>组件</strong>：指的是单一的功能组件，如地图组件（MapSDK）、支付组件（AnjukePay）、路由组件（Router）等等；</p>
</li>
<li><p><strong>模块</strong>：指的是独立的业务模块，如新房模块（NewHouseModule）、二手房模块（SecondHouseModule）、即时通讯模块（InstantMessagingModule）等等；模块相对于组件来说粒度更大。</p>
</li>
</ul>
<p>具体设计方案如下图：</p>
<p><img src="http://resources.baronzhang.com/blog/framework/android/2/modularization.png" alt="Android 模块化设计方案"></p>
<p>整个项目分为三层，从下至上分别是：</p>
<ul>
<li>Basic Component Layer: 基础组件层，顾名思义就是一些基础组件，包含了各种开源库以及和业务无关的各种自研工具库；</li>
<li>Business Component Layer: 业务组件层，这一层的所有组件都是业务相关的，例如上图中的支付组件 AnjukePay、数据模拟组件 DataSimulator 等等；</li>
<li>Business Module Layer: 业务 Module 层，在 Android Studio 中每块业务对应一个单独的 Module。例如安居客用户 App 我们就可以拆分成新房 Module、二手房 Module、IM Module 等等，每个单独的 Business Module 都必须准遵守我们自己的 MVP 架构。</li>
</ul>
<p>我们在谈模块化的时候，其实就是将业务模块层的各个功能业务拆分层独立的业务模块。所以我们进行模块化的第一步就是业务模块划分，但是模块划分并没有一个业界通用的标准，因此划分的粒度需要根据项目情况进行合理把控，这就需要对业务和项目有较为透彻的理解。拿安居客来举例，我们会将项目划分为新房模块、二手房模块、IM 模块等等。</p>
<p>每个业务模块在 Android Studio 中的都是一个 Module ,因此在命名方面我们要求每个业务模块都以 Module 为后缀。如下图所示：<div align="left"><img src="http://resources.baronzhang.com/blog/framework/android/2/modules.png" width="40%" alt="图片名称" align="center"></div></p>
<p>对于模块化项目，每个单独的 Business Module 都可以单独编译成 APK。在开发阶段需要单独打包编译，项目发布的时候又需要它作为项目的一个 Module 来整体编译打包。简单的说就是开发时是 Application，发布时是 Library。因此需要在 Business Module 的 build.gradle 中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isBuildModule.toBoolean())&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>isBuildModule 在项目根目录的 gradle.properties 中定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&gt; isBuildModule=<span class="keyword">false</span></div><div class="line">&gt;</div></pre></td></tr></table></figure>
</blockquote>
<p>同样 Manifest.xml 也需要有两套：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">sourceSets &#123;</div><div class="line">   main &#123;</div><div class="line">       <span class="keyword">if</span> (isBuildModule.toBoolean()) &#123;</div><div class="line">           manifest.srcFile <span class="string">'src/main/debug/AndroidManifest.xml'</span></div><div class="line">       &#125; <span class="keyword">else</span> &#123;</div><div class="line">           manifest.srcFile <span class="string">'src/main/release/AndroidManifest.xml'</span></div><div class="line">       &#125;</div><div class="line">   &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如图：<div align="left"><img src="http://resources.baronzhang.com/blog/framework/android/2/manifest.png" width="45%" alt="图片名称" align="center"></div></p>
<p>debug 模式下的 AndroidManifest.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span></span></div><div class="line">   <span class="attr">...</span></div><div class="line">   &gt;</div><div class="line">   <span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">       <span class="attr">android:name</span>=<span class="string">"com.baronzhang.android.newhouse.NewHouseMainActivity"</span></div><div class="line">       <span class="attr">android:label</span>=<span class="string">"@string/new_house_label_home_page"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.MAIN"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.LAUNCHER"</span> /&gt;</span></div><div class="line">       <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></div></pre></td></tr></table></figure>
<p>realease 模式下的 AndroidManifest.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">application</span></span></div><div class="line">   <span class="attr">...</span></div><div class="line">   &gt;</div><div class="line">   <span class="tag">&lt;<span class="name">activity</span></span></div><div class="line">       <span class="attr">android:name</span>=<span class="string">"com.baronzhang.android.newhouse.NewHouseMainActivity"</span></div><div class="line">       <span class="attr">android:label</span>=<span class="string">"@string/new_house_label_home_page"</span>&gt;</div><div class="line">       <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.DEFAULT"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">category</span> <span class="attr">android:name</span>=<span class="string">"android.intent.category.BROWSABLE"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">"android.intent.action.VIEW"</span> /&gt;</span></div><div class="line">           <span class="tag">&lt;<span class="name">data</span> <span class="attr">android:host</span>=<span class="string">"com.baronzhang.android.newhouse"</span></span></div><div class="line">               <span class="attr">android:scheme</span>=<span class="string">"router"</span> /&gt;</div><div class="line">       <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></div><div class="line">   <span class="tag">&lt;/<span class="name">activity</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">application</span>&gt;</span></div></pre></td></tr></table></figure>
<p>同时针对模块化我们也定义了一些自己的游戏规则:</p>
<ul>
<li>对于 Business Module Layer，各业务模块之间不允许存在相互依赖关系，它们之间的跳转通讯采用路由框架 Router 来实现（后面会介绍 Router 框架的实现）;</li>
<li>对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，个性化需求对外部提供接口让调用方定制;</li>
<li>合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分;</li>
<li>上层的公有业务或者功能模块可以逐步下放到下层，合理把握好度就好；</li>
<li>各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。</li>
</ul>
<h2 id="模块间跳转通讯（Router）"><a href="#模块间跳转通讯（Router）" class="headerlink" title="模块间跳转通讯（Router）"></a>模块间跳转通讯（Router）</h2><p>对业务进行模块化拆分后，为了使各业务模块间解耦，因此各个 Bussiness Module 都是独立的模块，它们之间是没有依赖关系。那么各个模块间的跳转通讯如何实现呢？</p>
<p>比如业务上要求从<strong>新房的列表页</strong>跳转到<strong>二手房的列表页</strong>，那么由于是 NewHouseModule 和 SecondHouseModule 之间并不相互依赖，我们通过想如下这种显式跳转的方式来实现 Activity 跳转显然是不可能的实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(NewHouseListActivity.<span class="keyword">this</span>, SecondHouseListActivity.class);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>有的同学可能会想到用隐式跳转，通过 Intent 匹配规则来实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_VIEW, <span class="string">"&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/&lt;path&gt;"</span>);</div><div class="line">startActivity(intent);</div></pre></td></tr></table></figure>
<p>但是这种代码写起来比较繁琐，且容易出错，出错也不太容易定位问题。因此一个简单易用、解放开发的路由框架是必须的了。<div align="left"><img src="http://resources.baronzhang.com/blog/framework/android/2/router2.png" width="45%" alt="图片名称" align="center"></div></p>
<p>我自己实现的路由框架分为<b>路由（Router）</b> 和<b>参数注入器（Injector）</b> 两部分：<div align="left"><img src="http://resources.baronzhang.com/blog/framework/android/2/router.png" width="45%" alt="图片名称" align="center"></div></p>
<blockquote>
<p>Router 提供 Activity 跳转传参的功能；Injector 提供参数注入功能，通过编译时生成代码的方式在 Activity 获取获取传递过来的参数，简化开发。</p>
</blockquote>
<h3 id="Router"><a href="#Router" class="headerlink" title="Router"></a>Router</h3><p>路由（Router）部分通过 Java 注解结合动态代理来实现，这一点和 Retrofit 的实现原理是一样的。</p>
<p>首先需要定义我们自己的注解（篇幅有限，这里只列出少部分源码）。</p>
<p>用于定义跳转 URI 的注解 FullUri：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.METHOD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> FullUri &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于定义跳转传参的 UriParam（ UriParam 注解的参数用于拼接到 URI 后面）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> UriParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>用于定义跳转传参的 IntentExtrasParam（ IntentExtrasParam 注解的参数最终通过 Intent 来传递）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.PARAMETER)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> IntentExtrasParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实现 Router ,内部通过动态代理的方式来实现 Activity 跳转：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Router</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class[]&#123;service&#125;, <span class="keyword">new</span> InvocationHandler() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</div><div class="line"></div><div class="line">                FullUri fullUri = method.getAnnotation(FullUri.class);</div><div class="line">                StringBuilder urlBuilder = <span class="keyword">new</span> StringBuilder();</div><div class="line">                urlBuilder.append(fullUri.value());</div><div class="line">                <span class="comment">//获取注解参数</span></div><div class="line">                Annotation[][] parameterAnnotations = method.getParameterAnnotations();</div><div class="line">                HashMap&lt;String, Object&gt; serializedParams = <span class="keyword">new</span> HashMap&lt;&gt;();</div><div class="line">			    <span class="comment">//拼接跳转 URI</span></div><div class="line">                <span class="keyword">int</span> position = <span class="number">0</span>;</div><div class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; parameterAnnotations.length; i++) &#123;</div><div class="line">                    Annotation[] annotations = parameterAnnotations[i];</div><div class="line">                    <span class="keyword">if</span> (annotations == <span class="keyword">null</span> || annotations.length == <span class="number">0</span>)</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line"></div><div class="line">                    Annotation annotation = annotations[<span class="number">0</span>];</div><div class="line">                    <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> UriParam) &#123;</div><div class="line">                        <span class="comment">//拼接 URI 后的参数</span></div><div class="line">                        ...</div><div class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (annotation <span class="keyword">instanceof</span> IntentExtrasParam) &#123;</div><div class="line">                        <span class="comment">//Intent 传参处理</span></div><div class="line">                        ...</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="comment">//执行Activity跳转操作</span></div><div class="line">                performJump(urlBuilder.toString(), serializedParams);</div><div class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">	...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面是 Router 实现的部分代码，在使用 Router 来跳转的时候，首先需要定义一个 Interface（类似于 Retrofit 的使用方式）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RouterService</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@FullUri</span>(<span class="string">"router://com.baronzhang.android.router.FourthActivity"</span>)</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">startUserActivity</span><span class="params">(@UriParam(<span class="string">"cityName"</span>)</span></span></div><div class="line">    		String cityName, @<span class="title">IntentExtrasParam</span><span class="params">(<span class="string">"user"</span>)</span> User user);</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们就可以通过如下方式实现 Activity 的跳转传参了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">RouterService routerService = <span class="keyword">new</span> Router(<span class="keyword">this</span>).create(RouterService.class);</div><div class="line"></div><div class="line">User user = <span class="keyword">new</span> User(<span class="string">"张三"</span>, <span class="number">17</span>, <span class="number">165</span>, <span class="number">88</span>);</div><div class="line">routerService.startUserActivity(<span class="string">"上海"</span>, user);</div></pre></td></tr></table></figure>
<h3 id="Injector"><a href="#Injector" class="headerlink" title="Injector"></a>Injector</h3><p>通过 Router 跳转到目标 Activity 后，我们需要在目标 Activity 中获取通过 Intent 传过来的参数：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">getIntent().getIntExtra(<span class="string">"intParam"</span>, <span class="number">0</span>);</div><div class="line"></div><div class="line">getIntent().getData().getQueryParameter(<span class="string">"preActivity"</span>);</div></pre></td></tr></table></figure>
<p>为了简化这部分工作，路由框架 Router 中提供了 Injector 模块在编译时生成上述代码。参数注入器（Injector）部分通过 Java 编译时注解来实现，实现思路和 ButterKnife 这类编译时注解框架类似。</p>
<p>首先定义我们的参数注解 InjectUriParam ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Target</span>(ElementType.FIELD)</div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.CLASS)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> InjectUriParam &#123;</div><div class="line">    <span class="function">String <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后实现一个注解处理器 InjectProcessor ，在编译阶段生成获取参数的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@AutoService</span>(Processor.class)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InjectProcessor</span> <span class="keyword">extends</span> <span class="title">AbstractProcessor</span> </span>&#123;</div><div class="line">    ...</div><div class="line">   <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; set, RoundEnvironment roundEnvironment)</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="comment">//解析注解</span></div><div class="line">        Map&lt;TypeElement, TargetClass&gt; targetClassMap = findAndParseTargets(roundEnvironment);</div><div class="line"></div><div class="line">        <span class="comment">//解析完成后，生成的代码的结构已经有了，它们存在InjectingClass中</span></div><div class="line">        <span class="keyword">for</span> (Map.Entry&lt;TypeElement, TargetClass&gt; entry : targetClassMap.entrySet()) &#123;</div><div class="line">            ...</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方式类似于 ButterKnife ，在 Activity 中我们使用 Inject 来注解一个全局变量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Inject</span> User user;</div></pre></td></tr></table></figure>
<p>然后 onCreate 方法中需要调用 inject(Activity activity) 方法实现注入：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">RouterInjector.inject(<span class="keyword">this</span>);</div></pre></td></tr></table></figure>
<p>这样我们就可以获取到前面通过 Router 跳转的传参了。</p>
<blockquote>
<p>由于篇幅限制，加上为了便于理解，这里只贴出了极少部分 <a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 框架的源码。希望进一步了解 Router 实现原理的可以到 GiuHub 去翻阅源码，<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 的实现还比较简陋，后面会进一步完善功能和文档，之后也会有单独的文章详细介绍。源码地址：<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">https://github.com/BaronZ88/Router</a></p>
</blockquote>
<h2 id="问题及建议"><a href="#问题及建议" class="headerlink" title="问题及建议"></a>问题及建议</h2><h3 id="资源名冲突"><a href="#资源名冲突" class="headerlink" title="资源名冲突"></a>资源名冲突</h3><p>对于多个 Bussines Module 中资源名冲突的问题，可以通过在 build.gradle 定义前缀的方式解决：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">defaultConfig &#123;</div><div class="line">   ...</div><div class="line">   resourcePrefix <span class="string">"new_house_"</span></div><div class="line">   ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>而对于 Module 中有些资源不想被外部访问的，我们可以创建 res/values/public.xml，添加到 public.xml 中的 resource 则可被外部访问，未添加的则视为私有：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">resources</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">public</span> <span class="attr">name</span>=<span class="string">"new_house_settings"</span> <span class="attr">type</span>=<span class="string">"string"</span>/&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">resources</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="重复依赖"><a href="#重复依赖" class="headerlink" title="重复依赖"></a>重复依赖</h3><p>模块化的过程中我们常常会遇到重复依赖的问题，如果是通过 aar 依赖， gradle 会自动帮我们找出新版本，而抛弃老版本的重复依赖。如果是以 project 的方式依赖，则在打包的时候会出现重复类。对于这种情况我们可以在 build.gradle 中将 compile 改为 provided，只在最终的项目中 compile 对应的 library ；</p>
<p>其实从前面的安居客模块化设计图上能看出来，我们的设计方案能一定程度上规避重复依赖的问题。比如我们所有的第三方库的依赖都会放到 OpenSoureLibraries 中，其他需要用到相关类库的项目，只需要依赖 OpenSoureLibraries 就好了。</p>
<h3 id="模块化过程中的建议"><a href="#模块化过程中的建议" class="headerlink" title="模块化过程中的建议"></a>模块化过程中的建议</h3><p>对于大型的商业项目，在重构过程中可能会遇到业务耦合严重，难以拆分的问题。<strong>我们需要先理清业务，再动手拆分业务模块</strong>。比如可以先在原先的项目中根据业务分包，在一定程度上将各业务解耦后拆分到不同的 package 中。比如之前新房和二手房由于同属于 app module，因此他们之前是通过隐式的 intent 跳转的，现在可以先将他们改为通过 Router 来实现跳转。又比如新房和二手房中公用的模块可以先下放到 Business Component Layer 或者 Basic Component Layer 中。在这一系列工作完成后再将各个业务拆分成多个 module 。</p>
<p>模块化重构需要渐进式的展开，不可一触而就，不要想着将整个项目推翻重写。线上成熟稳定的业务代码，是经过了时间和大量用户考验的；全部推翻重写往往费时费力，实际的效果通常也很不理想，各种问题层出不穷得不偿失。对于这种项目的模块化重构，我们需要一点点的改进重构，可以分散到每次的业务迭代中去，逐步淘汰掉陈旧的代码。</p>
<p>各业务模块间肯定会有公用的部分，按照我前面的设计图，公用的部分我们会根据业务相关性下放到业务组件层（Business Component Layer）或者基础组件层（Common Component Layer）。对于太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分。过程中完美主义可以有，切记不可过度。</p>
<p>以上就是我在模块化探索实践方面的一些经验，不住之处还望大家指出。</p>
<ul>
<li>模块化示例项目 <a href="https://github.com/BaronZ88/ModularizationProject" target="_blank" rel="external">ModularizationProject</a> 源码地址：<a href="https://github.com/BaronZ88/ModularizationProject" target="_blank" rel="external">https://github.com/BaronZ88/ModularizationProject</a></li>
<li>路由框架 <a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">Router</a> 源码地址：<a href="https://github.com/BaronZ88/Router" target="_blank" rel="external">https://github.com/BaronZ88/Router</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/blog/framework/android/2/header.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;首发于《程序员》杂志五月刊&lt;/p&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;万维网发明人 Tim Berners-Lee 谈到设计原理时说过：“简单性和模块化是软件工程的基石；分布式和容错性是互联网的生命。” 由此可见模块化之于软件工程领域的重要性。&lt;/p&gt;
&lt;p&gt;从 2016 年开始，模块化在 Android 社区越来越多的被提及。随着移动平台的不断发展，移动平台上的软件慢慢走向复杂化，体积也变得臃肿庞大；为了降低大型软件复杂性和耦合度，同时也为了适应模块重用、多团队并行开发测试等等需求，模块化在 Android 平台上变得势在必行。阿里 Android 团队在年初开源了他们的容器化框架 Atlas 就很大程度说明了当前 Android 平台开发大型商业项目所面临的问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://baronzhang.com/categories/Framework/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://baronzhang.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>安居客 Android 项目架构演进</title>
    <link href="http://baronzhang.com//blog/Framework/%E5%AE%89%E5%B1%85%E5%AE%A2Android%E9%A1%B9%E7%9B%AE%E6%9E%B6%E6%9E%84%E6%BC%94%E8%BF%9B/"/>
    <id>http://baronzhang.com//blog/Framework/安居客Android项目架构演进/</id>
    <published>2017-02-24T09:59:16.000Z</published>
    <updated>2019-08-19T06:53:46.660Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://resources.baronzhang.com/Blog/Framework/Android/header.jpg" alt=""></p>
<blockquote>
<p>本文已授权微信公众号 AndroidDeveloper 独家发布。</p>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>入职安居客三年从工程师到 Team Leader，见证了 Android 团队一路走来的发展历程。因此有心将这些记录下来与大家分享，也算是对自己三年来一部分工作的总结。希望对大家有所帮助，更希望能得到大家宝贵的建议。<br><a id="more"></a></p>
<h2 id="三网合并"><a href="#三网合并" class="headerlink" title="三网合并"></a>三网合并</h2><p>三年前入职时安居客在业务上刚完成了三网合并（新房、二手房、好租和商业地产多个平台多个网站合成现在的 anjuke.com，这在公司的历史上称之为三网合并）,因此移动端也将原先的新房、二手房、好租和商业地产多个 App 合并成为了现在的安居客 App。所谓的合并也差不多就是将多个项目的代码拷贝到了一起组成了新的 Anjuke Project。下面这张图能更加直观的呈现当时的状况：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/merge1.1.png" width="70%" alt="图片名称" align="center"></div></p>
<p>这一时期代码结构混乱、层次不清，各业务技术方案不统一，冗余代码充斥项目的各个角落；甚至连基本的包结构也是胡乱不堪，项目架构更是无从谈起。大家只不过是不停地往上堆砌代码添加新功能罢了。于是我进入公司的第一件事就是向 Leader 申请梳理了整个项目的结构。</p>
<p>而后随着项目的迭代，我们不断引入了 Retrofit、UniversalImageLoader、OKHttp、ButterKnife 等一系列成熟的开源库，同时我们也开发了自己的 UI 组件库 UIComponent、基础工具库 CommonUtils、基于第三方地图封装的 MapSDK、即时聊天模块 ChatLibrary 等等。这之后安居客项目架构大致演变成了由基础组件层、业务组件层和业务层组成的三层架构。如下图：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/merge2.1.png" width="50%" alt="图片名称" align="center"></div></p>
<p>其中业务层是一种非标准的 MVC 架构，Activity 和 Fragment 承担了 View 和 Controller 的职责：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/merge3.1.png" width="85%" alt="图片名称" align="center"></div></p>
<p>前面这种分层的架构本身是没太大问题的，即使到了现在我们的业务项目也已然是基于这种分层的架构来构建的，只不过在不断的迭代中我们做了些许调整（分层架构后面在介绍组件化和模块化的时候会详细介绍）。但是随着业务的不断迭代,我们慢慢发现业务层这种非标准的MVC架构带来了种种影响团队开发效率的问题：</p>
<ul>
<li>Activity 和 Fragment 越来越多的同时承担了 Controller 和 View 的职责，导致他们变得及其臃肿且难以维护；</li>
<li>由于 Controller 和 View 的揉合，导致单元测试起来很困难；</li>
<li>回调嵌套太多，面对负责业务时的代码逻辑不清晰，难以理解且不利于后期维护；</li>
<li>各层次模块之间职责不清晰等等</li>
</ul>
<blockquote>
<p>鉴于三网合并时期我还未加入安居客，所以对这一块的理解难免有偏差，如果有安居客的老同事发现文章中的描述有不对的地方还望批评指正。</p>
</blockquote>
<h2 id="由-RxJava-驱动的-MVP-架构"><a href="#由-RxJava-驱动的-MVP-架构" class="headerlink" title="由 RxJava 驱动的 MVP 架构"></a>由 RxJava 驱动的 MVP 架构</h2><p>一种技术架构无法满足所有的业务项目，更不可能有一种架构方案能够一劳永逸。正如上一节中提到的随着业务的不断迭代，现有架构的缺陷逐渐浮出水面，项目架构必需不断升级迭代才能更好地服务于业务。</p>
<h3 id="MVP-的设计与实现"><a href="#MVP-的设计与实现" class="headerlink" title="MVP 的设计与实现"></a>MVP 的设计与实现</h3><p>在研究了 Google 推出的基于 MVP 架构的 Demo 后，我们发现 MVP 架构能解决现在所面临过的很多问题，于是我们学习并引入到了我们的项目中来，并针对性的做了部分调整。下图呈现的是安居客 MVP 方案：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/mvp1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>以前面提到的三层架构的方案来看是这样的：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/mvp2.1.png" width="50%" alt="图片名称" align="center"></div></p>
<blockquote>
<p>基于此架构我在 GitHub 上开源了一个项目<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>，有兴趣的小伙伴可以去 Clone 下来看看，如果觉得对你有帮助就给个 Star 吧。  :)</p>
</blockquote>
<ul>
<li><strong>View Layer</strong>: 只负责 UI 的绘制呈现，包含 Fragment 和一些自定义的 UI 组件，View 层需要实现 ViewInterface 接口。Activity 在项目中不再负责 View 的职责，仅仅是一个全局的控制者，负责创建 View 和 Presenter 的实例；</li>
<li><strong>Model Layer</strong>: 负责检索、存储、操作数据，包括来自网络、数据库、磁盘文件和SharedPreferences的数据；</li>
<li><strong>Presenter Layer</strong>: 作为 View Layer 和 Module Layer 的之间的纽带，它从 Model 层中获取数据，然后调用 View 的接口去控制 View；</li>
<li><strong>Contract</strong>: 我们参照 Google 的 Demo 加入契约类 Contract 来统一管理 View 和 Presenter 的接口，使得某一功能模块的接口能更加直观的呈现出来，这样做是有利于后期维护的。</li>
</ul>
<p>另外这套MVP架构还为我们带来了一个额外的好处：<strong>我们有了足够明确的开发规范和标准</strong>。细致到了每一个类应该放到哪个包下，哪个类具体应该负责什么职责等等。这对于我们的 Code Review、接手他人的功能模块等都提供了极大的便利。前面提到的 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 就是为了定规范定标准而开发的。</p>
<p>这一时期我们还在项目中引入了 RxJava，很好的解决了前面提到的嵌套回调的问题，同时能够帮助我们简化复杂业务场景下的代码逻辑（当然 RxJava 的好处远远不止这么一点，对 RxJava 不了解的同学可以去翻翻我之前<a href="https://zhuanlan.zhihu.com/p/20687178?refer=baron" target="_blank" rel="external">一系列关于 RxJava 的文章</a>）。我们也将网络库升级到了 Retrofit2 + OKHttp3，它们和 RxJava 之间能更好的配合。</p>
<h3 id="MVP-带来的新问题及解决方案"><a href="#MVP-带来的新问题及解决方案" class="headerlink" title="MVP 带来的新问题及解决方案"></a>MVP 带来的新问题及解决方案</h3><p>是不是升级到了 MVP 架构就高枕无忧了呢？很明显不是这样！MVP 架构也会带来以下新的问题：</p>
<ul>
<li>由于大量的业务逻辑处理转移到了 Presenter 层，在一些复杂的业务场景中 Presenter 同样会变得臃肿难懂。细心的同学可能注意到了前面的架构图中的 Model 层有个 Data Repository 模块，Data Repository 在这里有两个作用：一是可以将原本由 Presenter 处理的部分逻辑转移到这里来处理，包括数据的校验、部分单纯只与数据相关的逻辑等等，向 Presenter 屏蔽数据处理细节，比如作为 Presenter 就不必关心 Model 层传递过来的数据到底是来至网络还是来至数据库还是来至本地文件等等；二是我们引入了 RxJava，但是只有网络层中的 Retrofit 能返回 Observable 对象，其他模块都是返回的还是一些非 Observable 的 Java 对象，为了能在整个 Presenter 层中都体验 RxJava 带来的美妙之处，因此可以通过 Data Repository 做一层转换；</li>
<li>现在的 MVP 架构中最重的部分就是 Model Layer 了，这一点从前面的架构图中就能体现。因此这就要求我们在 Model 层的设计过程中职责划分要足够清晰，分包更明确，耦合度更低。至于分包大家可以参考 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 的方案：db 包为数据库模块、http 包为网络模块、preference 包是对 SharedPreferences 的一些封装、repository 包就是前面提到的 Data Repository 模块；</li>
<li>同时还有一点需要注意，很多人在使用 RxJava 的过程中往往忘记了对生命周期的管理，这很容易造成内存泄露。<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a> 中采用了 CompositeSubscription 来管理，你也可以使用 RxLifecycle 这类开源库来管理生命周期。</li>
</ul>
<h2 id="组件化与模块化"><a href="#组件化与模块化" class="headerlink" title="组件化与模块化"></a>组件化与模块化</h2><p>去年下半年我们 Android 团队内部成立了技术小组，基础组件的开发是技术小组很重要的一部分工作，所以组件化是我们正在做的事；模块化更多的是现有的方案受到来自业务上的挑战以及受到了 Oasis Feng 在 MDCC 上的分享和整个大环境的启发，现在正处于设计规划和 Demo 开发的阶段。</p>
<h3 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h3><p>组件化不是个新概念，通俗的讲组件化就是基于可重用的目的，将一个大的软件系统拆分成一个个独立组件。</p>
<p>组件化的带来的好处不言而喻：</p>
<ul>
<li>避免重复造轮子，节省开发维护成本；</li>
<li>降低项目复杂性，提升开发效率；</li>
<li>多个团队公用同一个组件，在一定层度上确保了技术方案的统一性。</li>
</ul>
<p>现在的安居客有是三个业务团队：安居客用户 App、经纪人 App、集客家 App。为了避免各个业务团队重复造轮子，团队中也需要有一定的技术沉淀，因此组件化是必须的。从本篇的第一节大家就能看到组件化的影子，只不过在这之前我们做的并不好。现在我们需要提供更多的、职能单一、性能更优的组件供业务团队使用。根据业务相关性，我们将这些组件分为：基础组件和业务组件。后面在介绍模块化的时候会有进一步的描述。</p>
<h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>自从 Oasis Feng 在去年的 MDCC2016 上分享了模块化的经验后，模块化在 Android 社区越来越多的被提起。我们自然也不落俗的去做了一些研究和探索。安居客现在面临很多问题：例如全量编译时间太长（我这台13款的 MacBook Pro 上打一次包得花十多分钟）；例如新房、二手房、租房等等模块间耦合严重，不利于多团队并行开发测试；另外在17年初公司重新将租房 App 捡起推广，单独让人来开发维护一个三年前的项目并不划算，所以我们希望能直接从现在的安居客用户端中拆分出租房模块作为一个单独的 App 发布上线。这样看来模块化似乎是一个不错的选择。</p>
<p>所以我们做模块化的目的大致是这样的：</p>
<ul>
<li>业务模块间解耦</li>
<li>单个业务模块单独编译打包，加快编译速度</li>
<li>多团队间并行开发、测试</li>
<li>解决好租App需要单独维护的问题，降低研发成本</li>
</ul>
<blockquote>
<p>15年 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 还在安居客的时候开发了一套插件化框架，但受限于当时的团队规模并且插件化对整个项目的改造太大，因此在安居客团队中插件化并未实施下来。而模块化其实是个很好的过渡方案，将项目按照模块拆分后各业务模块间解耦的问题不存在了，后续如有必要，再进行插件化改造只不过是水到渠成的事。</p>
</blockquote>
<p>来看看安居客用户 App 的模块化设计图：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/modularization1.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>整个项目分为三层，从下往上分别是：</p>
<ul>
<li>Basic Component Layer: 基础组件层，顾名思义就是一些基础组件，包含了各种开源库以及和业务无关的各种自研工具库；</li>
<li>Business Component Layer: 业务组件层，这一层的所有组件都是业务相关的，例如上图中的支付组件 AnjukePay、数据模拟组件 DataSimulator 等等；</li>
<li>Business Module Layer: 业务 Module 层，在 Android Studio 中每块业务对应一个单独的 Module。例如安居客用户 App 我们就可以拆分成新房 Module、二手房 Module、IM Module 等等，每个单独的 Business Module 都必须准遵守前面提到的 MVP 架构。</li>
</ul>
<p>同时针对模块化我们也需要定义一些自己的游戏规则:</p>
<ul>
<li>对于 Business Module Layer，各业务模块之间的通讯跳转采用路由框架 Router 来实现（可能会采用成熟的开源库，也可能会选择重复造轮子）;</li>
<li>对于 Business Component Layer，单一业务组件只能对应某一项具体的业务，对于有个性化需求的对外部提供接口让调用方定制;</li>
<li>合理控制各组件和各业务模块的拆分粒度，太小的公有模块不足以构成单独组件或者模块的，我们先放到类似于 CommonBusiness 的组件中，在后期不断的重构迭代中视情况进行进一步的拆分（这一点的灵感来源于 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 的文章）;</li>
<li>上层的公有的业务或者功能模块可以逐步下放到下层，合理把握好度就好；</li>
<li>各 Layer 间严禁反向依赖，横向依赖关系由各业务 Leader 和技术小组商讨决定。</li>
</ul>
<p>对于模块化项目，每个单独的 Business Module 都可以单独编译成 APK。在开发阶段需要单独打包编译，项目发布的时候又需要它作为项目的一个 Module 来整体编译打包。简单的说就是开发时是 Application，发布时是 Library。因此需要你在 Business Module 的 Gradle 配置文件中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">if</span>(isBuildModule.toBoolean())&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.application'</span></div><div class="line">&#125;<span class="keyword">else</span>&#123;</div><div class="line">    apply <span class="string">plugin:</span> <span class="string">'com.android.library'</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们需要把租房模块打包成一个单独的租房 App，像下面这样就好：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/modularization2.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>我们可以把 Basic Component Layer 和 Business Component Layer 放在一起看做是 Anjuke SDK，新的业务或者项目只需要依赖 Anjuke SDK 就好（这一点同样是受到了 <a href="http://www.trinea.cn" target="_blank" rel="external">Trinea</a> 文章的启发）。甚至我们可以做得更极致一些，开发一套自己的组件管理平台，业务方可以根据自己的需求选择自己需要的组件，定制业务专属的 Anjuke SDK。业务端和 Anjuke SDK 的关系如下图所示：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/modularization3.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>最后看看安居客模块化的整体设计图：<div align="center"><img src="http://resources.baronzhang.com/Blog/Framework/Android/modularization4.1.png" width="100%" alt="图片名称" align="center"></div></p>
<p>模块化拆分对于安居客这种比较大型的商业项目而言，由于历史比较久远很多代码都运行五六年了；各个业务相互交叉耦合严重，所以实施起来还是有很大难度的。过程中难免会有预料不到的坑，这就需要我们对各个业务有较深的理解同时也要足够的耐心和细致。虽然辛苦，但是一旦完成模块化拆分对整个团队及公司业务上的帮助是很大的。</p>
<p>以上是我的简单总结以及对模块化的一些思考，不足之处还望大家批评指正。后面模块化的 Demo 完善后我会把它放到 GitHub，并再出一篇文章详细介绍模块化的设计实现细节。</p>
<p>参考资料：</p>
<ul>
<li><a href="http://www.csdn.net/article/2015-12-16/2826499-android-app-architecture?locationNum=7&amp;fps=1" target="_blank" rel="external">http://www.csdn.net/article/2015-12-16/2826499-android-app-architecture?locationNum=7&amp;fps=1</a></li>
<li><a href="http://www.trinea.cn/android/didi-internationalization-android-evolution/" target="_blank" rel="external">http://www.trinea.cn/android/didi-internationalization-android-evolution/</a></li>
<li><a href="https://www.tianmaying.com/tutorial/AndroidMVC" target="_blank" rel="external">https://www.tianmaying.com/tutorial/AndroidMVC</a></li>
<li><a href="https://www.diycode.cc/topics/362" target="_blank" rel="external">https://www.diycode.cc/topics/362</a></li>
<li><a href="https://github.com/MDCC2016/Android-Session-Slides/blob/master/02-From.Containerization.To.Modularity.pdf" target="_blank" rel="external">https://github.com/MDCC2016/Android-Session-Slides/blob/master/02-From.Containerization.To.Modularity.pdf</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://resources.baronzhang.com/Blog/Framework/Android/header.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文已授权微信公众号 AndroidDeveloper 独家发布。&lt;/p&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;入职安居客三年从工程师到 Team Leader，见证了 Android 团队一路走来的发展历程。因此有心将这些记录下来与大家分享，也算是对自己三年来一部分工作的总结。希望对大家有所帮助，更希望能得到大家宝贵的建议。&lt;br&gt;
    
    </summary>
    
      <category term="Framework" scheme="http://baronzhang.com/categories/Framework/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="Framework" scheme="http://baronzhang.com/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>神兵利器Dagger2</title>
    <link href="http://baronzhang.com//blog/OpenSource/Java/%E7%A5%9E%E5%85%B5%E5%88%A9%E5%99%A8Dagger2/"/>
    <id>http://baronzhang.com//blog/OpenSource/Java/神兵利器Dagger2/</id>
    <published>2017-02-06T10:58:18.000Z</published>
    <updated>2019-08-19T06:53:46.665Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。</p>
<p>Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。</p>
<p>起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。</p>
<a id="more"></a>
<h2 id="依赖注入（Dependency-Injection）"><a href="#依赖注入（Dependency-Injection）" class="headerlink" title="依赖注入（Dependency Injection）"></a>依赖注入（Dependency Injection）</h2><p>那么什么是依赖注入呢？在解释这个概念前我们先看一小段代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</div><div class="line">		engine = <span class="keyword">new</span> Engine();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这段Java代码中Car类持有了对Engine实例的引用，我们称之为Car类对Engine类有一个依赖。而依赖注入则是指通过注入的方式实现类与类之间的依赖，下面是常见的三种依赖注入的方式：</p>
<h3 id="1-构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。"><a href="#1-构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。" class="headerlink" title="1. 构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。"></a>1. 构造注入：通过构造函数传参给依赖的成员变量赋值，从而实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-接口注入：实现接口方法，同样以传参的方式实现注入。"><a href="#2-接口注入：实现接口方法，同样以传参的方式实现注入。" class="headerlink" title="2. 接口注入：实现接口方法，同样以传参的方式实现注入。"></a>2. 接口注入：实现接口方法，同样以传参的方式实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Injection</span>&lt;<span class="title">T</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(T t)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword">implements</span> <span class="title">Injection</span>&lt;<span class="title">Engine</span>&gt;</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Engine engine)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="3-注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。"><a href="#3-注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。" class="headerlink" title="3. 注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。"></a>3. 注解注入：使用Java注解在编译阶段生成代码实现注入或者是在运行阶段通过反射实现注入。</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="meta">@Inject</span></div><div class="line">	Engine engine;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>前两种注入方式需要我们编写大量的模板代码，而机智的Dagger2则是通过Java注解在编译期来实现依赖注入的。</p>
<h2 id="为什么需要依赖注入"><a href="#为什么需要依赖注入" class="headerlink" title="为什么需要依赖注入"></a>为什么需要依赖注入</h2><p>我们之所是要依赖注入，最重要的就是为了解耦，达到高内聚低耦合的目的，保证代码的健壮性、灵活性和可维护性。</p>
<p>下面我们看看同一个业务的两种实现方案：</p>
<h3 id="1-方案A"><a href="#1-方案A" class="headerlink" title="1. 方案A"></a>1. 方案A</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line">	<span class="keyword">private</span> List&lt;Wheel&gt; wheels;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span></span>&#123;</div><div class="line">		engine = <span class="keyword">new</span> Engine();</div><div class="line">		wheels = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</div><div class="line">			wheels.add(<span class="keyword">new</span> Wheel());</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> start&#123;</div><div class="line">		System.out.println(<span class="string">"启动汽车"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarTest</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">		Car car = <span class="keyword">new</span> Car();</div><div class="line">		car.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-方案B"><a href="#2-方案B" class="headerlink" title="2. 方案B"></a>2. 方案B</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">private</span> Engine engine;</div><div class="line">	<span class="keyword">private</span> List&lt;Wheel&gt; wheels;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">(Engine engine, List&lt;Wheel&gt; wheels)</span></span>&#123;</div><div class="line">		<span class="keyword">this</span>.engine = engine;</div><div class="line">		<span class="keyword">this</span>.wheels = wheels;</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	<span class="keyword">public</span> <span class="keyword">void</span> start&#123;</div><div class="line">		System.out.println(<span class="string">"启动汽车"</span>);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CarTest</span></span>&#123;</div><div class="line"></div><div class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line"></div><div class="line">		Engine engine = <span class="keyword">new</span> Engine();</div><div class="line">		List&lt;Wheel&gt; wheels = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)&#123;</div><div class="line">			wheels.add(<span class="keyword">new</span> Wheel());</div><div class="line">		&#125;</div><div class="line">		Car car = <span class="keyword">new</span> Car(engine, wheels);</div><div class="line">		car.start();</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>方案A：由于没有依赖注入，因此需要我们自己是在Car的构造函数中创建Engine和Wheel对象。</p>
<p>方案B：我们手动以构造函数的方式注入依赖，将engine和wheels作为参数传入而不是在Car的构造函数中去显示的创建。</p>
<p>方案A明显丧失了灵活性，一切依赖都是在Car类的内部创建，Car与Engine和Wheel严重耦合。一旦Engine或者Wheel的创建方式发生了改变，我们就必须要去修改Car类的构造函数（比如说现在创建Wheel实例的构造函数改变了，需要传入Rubber（橡胶）了）；另外我们也没办法替换动态的替换依赖实例（比如我们想把Car的Wheel（轮胎）从邓禄普（轮胎品牌）换成米其林（轮胎品牌）的）。这类问题在大型的商业项目中则更加严重，往往A依赖B、B依赖C、C依赖D、D依赖E；一旦稍有改动便牵一发而动全身，想想都可怕！而依赖注入则很好的帮我们解决了这一问题。</p>
<h2 id="为什么是Dagger2"><a href="#为什么是Dagger2" class="headerlink" title="为什么是Dagger2"></a>为什么是Dagger2</h2><p>无论是构造函数注入还是接口注入，都避免不了要编写大量的模板代码。机智的猿猿们当然不开心做这些重复性的工作，于是各种依赖注入框架应用而生。但是这么多的依赖注入框架为什么我们却偏爱Dagger2呢？我们先从Spring中的控制反转（IOC）说起。</p>
<p>谈起依赖注入，做过J2EE开发的同学一定会想起Spring IOC，那通过迷之XML来配置依赖的方式真的很让人讨厌；而且XML与Java代码分离也导致代码链难以追踪。之后更加先进的Guice（Android端也有个RoboGuice）出现了，我们不再需要通过XML来配置依赖，但其运行时实现注入的方式让我们在追踪和定位错误的时候却又万分痛苦。开篇提到过Dagger就是受Guice的启发而开发出来的；Dagger继承了前辈的思想，在性能又碾压了它的前辈Guice，可谓是长江后浪推前浪，前浪死在沙滩上。</p>
<p>又如开篇我在简介中说到的，Dagger是一种半静态半运行时的DI框架，虽说依赖注入是完全静态的，但是生成有向无环图(DAG)还是基于反射来实现，这无论在大型的服务端应用还是在Android应用上都不是最优方案。升级版的Dagger2解决了这一问题，从半静态变为完全静态，从Map式的API变成申明式API（@Module），生成的代码更优雅高效；而且一旦出错我们在编译期间就能发现。所以Dagger2对开发者的更加友好了，当然Dagger2也因此丧失了一些灵活性，但总体来说利还是远远大于弊的。</p>
<p>前面提到这种A B C D E连续依赖的问题，一旦E的创建方式发生了改变就会引发连锁反应，可能会导致A B C D都需要做针对性的修改；但是骚年，你以为为这仅仅是工作量的问题吗？更可怕的是我们创建A时需要按顺序先创建E D C B四个对象，而且必须保证顺序上是正确的。Dagger2就很好的解决了这一问题（不只是Dagger2，在其他DI框架中开发者同样不需要关注这些问题）。</p>
<h2 id="Dagger2注解"><a href="#Dagger2注解" class="headerlink" title="Dagger2注解"></a>Dagger2注解</h2><p>开篇我们就提到Dagger2是基于Java注解来实现依赖注入的，那么在正式使用之前我们需要先了解下Dagger2中的注解。Dagger2使用过程中我们通常接触到的注解主要包括：@Inject, @Module, @Provides, @Component, @Qulifier, @Scope, @Singleten。</p>
<ul>
<li><p>@Inject：@Inject有两个作用，一是用来标记需要依赖的变量，以此告诉Dagger2为它提供依赖；二是用来标记构造函数，Dagger2通过@Inject注解可以在需要这个类实例的时候来找到这个构造函数并把相关实例构造出来，以此来为被@Inject标记了的变量提供依赖；</p>
</li>
<li><p>@Module：@Module用于标注提供依赖的类。你可能会有点困惑，上面不是提到用@Inject标记构造函数就可以提供依赖了么，为什么还需要@Module？很多时候我们需要提供依赖的构造函数是第三方库的，我们没法给它加上@Inject注解，又比如说提供以来的构造函数是带参数的，如果我们之所简单的使用@Inject标记它，那么他的参数又怎么来呢？@Module正是帮我们解决这些问题的。</p>
</li>
<li><p>@Provides：@Provides用于标注Module所标注的类中的方法，该方法在需要提供依赖时被调用，从而把预先提供好的对象当做依赖给标注了@Inject的变量赋值；</p>
</li>
<li><p>@Component：@Component用于标注接口，是依赖需求方和依赖提供方之间的桥梁。被Component标注的接口在编译时会生成该接口的实现类（如果@Component标注的接口为CarComponent，则编译期生成的实现类为DaggerCarComponent）,我们通过调用这个实现类的方法完成注入；</p>
</li>
<li><p>@Qulifier：@Qulifier用于自定义注解，也就是说@Qulifier就如同Java提供的几种基本元注解一样用来标记注解类。我们在使用@Module来标注提供依赖的方法时，方法名我们是可以随便定义的（虽然我们定义方法名一般以provide开头，但这并不是强制的，只是为了增加可读性而已）。那么Dagger2怎么知道这个方法是为谁提供依赖呢？答案就是返回值的类型，Dagger2根据返回值的类型来决定为哪个被@Inject标记了的变量赋值。但是问题来了，一旦有多个一样的返回类型Dagger2就懵逼了。@Qulifier的存在正式为了解决这个问题，我们使用@Qulifier来定义自己的注解，然后通过自定义的注解去标注提供依赖的方法和依赖需求方（也就是被@Inject标注的变量），这样Dagger2就知道为谁提供依赖了。—-一个更为精简的定义：当类型不足以鉴别一个依赖的时候，我们就可以使用这个注解标示；</p>
</li>
<li><p>@Scope：@Scope同样用于自定义注解，我能可以通过@Scope自定义的注解来限定注解作用域，实现局部的单例；</p>
</li>
<li><p>@Singleton：@Singleton其实就是一个通过@Scope定义的注解，我们一般通过它来实现全局单例。但实际上它并不能提前全局单例，是否能提供全局单例还要取决于对应的Component是否为一个全局对象。</p>
</li>
</ul>
<p>我们提到@Inject和@Module都可以提供依赖，那如果我们即在构造函数上通过标记@Inject提供依赖，有通过@Module提供依赖Dagger2会如何选择呢？具体规则如下：</p>
<ul>
<li>步骤1：首先查找@Module标注的类中是否存在提供依赖的方法。</li>
<li>步骤2：若存在提供依赖的方法，查看该方法是否存在参数。<ul>
<li>a：若存在参数，则按从步骤1开始依次初始化每个参数；</li>
<li>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
</ul>
</li>
<li>步骤3：若不存在提供依赖的方法，则查找@Inject标注的构造函数，看构造函数是否存在参数。<ul>
<li>a：若存在参数，则从步骤1开始依次初始化每一个参数</li>
<li>b：若不存在，则直接初始化该类实例，完成一次依赖注入。</li>
</ul>
</li>
</ul>
<h2 id="Dagger2使用入门"><a href="#Dagger2使用入门" class="headerlink" title="Dagger2使用入门"></a>Dagger2使用入门</h2><p>前面长篇大论的基本都在介绍概念，下面我们看看Dagger2的基本应用。关于Dagger2的依赖配置就不在这里占用篇幅去描述了，大家可以到它的github主页下去查看官方教程<a href="https://github.com/google/dagger" target="_blank" rel="external">https://github.com/google/dagger</a>。接下来我们还是拿前面的Car和Engine来举例。</p>
<h3 id="1-案例A"><a href="#1-案例A" class="headerlink" title="1. 案例A"></a>1. 案例A</h3><p>Car类是需求依赖方，依赖了Engine类；因此我们需要在类变量Engine上添加@Inject来告诉Dagger2来为自己提供依赖。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine engine;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engine;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Engine类是依赖提供方，因此我们需要在它的构造函数上添加@Inject</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine()&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"引擎转起来了~~~"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们需要创建一个用@Component标注的接口CarComponent，这个CarComponent其实就是一个注入器，这里用来将Engine注入到Car中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>完成这些之后我们需要Build下项目，让Dagger2帮我们生成相关的Java类。接着我们就可以在Car的构造函数中调用Dagger2生成的DaggerCarComponent来实现注入（这其实在前面Car类的代码中已经有了体现）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">    DaggerCarComponent.builder().build().inject(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="2-案例B"><a href="#2-案例B" class="headerlink" title="2. 案例B"></a>2. 案例B</h3><p><strong>如果创建Engine的构造函数是带参数的呢？比如说制造一台引擎是需要齿轮(Gear)的。或者Eggine类是我们无法修改的呢？这时候就需要@Module和@Provide上场了。</strong></p>
<p>同样我们需要在Car类的成员变量Engine上加上@Inject表示自己需要Dagger2为自己提供依赖；Engine类的构造函数上的@Inject也需要去掉，应为现在不需要通过构造函数上的@Inject来提供依赖了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span></div><div class="line">    Engine engine;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engine;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们需要一个Module类来生成依赖对象。前面介绍的@Module就是用来标准这个类的，而@Provide则是用来标注具体提供依赖对象的方法（这里有个不成文的规定，被@Provide标注的方法命名我们一般以provide开头，这并不是强制的但有益于提升代码的可读性）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span> <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来我们还需要对CarComponent进行一点点修改，之前的@Component注解是不带参数的，现在我们需要加上<code>modules = {MarkCarModule.class}</code>，用来告诉Dagger2提供依赖的是<code>MarkCarModule</code>这个类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>Car类的构造函数我们也需要修改，相比之前多了个<code>markCarModule(new MarkCarModule())</code>方法，这就相当于告诉了注入器<code>DaggerCarComponent</code>把<code>MarkCarModule</code>提供的依赖注入到了Car类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">   DaggerCarComponent.builder()</div><div class="line">           .markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">           .build().inject(<span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这样一个最最基本的依赖注入就完成了，接下来我们测试下我们的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line">    car.getEngine().run();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">引擎转起来了~~~</div></pre></td></tr></table></figure>
<h3 id="3-案例C"><a href="#3-案例C" class="headerlink" title="3. 案例C"></a>3. 案例C</h3><p>那么如果一台汽车有两个引擎（也就是说Car类中有两个Engine变量）怎么办呢？没关系，我们还有@Qulifier！首先我们需要使用Qulifier定义两个注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> QualifierA &#123; &#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Qualifier</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> QualifierB &#123; &#125;</div></pre></td></tr></table></figure>
<p>同时我们需要对依赖提供方做出修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierA</span></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngineA</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gearA"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierB</span></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngineB</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gearB"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接下来依赖需求方Car类同样需要修改</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@QualifierA</span> <span class="meta">@Inject</span> Engine engineA;</div><div class="line">    <span class="meta">@QualifierB</span> <span class="meta">@Inject</span> Engine engineB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder().markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineA</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineA;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Engine <span class="title">getEngineB</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.engineB;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最后我们再对Engine类做些调整方便测试</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String gear;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String gear)</span></span>&#123;</div><div class="line">        <span class="keyword">this</span>.gear = gear;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printGearName</span><span class="params">()</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"GearName:"</span> + gear);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>测试代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line">    car.getEngineA().printGearName();</div><div class="line">    car.getEngineB().printGearName();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">GearName:gearA</div><div class="line">GearName:gearB</div></pre></td></tr></table></figure>
<h3 id="4-案例D"><a href="#4-案例D" class="headerlink" title="4. 案例D"></a>4. 案例D</h3><p>接下来我们看看@Scope是如何限定作用域，实现局部单例的。</p>
<p>首先我们需要通过@Scope定义一个CarScope注解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Scope</span></div><div class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</div><div class="line"><span class="keyword">public</span> <span class="meta">@interface</span> CarScope &#123;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们需要用这个@CarScope去标记依赖提供方MarkCarModule。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span></div><div class="line">    <span class="meta">@CarScope</span></div><div class="line">    <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>同时还需要使用@Scope去标注注入器Compoent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@CarScope</span></div><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>为了便于测试我们对Car和Engine类做了一些改造：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="meta">@Inject</span> Engine engineA;</div><div class="line">    <span class="meta">@Inject</span> Engine engineB;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Car</span><span class="params">()</span> </span>&#123;</div><div class="line">        DaggerCarComponent.builder()</div><div class="line">                .markCarModule(<span class="keyword">new</span> MarkCarModule())</div><div class="line">                .build().inject(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Engine</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> String gear;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Engine</span><span class="params">(String gear)</span></span>&#123;</div><div class="line">        System.out.println(<span class="string">"Create Engine"</span>);</div><div class="line">        <span class="keyword">this</span>.gear = gear;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果我们不适用@Scope,上面的代码会实例化两次Engine类，因此会有两次\”Create Engine\”输出。现在我们在有@Scope的情况测试下劳动成果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line">    Car car = <span class="keyword">new</span> Car();</div><div class="line"></div><div class="line">    System.out.println(car.engineA.hashCode());</div><div class="line">    System.out.println(car.engineB.hashCode());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Create Engine</div></pre></td></tr></table></figure>
<p>bingo！我们确实通过@Scope实现了局部的单例。</p>
<h2 id="Dagger2原理分析"><a href="#Dagger2原理分析" class="headerlink" title="Dagger2原理分析"></a>Dagger2原理分析</h2><p>前面啰里啰嗦的介绍了Dagger2的基本使用，接下来我们再分析分析实现原理。这里不会分析Dagger2根据注解生成各种代码的原理，关于Java注解以后有机会再写一篇文章来介绍。后面主要分析的是Dagger2生成的各种类如何帮我们实现依赖注入，为了便于理解我这里选了前面相对简单的<strong>案例B</strong>来做分析。</p>
<p>Dagger2编译期生成的代码位于<code>build/generated/source/apt/debug/your package name/</code>下面:<br><img src="http://resources.baronzhang.com/Blog/OpenSource/Android/Dagger2/generated_code.png" alt="Generated Code"></p>
<p>首先我们看看Dagger2依据依赖提供方<code>MarkCarModule</code>生成的对应工厂类<code>MarkCarModule_ProvideEngineFactory</code>。为了方便大家理解对比，后面我一律会把自己写的类和Dagger2生成的类一并放出来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 我们自己的类</div><div class="line">*/</div><div class="line"><span class="meta">@Module</span></div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule</span><span class="params">()</span></span>&#123; &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Provides</span> <span class="function">Engine <span class="title">provideEngine</span><span class="params">()</span></span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Engine(<span class="string">"gear"</span>);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Dagger2生成的工厂类</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MarkCarModule_ProvideEngineFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span>&lt;<span class="title">Engine</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> MarkCarModule <span class="keyword">module</span>;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MarkCarModule_ProvideEngineFactory</span><span class="params">(MarkCarModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> <span class="keyword">module</span> != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.<span class="keyword">module</span> = <span class="keyword">module</span>;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> Engine <span class="title">get</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Preconditions.checkNotNull(</div><div class="line">        <span class="keyword">module</span>.provideEngine(), <span class="string">"Cannot return null from a non-@Nullable @Provides method"</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Factory&lt;Engine&gt; <span class="title">create</span><span class="params">(MarkCarModule <span class="keyword">module</span>)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> MarkCarModule_ProvideEngineFactory(<span class="keyword">module</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="comment">/** Proxies &#123;<span class="doctag">@link</span> MarkCarModule#provideEngine()&#125;. */</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Engine <span class="title">proxyProvideEngine</span><span class="params">(MarkCarModule instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> instance.provideEngine();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们可以看到<code>MarkCarModule_ProvideEngineFactory</code>中的get()调用了<code>MarkCarModule</code>的<code>provideEngine()</code>方法来获取我们需要的依赖<code>Engine</code>，<code>MarkCarModule_ProvideEngineFactory</code>的实例化有<code>crate()</code>创建，并且<code>MarkCarModule</code>的实例也是通过<code>create()</code>方法传进来的。那么这个<code>create()</code>一定会在哪里调用的，我们接着往下看。</p>
<p>前面提到@Component是依赖提供方(MarkCarModule)和依赖需求方(Car)之前的桥梁，那我看看Dagger2是如何通过CarComponent将两者联系起来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line">* 我们自己的类</div><div class="line">*/</div><div class="line"><span class="meta">@Component</span>(modules = &#123;MarkCarModule.class&#125;)</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span></span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line">* Dagger2生成的CarComponent实现类</div><div class="line">*/</div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DaggerCarComponent</span> <span class="keyword">implements</span> <span class="title">CarComponent</span> </span>&#123;</div><div class="line">  <span class="keyword">private</span> Provider&lt;Engine&gt; provideEngineProvider;</div><div class="line"></div><div class="line">  <span class="keyword">private</span> MembersInjector&lt;Car&gt; carMembersInjector;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="title">DaggerCarComponent</span><span class="params">(Builder builder)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> builder != <span class="keyword">null</span>;</div><div class="line">    initialize(builder);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Builder <span class="title">builder</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Builder();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CarComponent <span class="title">create</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> builder().build();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</div><div class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(<span class="keyword">final</span> Builder builder)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.provideEngineProvider = MarkCarModule_ProvideEngineFactory.create(builder.markCarModule);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.carMembersInjector = Car_MembersInjector.create(provideEngineProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Car car)</span> </span>&#123;</div><div class="line">    carMembersInjector.injectMembers(car);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> MarkCarModule markCarModule;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> CarComponent <span class="title">build</span><span class="params">()</span> </span>&#123;</div><div class="line">      <span class="keyword">if</span> (markCarModule == <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.markCarModule = <span class="keyword">new</span> MarkCarModule();</div><div class="line">      &#125;</div><div class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DaggerCarComponent(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> Builder <span class="title">markCarModule</span><span class="params">(MarkCarModule markCarModule)</span> </span>&#123;</div><div class="line">      <span class="keyword">this</span>.markCarModule = Preconditions.checkNotNull(markCarModule);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码我们看到Dagger2依据<code>CarComponent</code>接口生成了实现类<code>DaggerCarComponent</code>（没错这正是我们在Car的构造函数中使用DaggerCarComponent）。<code>DaggerCarComponent</code>在build的时候实例化了<code>DaggerCarComponent</code>对象，并首先调用<code>MarkCarModule_ProvideEngineFactory.create(builder.markCarModule)</code>始化了<code>provideEngineProvider</code>变量，接着调用<code>Car_MembersInjector.create(provideEngineProvider)</code>初始化了<code>carMembersInjector</code>变量。当我们手动在Car类的构造函数中调用<code>inject(Car car)</code>方法时会执行<code>carMembersInjector.injectMembers(car)</code>。所以接下来我们要看看<code>Car_MembersInjector</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Car_MembersInjector</span> <span class="keyword">implements</span> <span class="title">MembersInjector</span>&lt;<span class="title">Car</span>&gt; </span>&#123;</div><div class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Provider&lt;Engine&gt; engineProvider;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Car_MembersInjector</span><span class="params">(Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">assert</span> engineProvider != <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">this</span>.engineProvider = engineProvider;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> MembersInjector&lt;Car&gt; <span class="title">create</span><span class="params">(Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Car_MembersInjector(engineProvider);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="meta">@Override</span></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">injectMembers</span><span class="params">(Car instance)</span> </span>&#123;</div><div class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Cannot inject members into a null reference"</span>);</div><div class="line">    &#125;</div><div class="line">    instance.engine = engineProvider.get();</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectEngine</span><span class="params">(Car instance, Provider&lt;Engine&gt; engineProvider)</span> </span>&#123;</div><div class="line">    instance.engine = engineProvider.get();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Car_MembersInjector</code>中的<code>create()</code>用于实例化自己，这个方法前面我们看到是在<code>DaggerCarComponent</code>中调用的。<code>injectMembers(Car instance)</code>将<code>engineProvider.get()</code>的返回值赋给了依赖需求方Car的engine变量，而<code>engineProvider.get()</code>正是本节一开始我们提到的<code>MarkCarModule_ProvideEngineFactory</code>中的<code>get()</code>方法。至此整个依赖注入的流程就完成了。更复杂的应用场景会生成更加复杂的代码，但原理都和前面分析的大同小异。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这篇文章只是通过一些简单的例子介绍了Dagger2的相关概念及使用，实际项目中的应用远比这里的例子要复杂。关于Dagger2在实际项目中的应用可以参照这个开源项目 <a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">https://github.com/BaronZ88/MinimalistWeather</a>（项目采用MVP架构，其中View层和Presenter层的解耦就是通过Dagger2来实现的）。</p>
<blockquote>
<p><a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>是一款开源天气App，开发此项目主要是为展示各种开源库的使用方式以及Android项目的架构方案，并作为团队开发规范的一部分。项目中每一个字母、每一个命名、每一行代码都是经过仔细考究的；但是由于时间精力有限，项目UI未做严格要求。本着精益求精、提供更好开源项目和更美天气应用的原则，因此期望有兴趣的开发和UED同学可以一起来完成这个项目。</p>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Dagger-匕首，鼎鼎大名的Square公司旗下又一把利刃（没错！还有一把黄油刀，唤作ButterKnife）；故此给本篇取名神兵利器Dagger2。&lt;/p&gt;
&lt;p&gt;Dagger2起源于Dagger，是一款基于Java注解来实现的完全在编译阶段完成依赖注入的开源库，主要用于模块间解耦、提高代码的健壮性和可维护性。Dagger2在编译阶段通过apt利用Java注解自动生成Java代码，然后结合手写的代码来自动帮我们完成依赖注入的工作。&lt;/p&gt;
&lt;p&gt;起初Square公司受到Guice的启发而开发了Dagger，但是Dagger这种半静态半运行时的框架还是有些性能问题（虽说依赖注入是完全静态的，但是其有向无环图(Directed Acyclic Graph)还是基于反射来生成的，这无论在大型的服务端应用还是在Android应用上都不是最优方案）。因此Google工程师Fork了Dagger项目，对它进行了改造。于是变演变出了今天我们要讨论的Dagger2，所以说Dagger2其实就是高配版的Dagger。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenSource" scheme="http://baronzhang.com/categories/OpenSource/"/>
    
      <category term="Java" scheme="http://baronzhang.com/categories/OpenSource/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="依赖注入" scheme="http://baronzhang.com/tags/%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    
      <category term="开源框架" scheme="http://baronzhang.com/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%97%E7%95%AA%E5%A4%96%E7%AF%87%EF%BC%9A%E4%B8%80%E4%B8%AARxJava%E8%A7%A3%E5%86%B3%E5%A4%8D%E6%9D%82%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91%E7%9A%84%E6%A1%88%E4%BE%8B/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例/</id>
    <published>2017-02-05T16:30:27.000Z</published>
    <updated>2019-08-19T06:53:46.660Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：</p>
<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<h2 id="业务场景"><a href="#业务场景" class="headerlink" title="业务场景"></a>业务场景</h2><p>拿<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>这个开源的天气App来举例：</p>
<a id="more"></a>
<p>进入App首页后，首先我们需要从数据库中获取当前城市的天气数据，如果数据库中存在天气数据则在UI页面上展示天气数据；如果数据库中未存储当前城市的天气数据，或者已存储的天气数据的发布时间相比现在已经超过了一小时，并且网络属于连接状态则调用API从服务端获取天气数据。如果获取到到的天气数据发布时间和当前数据库中的天气数据发布时间一致则丢弃掉从服务端获取到的天气数据，如果不一致则更新数据库并且在页面上展示最新的天气信息。（同时天气数据源是可配置的，可选择是小米天气数据源还是Know天气数据源）</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>首先我们需要创建一个从数据库获取天气数据的Observable <code>observableForGetWeatherFromDB</code>，同时我们也需要创建一个从API获取天气数据的Observable <code>observableForGetWeatherFromNetWork</code>；为了在无网络状态下免于创建<code>observableForGetWeatherFromNetWork</code>我们在这之前需要首先判断下网络状态。最后使用<code>contact</code>操作符将两个Observable合并，同时使用<code>distinct</code>和<code>takeUntil</code>操作符来过滤筛选数据以符合业务需求，然后结合<code>subscribeOn</code>和<code>observeOn</code>做线程切换。上述这一套复杂的业务逻辑如果使用传统编码方式将是极其复杂的。下面我们来看看使用RxJava如何清晰简洁的来实现这个复杂的业务：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class="line"><span class="comment">//首先创建一个从数据库获取天气数据的Observable</span></div><div class="line">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Weather weather = weatherDao.queryWeather(cityId);</div><div class="line">            subscriber.onNext(weather);</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class="line">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//接着创建一个从网络获取天气数据的Observable</span></div><div class="line">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span> (configuration.getDataSourceType()) &#123;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class="line">                    .map(<span class="keyword">new</span> Func1&lt;KnowWeather, Weather&gt;() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> Weather <span class="title">call</span><span class="params">(KnowWeather knowWeather)</span> </span>&#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> KnowWeatherAdapter(knowWeather).getWeather();</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class="line">                    .map(<span class="keyword">new</span> Func1&lt;MiWeather, Weather&gt;() &#123;</div><div class="line">                        <span class="meta">@Override</span></div><div class="line">                        <span class="function"><span class="keyword">public</span> Weather <span class="title">call</span><span class="params">(MiWeather miWeather)</span> </span>&#123;</div><div class="line">                            <span class="keyword">return</span> <span class="keyword">new</span> MiWeatherAdapter(miWeather).getWeather();</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> observableForGetWeatherFromNetWork != <span class="keyword">null</span>;</div><div class="line">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class="line">            .doOnNext(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            weatherDao.insertOrUpdateWeather(weather);</div><div class="line">                        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">                        &#125;</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">    <span class="comment">//使用concat操作符将两个Observable合并</span></div><div class="line">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class="line">            .filter(<span class="keyword">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> weather != <span class="keyword">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId());</div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .distinct(<span class="keyword">new</span> Func1&lt;Weather, Long&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Long <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> weather.getRealTime().getTime();<span class="comment">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class="line">                &#125;</div><div class="line">            &#125;)</div><div class="line">            .takeUntil(<span class="keyword">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>;<span class="comment">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                displayWeatherInformation();</div><div class="line">            &#125;</div><div class="line">        &#125;, <span class="keyword">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Throwable throwable)</span> </span>&#123;</div><div class="line">                Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show();</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>上面的代码看起来比较复杂，我们采用Lambda表达式简化下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class="line"><span class="comment">//首先创建一个从数据库获取天气数据的Observable</span></div><div class="line">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Weather weather = weatherDao.queryWeather(cityId);</div><div class="line">            subscriber.onNext(weather);</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">            <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class="line">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class="line">&#125; <span class="keyword">else</span> &#123;</div><div class="line">    <span class="comment">//接着创建一个从网络获取天气数据的Observable</span></div><div class="line">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class="keyword">null</span>;</div><div class="line">    <span class="keyword">switch</span> (configuration.getDataSourceType()) &#123;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class="line">                    .map(knowWeather -&gt; <span class="keyword">new</span> KnowWeatherAdapter(knowWeather).getWeather());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        <span class="keyword">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class="line">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class="line">                    .map(miWeather -&gt; <span class="keyword">new</span> MiWeatherAdapter(miWeather).getWeather());</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">assert</span> observableForGetWeatherFromNetWork != <span class="keyword">null</span>;</div><div class="line">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class="line">            .doOnNext(weather -&gt; Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class="line">                <span class="keyword">try</span> &#123;</div><div class="line">                    weatherDao.insertOrUpdateWeather(weather);</div><div class="line">                &#125; <span class="keyword">catch</span> (SQLException e) &#123;</div><div class="line">                    <span class="keyword">throw</span> Exceptions.propagate(e);</div><div class="line">                &#125;</div><div class="line">            &#125;));</div><div class="line"></div><div class="line">    <span class="comment">//使用concat操作符将两个Observable合并</span></div><div class="line">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class="line">            .filter(weather -&gt; weather != <span class="keyword">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId()))</div><div class="line">            .distinct(weather -&gt; weather.getRealTime().getTime())<span class="comment">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class="line">            .takeUntil(weather -&gt; System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class="number">60</span> * <span class="number">60</span> * <span class="number">1000</span>);<span class="comment">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class="line">&#125;</div><div class="line"></div><div class="line">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(weather -&gt; displayWeatherInformation(),</div><div class="line">                throwable -&gt; Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show());</div></pre></td></tr></table></figure>
<h2 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h2><p>在上述的实现中有几点是我们需要注意的:</p>
<ol>
<li><p>为什么我需要在判断网络那块整个if else？这样看起来很不优雅，我们通过RxJava符完全可以实现同样的操作啊！之所以这样做是为了在无网络状况下去创建不必要的Observable <code>observableForGetWeatherFromNetWork</code>;</p>
</li>
<li><p>更新数据库的操作不应该阻塞更新UI，因此我们在<code>observableForGetWeatherFromNetWork</code>的<code>doOnNext</code>中需要通过<code>Schedulers.io().createWorker()</code>去另起一条线程，以此保证更新数据库不会阻塞更新UI的操作。</p>
<blockquote>
<p>有同学可能会问为什么不在<code>doOnNext</code>之后再调用一次<code>observeOn</code>把更新数据库的操作切换到一条新的子线程去操作呢？其实一开始我也是这样做的，后来想想不对。整个Observable的事件传递处理就像是在一条流水线上完成的，虽然我们可以通过<code>observeOn</code>来指定子线程去处理更新数据库的操作，但是只有等这条子线程完成了更新数据库的任务后事件才会继续往后传递，这样就阻塞了更新UI的操作。对此有疑问的同学可以去看看我之前关于RxJava源码分析的文章或者自己动手debug看看。</p>
</blockquote>
</li>
</ol>
<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>最后给大家留个两个问题：</p>
<ol>
<li>上述代码是最佳实现方案吗？还有什么更加合理的做法？</li>
<li>我们在<code>observableForGetWeatherData</code>中使用<code>distinct</code>和<code>takeUntil</code>过滤筛选天气数据的时候网络请求会不会已经发出去了？这样做还有意义吗？</li>
</ol>
<p>欢迎大家留言讨论。</p>
<blockquote>
<p>本文中的代码在<a href="https://github.com/BaronZ88/MinimalistWeather" target="_blank" rel="external">MinimalistWeather</a>中的<code>WeatherDataRepository</code>类中有同样的实现，文章中为了更完整的将整个实现过程呈现出来，对代码做了部分改动。</p>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;业务场景&quot;&gt;&lt;a href=&quot;#业务场景&quot; class=&quot;headerlink&quot; title=&quot;业务场景&quot;&gt;&lt;/a&gt;业务场景&lt;/h2&gt;&lt;p&gt;拿&lt;a href=&quot;https://github.com/BaronZ88/MinimalistWeather&quot;&gt;MinimalistWeather&lt;/a&gt;这个开源的天气App来举例：&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列7(最佳实践)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%977-%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列7-最佳实践/</id>
    <published>2017-02-05T16:22:03.000Z</published>
    <updated>2019-08-19T06:53:46.655Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<hr>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。</p>
<blockquote>
<p>按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。</p>
</blockquote>
<a id="more"></a>
<h2 id="示例一、获取手机上已安装的App"><a href="#示例一、获取手机上已安装的App" class="headerlink" title="示例一、获取手机上已安装的App"></a>示例一、获取手机上已安装的App</h2><p>第一个例子我们需要在Android设备上展示已安装的第三方app列表，关于环境搭建、依赖配置、RecyclerView的使用等这些基础内容我就不做陈述了。需要了解的同学可以去GitHub上把项目clone下来看看。这里我主要讲讲如何通过RxJava实现核心功能。</p>
<p>首选我们需要调用系统api来获取所有已安装的app，所以在<code>OnSubscribe</code>的<code>call</code>方法中调用<code>getApplicationInfoList()</code>。但是<code>getApplicationInfoList()</code>获取的数据并不能完全满足我们的业务需求：</p>
<ol>
<li>由于我们只需要展示手机上已安装的第三方App，因此需要通过<code>filter</code>操作符来过滤掉系统app；</li>
<li><code>ApplicationInfo</code>并不是我们所需要的类型，因此需要通过<code>map</code>操作符将其转换为<code>AppInfo</code>；</li>
<li>由于获取<code>ApplicationInfo</code>、过滤数据、转换数据相对比较耗时，因此需要通过<code>subscribeOn</code>操作符将这一系列操作放到子线程中来处理；</li>
<li>而要将信息展示在页面上涉及到UI操作，因此需要通过<code>observeOn</code>操作符将<code>onNext</code>、<code>onCompleted</code>、<code>onError</code>调度到主线程，接着我们在这些方法中更新UI。</li>
</ol>
<p>下面是核心代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> PackageManager pm = MainActivity.<span class="keyword">this</span>.getPackageManager();</div><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;ApplicationInfo&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> ApplicationInfo&gt; subscriber)</span> </span>&#123;</div><div class="line">            List&lt;ApplicationInfo&gt; infoList = getApplicationInfoList(pm);</div><div class="line">            <span class="keyword">for</span> (ApplicationInfo info : infoList) &#123;</div><div class="line">                subscriber.onNext(info);</div><div class="line">            &#125;</div><div class="line">            subscriber.onCompleted();</div><div class="line">        &#125;</div><div class="line">    &#125;).filter(<span class="keyword">new</span> Func1&lt;ApplicationInfo, Boolean&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class="line">            <span class="keyword">return</span> (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;).map(<span class="keyword">new</span> Func1&lt;ApplicationInfo, AppInfo&gt;() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> AppInfo <span class="title">call</span><span class="params">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class="line">            AppInfo info = <span class="keyword">new</span> AppInfo();</div><div class="line">            info.setAppIcon(applicationInfo.loadIcon(pm));</div><div class="line">            info.setAppName(applicationInfo.loadLabel(pm).toString());</div><div class="line">            <span class="keyword">return</span> info;</div><div class="line">        &#125;</div><div class="line">    &#125;).subscribeOn(Schedulers.io())</div><div class="line">    .observeOn(AndroidSchedulers.mainThread())</div><div class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;AppInfo&gt;() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            mAppListAdapter.notifyDataSetChanged();</div><div class="line">            mPullDownSRL.setRefreshing(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            mPullDownSRL.setRefreshing(<span class="keyword">false</span>);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(AppInfo appInfo)</span> </span>&#123;</div><div class="line">            mAppInfoList.add(appInfo);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>程序执行效果图：</p>
<div align="left"><img src="http://resources.baronzhang.com/rxjava/7/pic1.png" width="38%" alt="图片名称" align="center"></div>

<p>完整的代码我放到了GitHub上，有兴趣大家可以去clone下来自己运行看看。</p>
<p>源码地址：<a href="https://github.com/BaronZ88/HelloRxAndroid" target="_blank" rel="external">https://github.com/BaronZ88/HelloRxAndroid</a></p>
<h2 id="示例二、RxJava-Retrofit2实现获取天气数据"><a href="#示例二、RxJava-Retrofit2实现获取天气数据" class="headerlink" title="示例二、RxJava+Retrofit2实现获取天气数据"></a>示例二、RxJava+Retrofit2实现获取天气数据</h2><p>RxJava + Retrofit2几乎是Android应用开发的标配了，这个例子中我们就来聊聊这二者是如何配合起来帮助我们快速开发的。</p>
<p>Retrofit2中一个标准的接口定义是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"weather"</span>)</div><div class="line"><span class="function">Observable&lt;Weather&gt; <span class="title">getWeather</span><span class="params">(@Query(<span class="string">"cityId"</span>)</span> String cityId)</span>;</div></pre></td></tr></table></figure>
<p>现在有了RxJava，一个基本的网络请求我们便可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">ApiClient.weatherService.getWeather(cityId)</div><div class="line">             	.subscribeOn(Schedulers.io())</div><div class="line">                .observeOn(AndroidSchedulers.mainThread())</div><div class="line">                .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">                        weatherView.displayWeatherInformation(weather);</div><div class="line">                    &#125;</div><div class="line">                &#125;);</div></pre></td></tr></table></figure>
<p>但有时候可能一开始我们并不知道cityId，我们只知道cityName。所以就需要我们先访问服务器，拿到对应城市名的cityId，然后通过这个cityId再去获取天气数据。</p>
<p>同样的，我们需要定义一个获取cityId的接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@GET</span>(<span class="string">"city"</span>)</div><div class="line"><span class="function">Observable&lt;String&gt; <span class="title">getCityIdByName</span><span class="params">(@Query(<span class="string">"cityName"</span>)</span> String cityName)</span>;</div></pre></td></tr></table></figure>
<p>紧接着我们便可以使用无所不能的RxJava来实现需求了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">ApiClient.weatherService.getCityIdByName(<span class="string">"上海"</span>)</div><div class="line">			 .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;Weather&gt;&gt;() &#123;</div><div class="line">			     <span class="meta">@Override</span></div><div class="line">			     <span class="function"><span class="keyword">public</span> Observable&lt;Weather&gt; <span class="title">call</span><span class="params">(String cityId)</span> </span>&#123;</div><div class="line">			         <span class="keyword">return</span> ApiClient.weatherService.getWeather(cityId);</div><div class="line">			     &#125;</div><div class="line">			 &#125;).subscribeOn(Schedulers.io())</div><div class="line">			 .observeOn(AndroidSchedulers.mainThread())</div><div class="line">			 .subscribe(<span class="keyword">new</span> Action1&lt;Weather&gt;() &#123;</div><div class="line">			     <span class="meta">@Override</span></div><div class="line">			     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Weather weather)</span> </span>&#123;</div><div class="line">			         weatherView.displayWeatherInformation(weather);</div><div class="line">			     &#125;</div><div class="line">			 &#125;);</div></pre></td></tr></table></figure>
<p>哇哦！~ so easy！！！妈妈再也不用担心….</p>
<p>源码地址：<a href="https://github.com/BaronZ88/WeatherStyle" target="_blank" rel="external">https://github.com/BaronZ88/WeatherStyle</a></p>
<blockquote>
<p><a href="(https://github.com/BaronZ88/WeatherStyle">WeatherStyle</a>)这个项目还在开发中，这个项目不只包含了RxJava和Retrofit的使用，同时还包含MVP、ORMLite、RetroLambda、ButterKnife等等开源库的使用</p>
</blockquote>
<p>RxJava1.X的系列文章就到此结束了，由于本人对RxJava的理解有限，这一系列文章中如有错误还请大家指正。在使用RxJava过程中有任何疑问也欢迎大家和我交流。共同学习！共同进步！</p>
<p>好啦，我们RxJava2见！~</p>
<hr>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列6(从微观角度解读RxJava源码)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%976-%E4%BB%8E%E5%BE%AE%E8%A7%82%E8%A7%92%E5%BA%A6%E8%A7%A3%E8%AF%BBRxJava%E6%BA%90%E7%A0%81/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/</id>
    <published>2017-02-05T16:21:05.000Z</published>
    <updated>2019-08-19T06:53:46.665Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<hr>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：</p>
<ul>
<li>RxJava基本流程分析</li>
<li>操作符原理分析</li>
<li>线程调度原理分析</li>
</ul>
<blockquote>
<p>本章节基于<strong>RxJava1.1.9</strong>版本的源码</p>
</blockquote>
<h2 id="一、RxJava执行流程分析"><a href="#一、RxJava执行流程分析" class="headerlink" title="一、RxJava执行流程分析"></a>一、RxJava执行流程分析</h2><p>在<a href="http://www.jianshu.com/p/ba61c047c230" target="_blank" rel="external">RxJava系列2(基本概念及使用介绍)</a>中我们介绍过，一个最基本的RxJava调用是这样的：</p>
<a id="more"></a>
<p><strong>示例A</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello RxJava!"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"completed!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>首先调用<code>Observable.create()</code>创建一个被观察者<code>Observable</code>，同时创建一个<code>OnSubscribe</code>作为<code>create()</code>方法的入参；接着创建一个观察者<code>Subscriber</code>，然后通过<code>subseribe()</code>实现二者的订阅关系。这里涉及到三个关键对象和一个核心的方法：</p>
<ul>
<li><strong>Observable</strong>（被观察者）</li>
<li><strong>OnSubscribe</strong> (从纯设计模式的角度来理解，<code>OnSubscribe.call()</code>可以看做是<a href="https://github.com/BaronZ88/Blog/blob/master/DesignPatterns/ObserverPattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md" target="_blank" rel="external">观察者模式</a>中被观察者用来通知观察者的<code>notifyObservers()</code>方法)</li>
<li><strong>Subscriber</strong> （观察者）</li>
<li><strong>subscribe()</strong> （实现观察者与被观察者订阅关系的方法）</li>
</ul>
<h3 id="1-Observable-create-源码分析"><a href="#1-Observable-create-源码分析" class="headerlink" title="1. Observable.create()源码分析"></a>1. Observable.create()源码分析</h3><p>首先我们来看看<code>Observable.create()</code>的实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里创建了一个被观察者<code>Observable</code>，同时将<code>RxJavaHooks.onCreate(f)</code>作为构造函数的参数，源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">protected</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class="line">	<span class="keyword">this</span>.onSubscribe = f;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到源码中直接将参数<code>RxJavaHooks.onCreate(f)</code>赋值给了当前我们构造的被观察者<code>Observable</code>的成员变量<code>onSubscribe</code>。那么<code>RxJavaHooks.onCreate(f)</code>返回的又是什么呢？我们接着往下看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observable.<span class="function">OnSubscribe&lt;T&gt; <span class="title">onCreate</span><span class="params">(Observable.OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</div><div class="line">    Func1&lt;OnSubscribe, OnSubscribe&gt; f = onObservableCreate;</div><div class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</div><div class="line">        <span class="keyword">return</span> f.call(onSubscribe);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> onSubscribe;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于我们并没调用<code>RxJavaHooks.initCreate()</code>，所以上面代码中的<code>onObservableCreate</code>为null；因此<code>RxJavaHooks.onCreate(f)</code>最终返回的就是<code>f</code>，也就是我们在<code>Observable.create()</code>的时候new出来的<code>OnSubscribe</code>。（<em>由于对RxJavaHooks的理解并不影响我们对RxJava执行流程的分析，因此在这里我们不做进一步的探讨。为了方便理解我们只需要知道RxJavaHooks一系列方法的返回值就是入参本身就OK了，例如这里的<code>RxJavaHooks.onCreate(f)</code>返回的就是<code>f</code></em>）。</p>
<p>至此我们做下逻辑梳理：<strong><code>Observable.create()</code>方法构造了一个被观察者<code>Observable</code>对象，同时将new出来的<code>OnSubscribe</code>赋值给了该<code>Observable</code>的成员变量<code>onSubscribe</code>。</strong></p>
<h3 id="2-Subscriber源码分析"><a href="#2-Subscriber源码分析" class="headerlink" title="2. Subscriber源码分析"></a>2. Subscriber源码分析</h3><p>接着我们看下观察者<code>Subscriber</code>的源码，为了增加可读性，我去掉了源码中的注释和部分代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> SubscriptionList subscriptions;<span class="comment">//订阅事件集，所有发送给当前Subscriber的事件都会保存在这里</span></div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">Subscriber</span><span class="params">(Subscriber&lt;?&gt; subscriber, <span class="keyword">boolean</span> shareSubscriptions)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.subscriber = subscriber;</div><div class="line">        <span class="keyword">this</span>.subscriptions = shareSubscriptions &amp;&amp; subscriber != <span class="keyword">null</span> ? subscriber.subscriptions : <span class="keyword">new</span> SubscriptionList();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span> </span>&#123;</div><div class="line">        subscriptions.unsubscribe();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isUnsubscribed</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> subscriptions.isUnsubscribed();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subscription</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">unsubscribe</span><span class="params">()</span></span>;</div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isUnsubscribed</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>Subscriber</code>实现了<code>Subscription</code>接口，从而对外提供<code>isUnsubscribed()</code>和<code>unsubscribe()</code>方法。前者用于判断是否已经取消订阅；后者用于将订阅事件列表(<em>也就是当前观察者的成员变量<code>subscriptions</code></em>)中的所有<code>Subscription</code>取消订阅，并且不再接受观察者<code>Observable</code>发送的后续事件。</p>
<h3 id="3-subscribe-源码分析"><a href="#3-subscribe-源码分析" class="headerlink" title="3. subscribe()源码分析"></a>3. subscribe()源码分析</h3><p>前面我们分析了观察者和被观察者相关的源码，那么接下来便是整个订阅流程中最最关键的环节了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line"></div><div class="line">	...</div><div class="line"></div><div class="line">    subscriber.onStart();</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</div><div class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</div><div class="line"></div><div class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>subscribe()</code>方法中将传进来的<code>subscriber</code>包装成了<code>SafeSubscriber</code>，<code>SafeSubscriber</code>其实是<code>subscriber</code>的一个代理，对<code>subscriber</code>的一系列方法做了更加严格的安全校验。保证了<code>onCompleted()</code>和<code>onError()</code>只会有一个被执行且只执行一次，一旦它们其中方法被执行过后<code>onNext()</code>就不在执行了。</p>
<p>上述代码中最关键的就是<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber)</code>。这里的RxJavaHooks和之前提到的一样，<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe)</code>返回的正是他的第二个入参<code>observable.onSubscribe</code>，也就是当前<code>observable</code>的成员变量<code>onSubscribe</code>。而这个成员变量我们前面提到过，它是我们在<code>Observable.create()</code>的时候new出来的。所以这段代码可以简化为<code>onSubscribe.call(subscriber)</code>。这也印证了我在<a href="http://www.jianshu.com/p/ba61c047c230" target="_blank" rel="external">RxJava系列2(基本概念及使用介绍)</a>中说的，<code>onSubscribe.call(subscriber)</code>中的<code>subscriber</code>正是我们在<code>subscribe()</code>方法中new出来的观察者。</p>
<p>到这里，我们对RxJava的执行流程做个总结：首先我们调用<code>crate()</code>创建一个观察者，同时创建一个<code>OnSubscribe</code>作为该方法的入参；接着调用<code>subscribe()</code>来订阅我们自己创建的观察者<code>Subscriber</code>。<br>一旦调用<code>subscribe()</code>方法后就会触发执行<code>OnSubscribe.call()</code>。然后我们就可以在call方法调用观察者<code>subscriber</code>的<code>onNext()</code>,<code>onCompleted()</code>,<code>onError()</code>。</p>
<p>最后我用张图来总结下之前的分析结果：</p>
<p><img src="http://resources.baronzhang.com/rxjava/6/OperatorProcess1.jpg" alt="RxJava基本流程分析"></p>
<h2 id="二、操作符原理分析"><a href="#二、操作符原理分析" class="headerlink" title="二、操作符原理分析"></a>二、操作符原理分析</h2><p>之前我们介绍过几十个操作符，要一一分析它们的源码显然不太现实。在这里我抛砖引玉，选取一个相对简单且常用的<code>map</code>操作符来分析。</p>
<p>我们先来看一个<code>map</code>操作符的简单应用：</p>
<p><strong>示例B</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="number">1</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"This is "</span> + integer;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onCompleted!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(e.getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>为了便于表述，我将上面的代码做了如下拆解：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Integer&gt; observableA = Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="number">1</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">Subscriber&lt;String&gt; subscriberOne = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onCompleted!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(e.getMessage());</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line">Observable&lt;String&gt; observableB =</div><div class="line">        observableA.map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> <span class="string">"This is "</span> + integer;;</div><div class="line">                &#125;</div><div class="line">            &#125;);</div><div class="line"></div><div class="line">observableB.subscribe(subscriberOne);</div></pre></td></tr></table></figure>
<p><code>map()</code>的源码和上一小节介绍的<code>create()</code>一样位于<code>Observable</code>这个类中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; func)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeMap&lt;T, R&gt;(<span class="keyword">this</span>, func));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过查看源码我们发现调用<code>map()</code>的时候实际上是创建了一个新的被观察者<code>Observable</code>，我们姑且称它为<code>ObservableB</code>；一开始通过<code>Observable.create()</code>创建的<code>Observable</code>我们称之为<code>ObservableA</code>。在创建<code>ObservableB</code>的时候同时创建了一个<code>OnSubscribeMap</code>，而<code>ObservableA</code>和变换函数<code>Func1</code>则作为构造<code>OnSubscribeMap</code>的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;<span class="comment">//ObservableA</span></div><div class="line"></div><div class="line">    <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer;<span class="comment">//map操作符中的转换函数Func1。T为转换前的数据类型，在上面的例子中为Integer；R为转换后的数据类型，在该例中为String。</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeMap</span><span class="params">(Observable&lt;T&gt; source, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">        <span class="keyword">this</span>.transformer = transformer;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;<span class="comment">//结合第一小节的分析结果，我们知道这里的入参o其实就是我们自己new的观察者subscriberOne。</span></div><div class="line">        MapSubscriber&lt;T, R&gt; parent = <span class="keyword">new</span> MapSubscriber&lt;T, R&gt;(o, transformer);</div><div class="line">        o.add(parent);</div><div class="line">        source.unsafeSubscribe(parent);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSubscriber</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; actual;<span class="comment">//这里的actual就是我们在调用subscribe()时创建的观察者mSubscriber</span></div><div class="line">        <span class="keyword">final</span> Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper;<span class="comment">//变换函数</span></div><div class="line">        <span class="keyword">boolean</span> done;</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MapSubscriber</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; actual, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</div><div class="line">            <span class="keyword">this</span>.actual = actual;</div><div class="line">            <span class="keyword">this</span>.mapper = mapper;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">            R result;</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                result = mapper.call(t);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">                Exceptions.throwIfFatal(ex);</div><div class="line">                unsubscribe();</div><div class="line">                onError(OnErrorThrowable.addValueAsLastCause(ex, t));</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            actual.onNext(result);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            actual.onError(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            ...</div><div class="line">            actual.onCompleted();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(Producer p)</span> </span>&#123;</div><div class="line">            actual.setProducer(p);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OnSubscribeMap</code>实现了<code>OnSubscribe</code>接口，因此<code>OnSubscribeMap</code>就是一个<code>OnSubscribe</code>。在调用<code>map()</code>的时候创建了一个新的被观察者<code>ObservableB</code>，然后我们用<code>ObservableB.subscribe(subscriberOne)</code>订阅了观察者<code>subscriberOne</code>。结合我们在第一小节的分析结果，所以<code>OnSubscribeMap.call(o)</code>中的<code>o</code>就是<code>subscribe(subscriberOne)</code>中的<code>subscriberOne</code>；一旦调用了<code>ObservableB.subscribe(subscriberOne)</code>就会执行<code>OnSubscribeMap.call()</code>。</p>
<p>在<code>call()</code>方法中，首先通过我们的观察者<code>o</code>和转换函数<code>transformer</code>构造了一个<code>MapSubscriber</code>，最后调用了<code>source</code>也就是<code>observableA</code>的<code>unsafeSubscribe()</code>方法。即<code>observableA</code>订阅了一个观察者<code>MapSubscriber</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">unsafeSubscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        ...</div><div class="line">        RxJavaHooks.onObservableStart(<span class="keyword">this</span>, onSubscribe).call(subscriber);</div><div class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码最终执行了<code>onSubscribe</code>也就是<code>OnSubscribeMap</code>的<code>call()</code>方法，<code>call()</code>方法中的参数就是之前在<code>OnSubscribeMap.call()</code>中new出来的<code>MapSubscriber</code>。最后在<code>call()</code>方法中执行了我们自己的业务代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">subscriber.onNext(<span class="number">1</span>);</div><div class="line">subscriber.onCompleted();</div></pre></td></tr></table></figure>
<p>其实也就是执行了<code>MapSubscriber</code>的<code>onNext()</code>和<code>onCompleted()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">    R result;</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        result = mapper.call(t);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</div><div class="line">        ...</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    actual.onNext(result);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>onNext(T t)</code>方法中的的<code>mapper</code>就是变换函数，<code>actual</code>就是我们在调用<code>subscribe()</code>时创建的观察者<code>subscriberOne</code>。这个<code>T</code>就是我们例子中的<code>Integer</code>，<code>R</code>就是<code>String</code>。在<code>onNext()</code>中首先调用变换函数<code>mapper.call()</code>将<code>T</code>转换成<code>R</code>(在我们的例子中就是将<code>Integer</code>类型的<strong>1</strong>转换成了<code>String</code>类型的<strong>“This is 1”</strong>)；接着调用<code>subscriberOne.onNext(String result)</code>。同样在调用<code>MapSubscriber.onCompleted()</code>时会执行<code>subscriberOne.onCompleted()</code>。这样就完成了一直完成的调用流程。</p>
<p>我承认太啰嗦了，花费了这么大的篇幅才将<code>map()</code>的转换原理解释清楚。我也是希望尽量的将每个细节都呈现出来方便大家理解，如果看我啰嗦了这么久还是没能理解，请看下面我画的这张执行流程图。</p>
<p><img src="http://resources.baronzhang.com/rxjava/6/OperatorProcess3.jpg" alt="加入Map操作符后的执行流程"></p>
<h2 id="三、线程调度原理分析"><a href="#三、线程调度原理分析" class="headerlink" title="三、线程调度原理分析"></a>三、线程调度原理分析</h2><p>在前面的文章中我介绍过RxJava可以很方便的通过<code>subscribeOn()</code>和<code>observeOn()</code>来指定数据流的每一部分运行在哪个线程。其中<code>subscribeOn()</code>指定了处理<code>Observable</code>的全部的过程(包括发射数据和通知)的线程；<code>observeOn()</code>指定了观察者的<code>onNext()</code>, <code>onError()</code>和<code>onCompleted()</code>执行的线程。接下来我们就分析分析源码，看看线程调度是如何实现的。</p>
<p>在分析源码前我们先看看一段常见的通过RxJava实现的线程调度代码：</p>
<p><strong>示例C</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class="line">        subscriber.onNext(<span class="string">"Hello RxJava!"</span>);</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line">&#125;).subscribeOn(Schedulers.io())</div><div class="line">.observeOn(AndroidSchedulers.mainThread())</div><div class="line">.subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"completed!"</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">    &#125;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="1-subscribeOn-源码分析"><a href="#1-subscribeOn-源码分析" class="headerlink" title="1. subscribeOn()源码分析"></a>1. subscribeOn()源码分析</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过上面的代码我们可以看到，<code>subscribeOn()</code>和<code>map()</code>一样是创建了一个新的被观察者<code>Observable</code>。因此我大致就能猜到<code>subscribeOn()</code>的执行流程应该和<code>map()</code>差不多，<code>OperatorSubscribeOn</code>肯定也是一个<code>OnSubscribe</code>。那我们接下来就看看<code>OperatorSubscribeOn</code>的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Scheduler scheduler;<span class="comment">//线程调度器，用来指定订阅事件发送、处理等所在的线程</span></div><div class="line">    <span class="keyword">final</span> Observable&lt;T&gt; source;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.scheduler = scheduler;</div><div class="line">        <span class="keyword">this</span>.source = source;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">final</span> Worker inner = scheduler.createWorker();</div><div class="line">        subscriber.add(inner);</div><div class="line"></div><div class="line">        inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">final</span> Thread t = Thread.currentThread();</div><div class="line"></div><div class="line">                Subscriber&lt;T&gt; s = <span class="keyword">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">                        subscriber.onNext(t);</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            subscriber.onError(e);</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            inner.unsubscribe();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                        <span class="keyword">try</span> &#123;</div><div class="line">                            subscriber.onCompleted();</div><div class="line">                        &#125; <span class="keyword">finally</span> &#123;</div><div class="line">                            inner.unsubscribe();</div><div class="line">                        &#125;</div><div class="line">                    &#125;</div><div class="line"></div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setProducer</span><span class="params">(<span class="keyword">final</span> Producer p)</span> </span>&#123;</div><div class="line">                        subscriber.setProducer(<span class="keyword">new</span> Producer() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> n)</span> </span>&#123;</div><div class="line">                                <span class="keyword">if</span> (t == Thread.currentThread()) &#123;</div><div class="line">                                    p.request(n);</div><div class="line">                                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                                    inner.schedule(<span class="keyword">new</span> Action0() &#123;</div><div class="line">                                        <span class="meta">@Override</span></div><div class="line">                                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                                            p.request(n);</div><div class="line">                                        &#125;</div><div class="line">                                    &#125;);</div><div class="line">                                &#125;</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;;</div><div class="line">                source.unsafeSubscribe(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorSubscribeOn</code>实现了<code>OnSubscribe</code>接口，<code>call()</code>中对<code>Subscriber</code>的处理也和<code>OperatorMap</code>对<code>Subscriber</code>的处理类似。首先通过<code>scheduler</code>构建了一个<code>Worker</code>；然后用传进来的<code>subscriber</code>构造了一个新的<code>Subscriber s</code>，并将<code>s</code>丢到<code>Worker.schedule()</code>中来处理；最后用原<code>Observable</code>去订阅观察者<code>s</code>。而这个<code>Worker</code>就是线程调度的关键！前面的例子中我们通过<code>subscribeOn(Schedulers.io())</code>指定了<code>Observable</code>发射处理事件以及通知观察者的一系列操作的执行线程，正是通过这个<code>Schedulers.io()</code>创建了我们前面提到的<code>Worker</code>。所以我们来看看<code>Schedulers.io()</code>的实现。</p>
<p>首先通过<code>Schedulers.io()</code>获得了<code>ioScheduler</code>并返回，上面的<code>OperatorSubscribeOn</code>通过这个的<code>Scheduler</code>的<code>createWorker()</code>方法创建了我们前面提到的<code>Worker</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">io</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> RxJavaHooks.onIOScheduler(getInstance().ioScheduler);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着我们看看这个<code>ioScheduler</code>是怎么来的，下面的代码向我们展现了是如何在<code>Schedulers</code>的构造函数中通过<code>RxJavaSchedulersHook.createIoScheduler()</code>来初始化<code>ioScheduler</code>的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">private</span> <span class="title">Schedulers</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    Scheduler io = hook.getIOScheduler();</div><div class="line">    <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</div><div class="line">        ioScheduler = io;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        ioScheduler = RxJavaSchedulersHook.createIoScheduler();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>最终<code>RxJavaSchedulersHook.createIoScheduler()</code>返回了一个<code>CachedThreadScheduler</code>，并赋值给了<code>ioScheduler</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">createIoScheduler</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> createIoScheduler(<span class="keyword">new</span> RxThreadFactory(<span class="string">"RxIoScheduler-"</span>));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">createIoScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CachedThreadScheduler(threadFactory);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这一步既然我们知道了<code>ioScheduler</code>就是一个<code>CachedThreadScheduler</code>，那我们就来看看它的<code>createWorker()</code>的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面的代码向我们赤裸裸的呈现了前面<code>OperatorSubscribeOn</code>中的<code>Worker</code>其实就是<code>EventLoopWorker</code>。我们重点要关注的是他的<code>scheduleActual()</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EventLoopWorker</span> <span class="keyword">extends</span> <span class="title">Scheduler</span>.<span class="title">Worker</span> <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CompositeSubscription innerSubscription = <span class="keyword">new</span> CompositeSubscription();</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> CachedWorkerPool pool;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadWorker threadWorker;</div><div class="line">    <span class="keyword">final</span> AtomicBoolean once;</div><div class="line"></div><div class="line">    EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class="line">        <span class="keyword">this</span>.pool = pool;</div><div class="line">        <span class="keyword">this</span>.once = <span class="keyword">new</span> AtomicBoolean();</div><div class="line">        <span class="keyword">this</span>.threadWorker = pool.get();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        ScheduledAction s = threadWorker.scheduleActual(<span class="keyword">new</span> Action0() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">                <span class="keyword">if</span> (isUnsubscribed()) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">                action.call();</div><div class="line">            &#125;</div><div class="line">        &#125;, delayTime, unit);</div><div class="line">        innerSubscription.add(s);</div><div class="line">        s.addParent(innerSubscription);</div><div class="line">        <span class="keyword">return</span> s;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>通过对源码的一步步追踪，我们知道了前面<code>OperatorSubscribeOn.call()</code>中的<code>inner.schedule()</code>最终会执行到<code>ThreadWorker</code>的<code>scheduleActual()</code>方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> ScheduledAction <span class="title">scheduleActual</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class="line">    Action0 decoratedAction = RxJavaHooks.onScheduledAction(action);</div><div class="line">    ScheduledAction run = <span class="keyword">new</span> ScheduledAction(decoratedAction);</div><div class="line">    Future&lt;?&gt; f;</div><div class="line">    <span class="keyword">if</span> (delayTime &lt;= <span class="number">0</span>) &#123;</div><div class="line">        f = executor.submit(run);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        f = executor.schedule(run, delayTime, unit);</div><div class="line">    &#125;</div><div class="line">    run.add(f);</div><div class="line">    <span class="keyword">return</span> run;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>scheduleActual()</code>中的<code>ScheduledAction</code>实现了<code>Runnable</code>接口，通过线程池<code>executor</code>最终实现了线程切换。上面便是<code>subscribeOn(Schedulers.io())</code>实现线程切换的全部过程。</p>
<h3 id="2-observeOn-源码分析"><a href="#2-observeOn-源码分析" class="headerlink" title="2. observeOn()源码分析"></a>2. observeOn()源码分析</h3><p><code>observeOn()</code>切换线程是通过<code>lift</code>来实现的，相比<code>subscribeOn()</code>在实现原理上相对复杂些。不过本质上最终还是创建了一个新的<code>Observable</code>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</div><div class="line">    ...</div><div class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorObserveOn</code>作为<code>OnSubscribeLift</code>构造函数的参数用来创建了一个新的<code>OnSubscribeLift</code>对象，接下来我们看看<code>OnSubscribeLift</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeLift</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; parent;</div><div class="line"></div><div class="line">    <span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeLift</span><span class="params">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.parent = parent;</div><div class="line">        <span class="keyword">this</span>.operator = operator;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</div><div class="line">        <span class="keyword">try</span> &#123;</div><div class="line">            Subscriber&lt;? <span class="keyword">super</span> T&gt; st = RxJavaHooks.onObservableLift(operator).call(o);</div><div class="line">            <span class="keyword">try</span> &#123;</div><div class="line">                st.onStart();</div><div class="line">                parent.call(st);</div><div class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">                Exceptions.throwIfFatal(e);</div><div class="line">                st.onError(e);</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">            Exceptions.throwIfFatal(e);</div><div class="line">            o.onError(e);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OnSubscribeLift</code>继承自<code>OnSubscribe</code>，通过前面的分析我们知道一旦调用了<code>subscribe()</code>将观察者与被观察绑定后就会触发被观察者所对应的<code>OnSubscribe</code>的<code>call()</code>方法，所以这里会触发<code>OnSubscribeLift.call()</code>。在<code>call()</code>中调用了<code>OperatorObserveOn.call()</code>并返回了一个新的观察者<code>Subscriber st</code>，接着调用了前一级<code>Observable</code>对应<code>OnSubscriber.call(st)</code>。</p>
<p>我们再看看<code>OperatorObserveOn.call()</code>的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</div><div class="line">    ...</div><div class="line">    ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class="line">    parent.init();</div><div class="line">    <span class="keyword">return</span> parent;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>OperatorObserveOn.call()</code>中创建了一个<code>ObserveOnSubscriber</code>并调用<code>init()</code>进行了初始化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable e)</span> </span>&#123;</div><div class="line">        ...</div><div class="line">        schedule();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</div><div class="line">            recursiveScheduler.schedule(<span class="keyword">this</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">long</span> missed = <span class="number">1L</span>;</div><div class="line">        <span class="keyword">long</span> currentEmission = emitted;</div><div class="line"></div><div class="line">        <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="keyword">this</span>.queue;</div><div class="line">        <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = <span class="keyword">this</span>.child;</div><div class="line">        <span class="keyword">final</span> NotificationLite&lt;T&gt; localOn = <span class="keyword">this</span>.on;</div><div class="line"></div><div class="line">        <span class="keyword">for</span> (;;) &#123;</div><div class="line">            <span class="keyword">long</span> requestAmount = requested.get();</div><div class="line"></div><div class="line">            <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</div><div class="line">                <span class="keyword">boolean</span> done = finished;</div><div class="line">                Object v = q.poll();</div><div class="line">                <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (checkTerminated(done, empty, localChild, q)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (empty) &#123;</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line"></div><div class="line">                localChild.onNext(localOn.getValue(v));</div><div class="line"></div><div class="line">                currentEmission++;</div><div class="line">                <span class="keyword">if</span> (currentEmission == limit) &#123;</div><div class="line">                    requestAmount = BackpressureUtils.produced(requested, currentEmission);</div><div class="line">                    request(currentEmission);</div><div class="line">                    currentEmission = <span class="number">0L</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="keyword">if</span> (requestAmount == currentEmission) &#123;</div><div class="line">                <span class="keyword">if</span> (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123;</div><div class="line">                    <span class="keyword">return</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            emitted = currentEmission;</div><div class="line">            missed = counter.addAndGet(-missed);</div><div class="line">            <span class="keyword">if</span> (missed == <span class="number">0L</span>) &#123;</div><div class="line">                <span class="keyword">break</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><code>ObserveOnSubscriber</code>继承自<code>Subscriber</code>，并实现了<code>Action0</code>接口。我们看到<code>ObserveOnSubscriber</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>都有个<code>schedule()</code>，这个方法就是我们线程调度的关键；通过<code>schedule()</code>将新观察者<code>ObserveOnSubscriber</code>发送给<code>subscriberOne</code>的所有事件都切换到了<code>recursiveScheduler</code>所对应的线程，简单的说就是把<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法丢到了<code>recursiveScheduler</code>对应的线程中来执行。</p>
<p>那么<code>schedule()</code>又是如何做到这一点的呢？他内部调用了<code>recursiveScheduler.schedule(this)</code>，<code>recursiveScheduler</code>其实就是一个<code>Worker</code>，和我们在介绍<code>subscribeOn()</code>时提到的<code>worker</code>一样，执行<code>schedule()</code>实际上最终是创建了一个<code>runable</code>，然后把这个<code>runnable</code>丢到了特定的线程池中去执行。在<code>runnable</code>的<code>run()</code>方法中调用了<code>ObserveOnSubscriber.call()</code>，看上面的代码大家就会发现在<code>call()</code>方法中最终调用了<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法。这便是它实现线程切换的原理。</p>
<p>好了，我们最后再看看<strong>示例C</strong>对应的执行流程图，帮助大家加深理解。</p>
<p><img src="http://resources.baronzhang.com/rxjava/6/OperatorProcess.jpg" alt="RxJava执行流程"></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>这一章以<strong>执行流程</strong>、<strong>操作符实现</strong>以及<strong>线程调度</strong>三个方面为切入点剖析了RxJava源码。下一章将站在更宏观的角度来分析整个RxJava的框架结构、设计思想等等。敬请期待~~ :)</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;RxJava基本流程分析&lt;/li&gt;
&lt;li&gt;操作符原理分析&lt;/li&gt;
&lt;li&gt;线程调度原理分析&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;本章节基于&lt;strong&gt;RxJava1.1.9&lt;/strong&gt;版本的源码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;一、RxJava执行流程分析&quot;&gt;&lt;a href=&quot;#一、RxJava执行流程分析&quot; class=&quot;headerlink&quot; title=&quot;一、RxJava执行流程分析&quot;&gt;&lt;/a&gt;一、RxJava执行流程分析&lt;/h2&gt;&lt;p&gt;在&lt;a href=&quot;http://www.jianshu.com/p/ba61c047c230&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;中我们介绍过，一个最基本的RxJava调用是这样的：&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列5(组合操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%975-%E7%BB%84%E5%90%88%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列5-组合操作符/</id>
    <published>2017-02-05T16:20:46.000Z</published>
    <updated>2019-08-19T06:53:46.660Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>   </li>
</ul>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<hr>
<p>这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： <strong><code>Merge</code></strong> <strong><code>StartWith</code></strong> <strong><code>Concat</code></strong> <strong><code>Zip</code></strong> <strong><code>CombineLatest</code></strong>  <strong><code>SwitchOnNext</code></strong> <strong><code>Join</code></strong>等等。</p>
<a id="more"></a>
<h3 id="Merge"><a href="#Merge" class="headerlink" title="Merge"></a>Merge</h3><p><strong><code>merge(Observable, Observable)</code></strong>将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。</p>
<p><img src="http://resources.baronzhang.com/rxjava/operator/merge/MergeOperator.png" alt="merge(Observable, Observable)"></p>
<p>我们看下面的例子，一共有两个Observable：一个用来发送字母，另一个用来发送数字；现在我们需要两连个Observable发射的数据合并。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.merge(letterSequence, numberSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                System.out.print(serializable.toString()+<span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A 0 B C 1 D E 2 F 3 G H 4
</code></pre><p><strong><code>merge(Observable[])</code></strong>将多个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。</p>
<p><img src="http://resources.baronzhang.com/rxjava/operator/merge/MergeIOOperator.png" alt="merge(Observable[])"></p>
<h3 id="StartWith"><a href="#StartWith" class="headerlink" title="StartWith"></a>StartWith</h3><p><strong><code>startWith(T)</code></strong>用于在源Observable发射的数据前插入数据。使用<strong><code>startWith(Iterable&lt;T&gt;)</code></strong>我们还可以在源Observable发射的数据前插入Iterable。官方示意图：<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/StartWithOperator.png" alt="startWith(T) startWith(Iterable&lt;T&gt;)"></p>
<p><strong><code>startWith(Observable&lt;T&gt;)</code></strong>用于在源Observable发射的数据前插入另一个Observable发射的数据（这些数据会被插入到<br>源Observable发射数据的前面）。官方示意图：<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/StartWithOOperator.png" alt="startWith(Observable&lt;T&gt;)"></p>
<h3 id="Concat"><a href="#Concat" class="headerlink" title="Concat"></a>Concat</h3><p><strong><code>concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)</code></strong> <strong><code>concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;</code>)</strong>用于将多个obserbavle发射的的数据进行合并发射，concat严格按照顺序发射数据，前一个Observable没发射玩是不会发射后一个Observable的数据的。它和merge、startWitch和相似，不同之处在于：</p>
<ol>
<li>merge:合并后发射的数据是无序的；</li>
<li>startWitch:只能在源Observable发射的数据前插入数据。</li>
</ol>
<p><img src="http://resources.baronzhang.com/rxjava/operator/merge/ConcatOperator.png" alt="concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)、concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;)"></p>
<p>这里我们将前面Merge操作符的例子拿过来，并将操作符换成<code>Concat</code>，然后我们看看执行结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">500</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.concat(letterSequence, numberSequence)</div><div class="line">        .subscribe(<span class="keyword">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Serializable serializable)</span> </span>&#123;</div><div class="line">                System.out.print(serializable.toString() + <span class="string">" "</span>);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A B C D E F G H 0 1 2 3 4
</code></pre><h3 id="Zip"><a href="#Zip" class="headerlink" title="Zip"></a>Zip</h3><p><strong><code>zip(Observable, Observable, Func2)</code></strong>用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/ZipOperator.png" alt="zip(Observable, Observable, Func2)"></p>
<p>和前面的例子一样，我们将操作符换成了<code>zip</code>:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">String[] letters = <span class="keyword">new</span> String[]&#123;<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>&#125;;</div><div class="line">Observable&lt;String&gt; letterSequence = Observable.interval(<span class="number">120</span>, TimeUnit.MILLISECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> letters[position.intValue()];</div><div class="line">            &#125;</div><div class="line">        &#125;).take(letters.length);</div><div class="line"></div><div class="line">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class="number">200</span>, TimeUnit.MILLISECONDS).take(<span class="number">5</span>);</div><div class="line"></div><div class="line">Observable.zip(letterSequence, numberSequence, <span class="keyword">new</span> Func2&lt;String, Long, String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String letter, Long number)</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> letter + number;</div><div class="line">    &#125;</div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String result)</span> </span>&#123;</div><div class="line">        System.out.print(result + <span class="string">" "</span>);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>A0 B1 C2 D3 E4
</code></pre><h3 id="CombineLatest"><a href="#CombineLatest" class="headerlink" title="CombineLatest"></a>CombineLatest</h3><p><strong><code>comnineLatest(Observable, Observable, Func2)</code></strong>用于将两个Observale最近发射的数据已经Func2函数的规则进展组合。下面是官方提供的原理图：<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/CombineLatestOperator.png" alt="comnineLatest(Observable, Observable, Func2)"></p>
<p>下面这张图应该更容易理解：<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/CombineLatest.png" alt="comnineLatest(Observable, Observable, Func2)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">List&lt;String&gt; communityNames = DataSimulator.getCommunityNames();</div><div class="line">List&lt;Location&gt; locations = DataSimulator.getLocations();</div><div class="line"></div><div class="line">Observable&lt;String&gt; communityNameSequence = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> communityNames.get(position.intValue());</div><div class="line">            &#125;</div><div class="line">        &#125;).take(communityNames.size());</div><div class="line">Observable&lt;Location&gt; locationSequence = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Long, Location&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Location <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> locations.get(position.intValue());</div><div class="line">            &#125;</div><div class="line">        &#125;).take(locations.size());</div><div class="line"></div><div class="line">Observable.combineLatest(</div><div class="line">        communityNameSequence,</div><div class="line">        locationSequence,</div><div class="line">        <span class="keyword">new</span> Func2&lt;String, Location, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String communityName, Location location)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"小区名:"</span> + communityName + <span class="string">", 经纬度:"</span> + location.toString();</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Error:"</span> + e.getMessage());</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                System.out.println(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区名:竹园新村, 经纬度:(21.827, 23.323)
小区名:康桥半岛, 经纬度:(21.827, 23.323)
小区名:康桥半岛, 经纬度:(11.923, 16.309)
小区名:中粮·海景壹号, 经纬度:(11.923, 16.309)
小区名:中粮·海景壹号, 经纬度:(22.273, 53.623)
小区名:浦江名苑, 经纬度:(22.273, 53.623)
小区名:南辉小区, 经纬度:(22.273, 53.623)
</code></pre><h3 id="SwitchOnNext"><a href="#SwitchOnNext" class="headerlink" title="SwitchOnNext"></a>SwitchOnNext</h3><p><strong><code>switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;</code></strong>用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新<br>的小Observable所发射的数据。</p>
<p>结合下面的原理图大家应该很容易理解，我们可以看到下图中的黄色圆圈就被丢弃了。<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/SwitchOnNextOperator.png" alt="switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;)"></p>
<h3 id="Join"><a href="#Join" class="headerlink" title="Join"></a>Join</h3><p><strong><code>join(Observable, Func1, Func1, Func2)</code></strong>我们先介绍下join操作符的4个参数：</p>
<ul>
<li>Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；</li>
<li>Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；</li>
<li>Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；</li>
<li>Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。</li>
</ul>
<p>所以Join操作符的语法结构大致是这样的：<strong><code>onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)</code></strong></p>
<p>join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： <code>[0, B]</code> <code>[1, B]</code> <code>[2, B]</code> <code>[3, B]</code></p>
<p>再看看下面的图是不是好理解了呢？！<br><img src="http://resources.baronzhang.com/rxjava/operator/merge/JoinOperator.png" alt="join(Observable, Func1, Func1, Func2)"></p>
<p>读懂了上面的文字，我们再来写段代码加深理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">final</span> List&lt;House&gt; houses = DataSimulator.getHouses();<span class="comment">//模拟的房源数据，用于测试</span></div><div class="line"></div><div class="line"><span class="comment">//用来每秒从houses总取出一套房源并发射出去</span></div><div class="line">Observable&lt;House&gt; houseSequence =</div><div class="line">        Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS)</div><div class="line">                .map(<span class="keyword">new</span> Func1&lt;Long, House&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> House <span class="title">call</span><span class="params">(Long position)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> houses.get(position.intValue());</div><div class="line">                    &#125;</div><div class="line">                &#125;).take(houses.size());<span class="comment">//这里的take是为了防止houses.get(position.intValue())数组越界</span></div><div class="line"></div><div class="line"><span class="comment">//用来实现每秒发送一个新的Long型数据</span></div><div class="line">Observable&lt;Long&gt; tictoc = Observable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</div><div class="line"></div><div class="line">houseSequence.join(tictoc,</div><div class="line">        <span class="keyword">new</span> Func1&lt;House, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">2</span>, TimeUnit.SECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Observable&lt;Long&gt; <span class="title">call</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> Observable.timer(<span class="number">0</span>, TimeUnit.SECONDS);</div><div class="line">            &#125;</div><div class="line">        &#125;,</div><div class="line">        <span class="keyword">new</span> Func2&lt;House, Long, String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house, Long aLong)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> aLong + <span class="string">"--&gt;"</span> + house.getDesc();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">).subscribe(<span class="keyword">new</span> Observer&lt;String&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.exit(<span class="number">0</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Error:"</span>+e.getMessage());</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">        System.out.println(s);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>0--&gt;中粮海景壹号新出大平层！总价4500W起
1--&gt;中粮海景壹号新出大平层！总价4500W起
1--&gt;满五唯一，黄金地段
2--&gt;中粮海景壹号新出大平层！总价4500W起
2--&gt;满五唯一，黄金地段
2--&gt;一楼自带小花园
3--&gt;一楼自带小花园
3--&gt;毗邻汤臣一品
4--&gt;毗邻汤臣一品
4--&gt;顶级住宅，给您总统般尊贵体验
5--&gt;顶级住宅，给您总统般尊贵体验
5--&gt;顶层户型，两室一厅
6--&gt;顶层户型，两室一厅
6--&gt;南北通透，豪华五房
7--&gt;南北通透，豪华五房
</code></pre><p>通过<a href="http://www.jianshu.com/p/5970280703b9" target="_blank" rel="external">转换操作符</a>、<a href="http://www.jianshu.com/p/3a188b995daa" target="_blank" rel="external">过滤操作符</a>、<a href="http://www.jianshu.com/p/546fe44a6e22" target="_blank" rel="external">组合操作符</a>三个篇幅将RxJava主要的操作符也介绍的七七八八了。更多操作符的介绍建议大家去查阅官方文档，并自己动手实践一下。这一系列的文章也会持续更新，欢迎大家保持关注！:)</p>
<p>Demo源码地址：<a href="https://github.com/BaronZ88/HelloRxJava" target="_blank" rel="external">https://github.com/BaronZ88/HelloRxJava</a></p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： &lt;strong&gt;&lt;code&gt;Merge&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;StartWith&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Concat&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Zip&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;CombineLatest&lt;/code&gt;&lt;/strong&gt;  &lt;strong&gt;&lt;code&gt;SwitchOnNext&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Join&lt;/code&gt;&lt;/strong&gt;等等。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列4(过滤操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%974-%E8%BF%87%E6%BB%A4%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列4-过滤操作符/</id>
    <published>2017-02-05T16:20:33.000Z</published>
    <updated>2019-08-19T06:53:46.660Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<hr>
<p>前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： <strong><code>Filter</code></strong> <strong><code>Take</code></strong> <strong><code>TakeLast</code></strong> <strong><code>TakeUntil</code></strong> <strong><code>Skip</code></strong> <strong><code>SkipLast</code></strong> <strong><code>ElementAt</code></strong> <strong><code>Debounce</code></strong> <strong><code>Distinct</code></strong> <strong><code>DistinctUntilChanged</code></strong> <strong><code>First</code></strong> <strong><code>Last</code></strong>等等。</p>
<a id="more"></a>
<h3 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a>Filter</h3><p><strong><code>filter(Func1)</code></strong>用来过滤观测序列中我们不想要的值，只返回满足条件的值，我们看下原理图：</p>
<p><img src="http://resources.baronzhang.com/rxjava/operator/filter/FilterOperator.png" alt="filter(Func1)"></p>
<p>还是拿前面文章中的小区<code>Community[] communities</code>来举例，假设我需要赛选出所有房源数大于10个的小区，我们可以这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .filter(<span class="keyword">new</span> Func1&lt;Community, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> community.houses.size()&gt;<span class="number">10</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Community&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">        System.out.println(community.name);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Take"><a href="#Take" class="headerlink" title="Take"></a>Take</h3><p><strong><code>take(int)</code></strong>用一个整数n作为一个参数，从原始的序列中发射前n个元素.<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/TakeOperator.png" alt="take(int)"></p>
<p>现在我们需要取小区列表<code>communities</code>中的前10个小区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .take(10)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```     </div><div class="line"></div><div class="line">### TakeLast</div><div class="line">**`takeLast(int)`**同样用一个整数n作为参数，只不过它发射的是观测序列中后n个元素。</div><div class="line">![takeLast(int)](http://resources.baronzhang.com/rxjava/operator/filter/TakeLastNOperator.png)</div><div class="line"></div><div class="line">获取小区列表`communities`中的后3个小区</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .takeLast(3)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="TakeUntil"><a href="#TakeUntil" class="headerlink" title="TakeUntil"></a>TakeUntil</h3><p><strong><code>takeUntil(Observable)</code></strong>订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，<code>takeUntil()</code>返回的Observable会停止发射原始Observable并终止。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/TakeUntilOperator.png" alt="takeUntil(Observable)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Long&gt; observableA = Observable.interval(<span class="number">300</span>, TimeUnit.MILLISECONDS);</div><div class="line">Observable&lt;Long&gt; observableB = Observable.interval(<span class="number">800</span>, TimeUnit.MILLISECONDS);</div><div class="line"></div><div class="line">observableA.takeUntil(observableB)</div><div class="line">        .subscribe(<span class="keyword">new</span> Subscriber&lt;Long&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">                System.exit(<span class="number">0</span>);</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Long aLong)</span> </span>&#123;</div><div class="line">                System.out.println(aLong);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    Thread.sleep(Integer.MAX_VALUE);</div><div class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</div><div class="line">    e.printStackTrace();</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>0
1
</code></pre><p><strong><code>takeUntil(Func1)</code></strong>通过Func1中的call方法来判断是否需要终止发射数据。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/TakeUntilPOperator.png" alt="takeUntil(Func1)"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</div><div class="line">                .takeUntil(<span class="keyword">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</div><div class="line">                    <span class="meta">@Override</span></div><div class="line">                    <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                        <span class="keyword">return</span> integer &gt;= <span class="number">5</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">                System.out.println(integer);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>1
2
3
4
5
</code></pre><p>###Skip<br><strong><code>skip(int)</code></strong>让我们可以忽略Observable发射的前n项数据。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/SkipOperator.png" alt="skip(int)"></p>
<p>过滤掉小区列表<code>communities</code>中的前5个小区</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .skip(5)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                System.out.println(community.name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```        </div><div class="line"></div><div class="line"></div><div class="line">### SkipLast</div><div class="line"></div><div class="line">**`skipLast(int)`**忽略Observable发射的后n项数据。</div><div class="line">![skipLast(int)](http://resources.baronzhang.com/rxjava/operator/filter/SkipLastOperator.png)</div><div class="line"></div><div class="line">### ElementAt</div><div class="line">**`elementAt(int)`**用来获取元素Observable发射的事件序列中的第n项数据，并当做唯一的数据发射出去。</div><div class="line">![elementAt(int)](http://resources.baronzhang.com/rxjava/operator/filter/ElementAtOperator.png)</div><div class="line"></div><div class="line">### Debounce</div><div class="line">**`debounce(long, TimeUnit)`**过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBing(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</div><div class="line">![debounce(long, TimeUnit)](http://resources.baronzhang.com/rxjava/operator/filter/DebounceOperator.png)</div><div class="line"></div><div class="line">**`debounce(Func1)`**可以根据Func1的call方法中的函数来过滤，Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。</div><div class="line">![debounce(Func1)](http://resources.baronzhang.com/rxjava/operator/filter/DebounceFOperator.png)</div><div class="line"></div><div class="line">### Distinct</div><div class="line">**`distinct()`**的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。</div><div class="line">![distinct()](http://resources.baronzhang.com/rxjava/operator/filter/DistinctOperator.png)</div><div class="line"></div><div class="line">过滤掉一段数字中的重复项：</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class="line">        .distinct()</div><div class="line">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer i) &#123;</div><div class="line">                System.out.print(i + " ");</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>2 1 3 4 5
</code></pre><p><strong><code>distinct(Func1)</code></strong>参数中的Func1中的call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是不是相同；如果判定为重复则会和<code>distinct()</code>一样过滤掉重复的数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/DistinctKeyOperator.png" alt="distinct(Func1)"></p>
<p>假设我们要过滤掉一堆房源中小区名重复的小区：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line"><span class="comment">//House构造函数中的第一个参数为该房源所属小区名，第二个参数为房源描述</span></div><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"中粮海景壹号新出大平层！总价4500W起"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"满五唯一，黄金地段"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"一楼自带小花园"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"毗邻汤臣一品"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"顶级住宅，给您总统般尊贵体验"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"顶层户型，两室一厅"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"南北通透，豪华五房"</span>));</div><div class="line">Observable.from(houses)</div><div class="line">        .distinct(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:竹园新村; 房源描述:满五唯一，黄金地段
</code></pre><h3 id="DistinctUntilChanged"><a href="#DistinctUntilChanged" class="headerlink" title="DistinctUntilChanged"></a>DistinctUntilChanged</h3><p><strong><code>distinctUntilChanged()</code></strong>和<code>distinct()</code>类似，只不过它判定的是Observable发射的当前数据项和前一个数据项是否相同。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/DistinctUntilChangedOperator.png" alt="distinctUntilChanged()"></p>
<p>同样还是上面过滤数字的例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class="line">        .distinctUntilChanged()</div><div class="line">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Integer i) &#123;</div><div class="line">                System.out.print(i + &quot; &quot;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>2 1 2 3 4 3 4 5
</code></pre><p><strong><code>distinctUntilChanged(Func1)</code></strong>和<code>distinct(Func1)</code>一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/DistinctUntilChangedKeyOperator.png" alt="distinctUntilChanged(Func1)"></p>
<p>我们还是拿前面的过滤房源的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .distinctUntilChanged(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:竹园新村; 房源描述:满五唯一，黄金地段
小区:中粮·海景壹号; 房源描述:毗邻汤臣一品
小区:竹园新村; 房源描述:顶层户型，两室一厅
小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
</code></pre><h3 id="First"><a href="#First" class="headerlink" title="First"></a>First</h3><p><strong><code>first()</code></strong>顾名思义，它是的Observable只发送观测序列中的第一个数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/FirstOperator.png" alt="first()"></p>
<p>获取房源列表<code>houses</code>中的第一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .first()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;                </div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
</code></pre><p><strong><code>first(Func1)</code></strong>只发送符合条件的第一个数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/FirstNOperator.png" alt="first(Func1)"></p>
<p>现在我们要获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的第一套房源。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .first(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"竹园新村"</span>.equals(house.communityName);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:竹园新村; 房源描述:满五唯一，黄金地段
</code></pre><h3 id="Last"><a href="#Last" class="headerlink" title="Last"></a>Last</h3><p><strong><code>last()</code></strong>只发射观测序列中的最后一个数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/LastOperator.png" alt="last()"></p>
<p>获取房源列表中的最后一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .last()</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
</code></pre><p><strong><code>last(Func1)</code></strong>只发射观测序列中符合条件的最后一个数据项。<br><img src="http://resources.baronzhang.com/rxjava/operator/filter/LastPOperator.png" alt="last(Func1)"></p>
<p>获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的最后一套房源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.from(houses)</div><div class="line">        .last(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"竹园新村"</span>.equals(house.communityName);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span> + house.communityName + <span class="string">"; 房源描述:"</span> + house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>程序输出：</p>
<pre><code>小区:竹园新村; 房源描述:顶层户型，两室一厅
</code></pre><p>这一章我们就先聊到这，更多的过滤类操作符的介绍大家可以去查阅官方文档和源码；在下一章我们将继续介绍组合类操作符。</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： &lt;strong&gt;&lt;code&gt;Filter&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Take&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;TakeLast&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;TakeUntil&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Skip&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;SkipLast&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;ElementAt&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Debounce&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Distinct&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;DistinctUntilChanged&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;First&lt;/code&gt;&lt;/strong&gt; &lt;strong&gt;&lt;code&gt;Last&lt;/code&gt;&lt;/strong&gt;等等。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列3(转换操作符)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%973-%E8%BD%AC%E6%8D%A2%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列3-转换操作符/</id>
    <published>2017-02-05T16:20:19.000Z</published>
    <updated>2019-08-19T06:53:46.660Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>   </li>
</ul>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<hr>
<p>前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：</p>
<ol>
<li><strong>转换类操作符</strong></li>
<li><strong>过滤类操作符</strong></li>
<li><strong>组合类操作符</strong></li>
</ol>
<p>这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。</p>
<a id="more"></a>
<h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><strong><code>map(Func1)</code></strong>函数接受一个Func1类型的参数(就像这样<code>map(Func1&lt;? super T, ? extends R&gt; func)</code>),然后吧这个Func1应用到每一个由Observable发射的值上，将发射的只转换为我们期望的值。这种狗屁定义我相信你也听不懂，我们来看一下官方给出的原理图：</p>
<p><img src="http://resources.baronzhang.com/rxjava/operator/map/MapOperator.png" alt="map(Func1)"></p>
<p>假设我们需要将一组数字装换成字符串，我们可以通过map这样实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Integer i)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> <span class="string">"This is "</span> + i;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</div><div class="line">                System.out.println(s);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<blockquote>
<p>Func1构造函数中的两个参数分别是Observable发射值当前的类型和map转换后的类型，上面这个例子中发射值当前的类型是Integer,转换后的类型是String。</p>
</blockquote>
<h3 id="FlatMap"><a href="#FlatMap" class="headerlink" title="FlatMap"></a>FlatMap</h3><p><strong><code>flatMap(Func1)</code></strong>函数同样也是做转换的，但是作用却不一样。flatMap不太好理解，我们直接看例子（<em>我们公司是个房产平台，那我就拿房子举例</em>）：假设我们有一组小区数据<code>Community[] communites</code>,现在我们要输出每个小区的名字；我们可以这样实现:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">Observable.from(communities)</div><div class="line">        .map(<span class="keyword">new</span> Func1&lt;Community, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> community.name;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;String&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(String name)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"Community name : "</span> + name);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>现在我们需求有变化，需要打印出每个小区下面每一套房子的价格。于是我可以这样实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div></pre></td><td class="code"><pre><div class="line">Community[] communities = &#123;&#125;;</div><div class="line">Observable.from(communities)</div><div class="line">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(Community community) &#123;</div><div class="line">                for (House house : community.houses) &#123;</div><div class="line">                    System.out.println("House price : " + house.price);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```            </div><div class="line"></div><div class="line">如果我不想在Subscriber中使用for循环，而是希望Subscriber中直接传入单个的House对象呢？用map()显然是不行的，因为map()是一对一的转化，而我现在的要求是一对多的转化。那么我们可以使用flatMap()把一个Community转化成多个House。</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Observable&lt;House&gt; call(Community community) &#123;</div><div class="line">                return Observable.from(community.houses);</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public void call(House house) &#123;</div><div class="line">                System.out.println("House price : " + house.price);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">```            </div><div class="line"></div><div class="line">从前面的例子中我们发现，flatMap()和map()都是把传入的参数转化之后返回另一个对象。但和map()不同的是，flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到 Subscriber的回调方法中。</div><div class="line"></div><div class="line">flatMap(Func1)的原理是这样的：</div><div class="line"></div><div class="line">1. 将传入的事件对象装换成一个Observable对象；</div><div class="line">2. 这是不会直接发送这个Observable, 而是将这个Observable激活让它自己开始发送事件；</div><div class="line">3. 每一个创建出来的Observable发送的事件，都被汇入同一个Observable，这个Observable负责将这些事件统一交给Subscriber的回调方法。</div><div class="line"></div><div class="line">这三个步骤，把事件拆成了两级，通过一组新创建的Observable将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是flatMap()所谓的flat。</div><div class="line"></div><div class="line">最后我们来看看flatMap的原理图：</div><div class="line">![flatMap(Func1)](http://resources.baronzhang.com/rxjava/operator/map/FlatMapOperator.png)</div><div class="line"></div><div class="line">### ConcatMap</div><div class="line">**`concatMap(Func1)`**解决了`flatMap()`的交叉问题，它能够把发射的值连续在一起，就像这样：</div><div class="line">![concatMap(Func1)](http://resources.baronzhang.com/rxjava/operator/map/ConcatMapOperator.png)</div><div class="line"></div><div class="line">### flatMapIterable</div><div class="line">**`flatMapIterable(Func1)`**和`flatMap()`几乎是一样的，不同的是`flatMapIterable()`它转化的多个Observable是使用Iterable作为源数据的。</div><div class="line">![flatMapIterable(Func1)](http://resources.baronzhang.com/rxjava/operator/map/FlatMapIterableOperator.png)</div><div class="line"></div><div class="line">```java</div><div class="line">Observable.from(communities)</div><div class="line">        .flatMapIterable(new Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123;</div><div class="line">            @Override</div><div class="line">            public Iterable&lt;House&gt; call(Community community) &#123;</div><div class="line">                return community.houses;</div><div class="line">            &#125;</div><div class="line">        &#125;)</div><div class="line">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class="line"></div><div class="line">            @Override</div><div class="line">            public void call(House house) &#123;</div><div class="line"></div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<h3 id="SwitchMap"><a href="#SwitchMap" class="headerlink" title="SwitchMap"></a>SwitchMap</h3><p><strong><code>switchMap(Func1)</code></strong>和<code>flatMap(Func1)</code>很像，除了一点：每当源<code>Observable</code>发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的<code>Observable</code>，并开始监视当前发射的这一个。<br><img src="http://resources.baronzhang.com/rxjava/operator/map/SwitchMapOperator.png" alt="switchMap(Func1)"></p>
<h3 id="Scan"><a href="#Scan" class="headerlink" title="Scan"></a>Scan</h3><p><strong><code>scan(Func2)</code></strong>对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用合格函数时的第一个参数使用。<br><img src="http://resources.baronzhang.com/rxjava/operator/map/ScanOperator.png" alt="scan(Func2)"></p>
<p>我们来看个简单的例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">Observable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</div><div class="line">        .scan(<span class="keyword">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">(Integer integer, Integer integer2)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> integer + integer2;</div><div class="line">            &#125;</div><div class="line">        &#125;).subscribe(<span class="keyword">new</span> Action1&lt;Integer&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Integer integer)</span> </span>&#123;</div><div class="line">        System.out.print(integer+“ ”);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>输出结果为：</p>
<pre><code>1 3 6 10 15  
</code></pre><h3 id="GroupBy"><a href="#GroupBy" class="headerlink" title="GroupBy"></a>GroupBy</h3><p><strong><code>groupBy(Func1)</code></strong>将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小Observable分别发射其所包含的的数据，和SQL中的groupBy类似。实际使用中，我们需要提供一个生成key的规则（也就是Func1中的call方法），所有key相同的数据会包含在同一个小的Observable中。另外我们还可以提供一个函数来对这些数据进行转化，有点类似于集成了flatMap。<br><img src="http://resources.baronzhang.com/rxjava/operator/map/GroupByOperator.png" alt="groupBy(Func1)"></p>
<p>单纯的文字描述和图片解释可能难以理解，我们来看个例子：假设我现在有一组房源<code>List&lt;House&gt; houses</code>,每套房子都属于某一个小区，现在我们需要根据小区名来对房源进行分类，然后依次将房源信息输出。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">List&lt;House&gt; houses = <span class="keyword">new</span> ArrayList&lt;&gt;();</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"中粮海景壹号新出大平层！总价4500W起"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"满五唯一，黄金地段"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"毗邻汤臣一品"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"竹园新村"</span>, <span class="string">"顶层户型，两室一厅"</span>));</div><div class="line">houses.add(<span class="keyword">new</span> House(<span class="string">"中粮·海景壹号"</span>, <span class="string">"南北通透，豪华五房"</span>));</div><div class="line">Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable.from(houses)</div><div class="line">        .groupBy(<span class="keyword">new</span> Func1&lt;House, String&gt;() &#123;</div><div class="line"></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                <span class="keyword">return</span> house.communityName;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>通过上面的代码我们创建了一个新的Observable:<code>groupByCommunityNameObservable</code>，它将会发送一个带有<code>GroupedObservable</code>的序列（也就是指发送的数据项的类型为GroupedObservable）。<code>GroupedObservable</code>是一个特殊的<code>Observable</code>，它基于一个分组的key，在这个例子中的key就是小区名。现在我们需要将分类后的房源依次输出：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable.concat(groupByCommunityNameObservable)</div><div class="line">        .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                System.out.println(<span class="string">"小区:"</span>+house.communityName+<span class="string">"; 房源描述:"</span>+house.desc);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div></pre></td></tr></table></figure>
<p>执行结果：</p>
<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起
小区:中粮·海景壹号; 房源描述:毗邻汤臣一品
小区:中粮·海景壹号; 房源描述:南北通透，豪华五房
小区:竹园新村; 房源描述:满五唯一，黄金地段
小区:竹园新村; 房源描述:顶层户型，两室一厅
</code></pre><p>转换类的操作符就先介绍到这，后续还会继续介绍组合、过滤类的操作符及源码分析，敬请期待！</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;p&gt;前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;转换类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;过滤类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;组合类操作符&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列2(基本概念及使用介绍)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%972-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E5%8F%8A%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列2-基本概念及使用介绍/</id>
    <published>2017-02-05T16:20:04.000Z</published>
    <updated>2019-08-19T06:53:46.660Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>   </li>
</ul>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>上一篇的示例代码中大家一定发现了Observable这个类。从纯Java的观点看，Observable类源自于经典的观察者模式。RxJava的异步实现正是基于观察者模式来实现的，而且是一种扩展的观察者模式。</p>
<a id="more"></a>
<h2 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h2><p>观察者模式基于Subject这个概念，Subject是一种特殊对象，又叫做<strong>主题</strong>或者<strong>被观察者</strong>。当它改变时那些由它保存的一系列对象将会得到通知，而这一系列对象被称作Observer(<strong>观察者</strong>)。它们会对外暴漏了一个通知方法(比方说update之类的)，当Subject状态发生变化时会调用的这个方法。</p>
<p>观察者模式很适合下面这些场景中的任何一个：</p>
<ol>
<li>当你的架构有两个实体类，一个依赖另一个，你想让它们互不影响或者是独立复用它们时。</li>
<li>当一个变化的对象通知那些与它自身变化相关联的未知数量的对象时。</li>
<li>当一个变化的对象通知那些无需推断具体类型的对象时。</li>
</ol>
<p>通常一个观察者模式的类图是这样的：</p>
<p><img src="http://resources.baronzhang.com/rxjava/2/Observer.png" alt="Observer"></p>
<p>如果你对观察者模式不是很了解，那么强烈建议你先去学习下。关于观察者模式的详细介绍可以参考我之前的文章：<a href="http://www.jianshu.com/p/d55ee6e83d66" target="_blank" rel="external">设计模式之观察者模式</a></p>
<h2 id="扩展的观察者模式"><a href="#扩展的观察者模式" class="headerlink" title="扩展的观察者模式"></a>扩展的观察者模式</h2><p>在RxJava中主要有4个角色：</p>
<ul>
<li>Observable</li>
<li>Subject</li>
<li>Observer</li>
<li>Subscriber</li>
</ul>
<p>Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。说直白点<code>Observable</code>对应于观察者模式中的<strong>被观察者</strong>，而<code>Observer</code>和<code>Subscriber</code>对应于观察者模式中的<strong>观察者</strong>。<code>Subscriber</code>其实是一个实现了<code>Observer</code>的抽象类，后面我们分析源码的时候也会介绍到。<code>Subject</code>比较复杂，以后再分析。</p>
<p>上一篇文章中我们说到RxJava中有个关键概念：<strong>事件</strong>。观察者<code>Observer</code>和被观察者<code>Observable</code>通过<code>subscribe()</code>方法实现订阅关系。从而<code>Observable</code> 可以在需要的时候发出<strong>事件</strong>来通知<code>Observer</code>。</p>
<h2 id="RxJava如何使用"><a href="#RxJava如何使用" class="headerlink" title="RxJava如何使用"></a>RxJava如何使用</h2><p>我自己在学习一种新技术的时候通常喜欢先去了解它是怎么用的，掌握了使用方法后再去深挖其原理。那么我们现在就来说说RxJava到底该怎么用。</p>
<p><strong>第一步：创建观察者Observer</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line">Observer&lt;Object&gt; observer = <span class="keyword">new</span> Observer&lt;Object&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Object s)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line"> &#125;;</div></pre></td></tr></table></figure>
<p>这么简单，一个观察者Observer创建了!</p>
<p>大兄弟你等等…，你之前那篇<a href="http://www.jianshu.com/p/d55ee6e83d66" target="_blank" rel="external">观察者模式</a>中不是说观察者只提供一个update方法的吗？这特么怎么有三个？！！</p>
<p>少年勿急，且听我慢慢道来。在普通的观察者模式中观察者一般只会提供一个update()方法用于被观察者的状态发生变化时，用于提供给被观察者调用。而在RxJava中的观察者Observer提供了:<code>onNext()</code>、 <code>onCompleted()</code>和<code>onError()</code>三个方法。还记得吗？开篇我们讲过RxJava是基于一种扩展的观察这模式实现，这里多出的onCompleted和onError正是对观察者模式的扩展。<em>ps:onNext就相当于普通观察者模式中的update</em></p>
<p>RxJava中添加了普通观察者模式缺失的三个功能：</p>
<ol>
<li>RxJava中规定当不再有新的事件发出时，可以调用onCompleted()方法作为标示；</li>
<li>当事件处理出现异常时框架自动触发onError()方法；</li>
<li>同时Observables支持链式调用，从而避免了回调嵌套的问题。</li>
</ol>
<p><strong>第二步：创建被观察者Observable</strong></p>
<p><code>Observable.create()</code>方法可以创建一个Observable，使用<code>crate()</code>创建Observable需要一个OnSubscribe对象，这个对象继承Action1。当观察者订阅我们的Observable时，它作为一个参数传入并执行<code>call()</code>函数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">Observable&lt;Object&gt; observable = Observable.create(<span class="keyword">new</span></div><div class="line">        	Observable.OnSubscribe&lt;Object&gt;() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Object&gt; subscriber)</span> </span>&#123;</div><div class="line"></div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>除了create()，just()和from()同样可以创建Observable。看看下面两个例子：</p>
<p><code>just(T...)</code>将传入的参数依次发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">Observable observable = Observable.just(<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>);</div><div class="line"><span class="comment">//上面这行代码会依次调用</span></div><div class="line"><span class="comment">//onNext("One");</span></div><div class="line"><span class="comment">//onNext("Two");</span></div><div class="line"><span class="comment">//onNext("Three");</span></div><div class="line"><span class="comment">//onCompleted();</span></div></pre></td></tr></table></figure>
<p><code>from(T[])/from(Iterable&lt;? extends T&gt;)</code>将传入的数组或者Iterable拆分成Java对象依次发送</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">String[] parameters = &#123;<span class="string">"One"</span>, <span class="string">"Two"</span>, <span class="string">"Three"</span>&#125;;</div><div class="line">Observable observable = Observable.from(parameters);</div><div class="line"><span class="comment">//上面这行代码会依次调用</span></div><div class="line"><span class="comment">//onNext("One");</span></div><div class="line"><span class="comment">//onNext("Two");</span></div><div class="line"><span class="comment">//onNext("Three");</span></div><div class="line"><span class="comment">//onCompleted();</span></div></pre></td></tr></table></figure>
<p><strong>第三步：被观察者Observable订阅观察者Observer</strong>（<em>ps:你没看错，不同于普通的观察者模式，这里是被观察者订阅观察者</em>）</p>
<p>有了观察者和被观察者，我们就可以通过subscribe()来实现二者的订阅关系了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">observable.subscribe(observer);</div></pre></td></tr></table></figure>
<p><img src="http://resources.baronzhang.com/rxjava/2/subscribe1.png" alt="observable.subscribe(observer)"></p>
<p>连在一起写就是这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</div><div class="line">            subscriber.onNext(i);</div><div class="line">        &#125;</div><div class="line">        subscriber.onCompleted();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">&#125;).subscribe(<span class="keyword">new</span> Observer&lt;Integer&gt;() &#123;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onCompleted"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"onError"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(Integer item)</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"Item is "</span> + item);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>至此一个完整的RxJava调用就完成了。</p>
<p>兄台，你叨逼叨叨逼叨的说了一大堆，可是我没搞定你特么到底在干啥啊？！！不急，我现在就来告诉你们到底发生了什么。</p>
<p>首先我们使用Observable.create()创建了一个新的Observable<integer>，并为<code>create()</code>方法传入了一个OnSubscribe，OnSubscribe中包含一个<code>call()</code>方法，一旦我们调用<code>subscribe()</code>订阅后就会自动触发call()方法。call()方法中的参数Subscriber其实就是subscribe()方法中的观察者Observer。我们在<code>call()</code>方法中调用了5次<code>onNext()</code>和1次<code>onCompleted()</code>方法。一套流程周下来以后输出结果就是下面这样的：</integer></p>
<pre><code>Item is 0
Item is 1
Item is 2
Item is 3
Item is 4
onCompleted
</code></pre><p>看到这里可能你又要说了，大兄弟你别唬我啊！OnSubscribe的call()方法中的参数Subscriber怎么就变成了subscribe()方法中的观察者Observer？！！！这俩儿货明明看起来就是两个不同的类啊。</p>
<p>我们先看看Subscriber这个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt;, <span class="title">Subscription</span> </span>&#123;</div><div class="line"></div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>从源码中我们可以看到，Subscriber是Observer的一个抽象实现类，所以我首先可以肯定的是Subscriber和Observer类型是一致的。接着往下我们看看subscribe()这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(<span class="keyword">final</span> Observer&lt;? <span class="keyword">super</span> T&gt; observer)</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//这里的if判断对于我们要分享的问题没有关联，可以先无视</span></div><div class="line">    <span class="keyword">if</span> (observer <span class="keyword">instanceof</span> Subscriber) &#123;</div><div class="line">        <span class="keyword">return</span> subscribe((Subscriber&lt;? <span class="keyword">super</span> T&gt;)observer);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</div><div class="line">            observer.onCompleted();</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</div><div class="line">            observer.onError(e);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</div><div class="line">            observer.onNext(t);</div><div class="line">        &#125;</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们看到subscribe()方法内部首先将传进来的Observer做了一层代理，将它转换成了Subscriber。我们再看看这个方法内部的subscribe()方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>进一步往下追踪看看return后面这段代码到底做了什么。精简掉其他无关代码后的subscribe(subscriber, this)方法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class="line"></div><div class="line">    subscriber.onStart();</div><div class="line">    <span class="keyword">try</span> &#123;</div><div class="line">        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</div><div class="line">        <span class="keyword">return</span> hook.onSubscribeReturn(subscriber);</div><div class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</div><div class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>我们重点看看hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber),前面这个hook.onSubscribeStart(observable, observable.onSubscribe)返回的是它自己括号内的第二个参数observable.onSubscribe,然后调用了它的call方法。而这个observable.onSubscribe正是create()方法中的Subscriber，这样整个流程就理顺了。看到这里是不是对RxJava的执行流程清晰了一点呢？这里也建议大家在学习新技术的时候多去翻一翻源码，知其然还要能知其所以然不是吗。</p>
<blockquote>
<p>subscribe()的参数除了可以是Observer和Subscriber以外还可以是Action1、Action0；这是一种更简单的回调，只有一个call(T)方法；由于太简单这里就不做详细介绍了！</p>
</blockquote>
<h2 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h2><p>上一篇文章中开篇就讲到RxJava就是来处理异步任务的。但是默认情况下我们在哪个线程调用subscribe()就在哪个线程生产事件，在哪个线程生产事件就在哪个线程消费事件。那怎么做到异步呢？RxJava为我们提供Scheduler用来做线程调度，我们来看看RxJava提供了哪些Scheduler。</p>
<table class="table table-striped"><tr><th>Schedulers</th><th>作用</th></tr><tr><td>Schedulers.immediate()</td><td>默认的Scheduler，直接在当前线程运行</td></tr><tr><td>Schedulers.newThread()</td><td>总是开启一个新线程</td></tr><tr><td>Schedulers.io()</td><td>用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io()默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</td></tr><tr><td>Schedulers.computation()</td><td>计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU</td></tr><tr><td>Schedulers.from(executor)</td><td>使用指定的Executor作为调度器</td></tr><tr><td>Schedulers.trampoline()</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>RxAndroid中新增的Scheduler，表示在Android的main线程中运行</td></tr></table>

<p>同时RxJava还为我们提供了<code>subscribeOn()</code>和<code>observeOn()</code>两个方法来指定Observable和Observer运行的线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Observable.from(getCommunitiesFromServer())</div><div class="line">            .flatMap(community -&gt; Observable.from(community.houses))</div><div class="line">            .filter(house -&gt; house.price&gt;=<span class="number">5000000</span>).subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(<span class="keyword">this</span>::addHouseInformationToScreen);</div></pre></td></tr></table></figure>
<p>上面这段代码大家应该有印象吧，没错正是我们上一篇文章中的例子。<code>subscribeOn(Schedulers.io())</code>指定了获取小区列表、处理房源信息等一系列事件都是在IO线程中运行，<code>observeOn(AndroidSchedulers.mainThread())</code>指定了在屏幕上展示房源的操作在UI线程执行。这就做到了在子线程获取房源，主线程展示房源。</p>
<p>好了，RxJava系列的入门内容我们就聊到这。下一篇我们再继续介绍更多的API以及它们内部的原理。</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;   &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;上一篇的示例代码中大家一定发现了Observable这个类。从纯Java的观点看，Observable类源自于经典的观察者模式。RxJava的异步实现正是基于观察者模式来实现的，而且是一种扩展的观察者模式。&lt;/p&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>RxJava系列1(简介)</title>
    <link href="http://baronzhang.com//blog/RxJava/RxJava%E7%B3%BB%E5%88%971-%E7%AE%80%E4%BB%8B/"/>
    <id>http://baronzhang.com//blog/RxJava/RxJava系列1-简介/</id>
    <published>2017-02-05T16:19:48.000Z</published>
    <updated>2019-08-19T06:53:46.656Z</updated>
    
    <content type="html"><![CDATA[<ul>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列1-简介/">RxJava系列1(简介)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/">RxJava系列2(基本概念及使用介绍)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/">RxJava系列3(转换操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/">RxJava系列4(过滤操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/">RxJava系列5(组合操作符)</a></li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>
<li><a href="http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/">RxJava系列7(最佳实践)</a>  </li>
</ul>
<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。</p>
<blockquote>
<p>由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。</p>
</blockquote>
<a id="more"></a>
<h2 id="响应式编程"><a href="#响应式编程" class="headerlink" title="响应式编程"></a>响应式编程</h2><p>在介绍RxJava前，我们先聊聊响应式编程。那么什么是响应式编程呢？响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</p>
<p>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。</p>
<p>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</p>
<blockquote>
<p>本章节中部分概念摘自《RxJava Essentials》一书</p>
</blockquote>
<h2 id="RxJava的来历"><a href="#RxJava的来历" class="headerlink" title="RxJava的来历"></a>RxJava的来历</h2><p>Rx是微软.Net的一个响应式扩展，Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012年Netflix为了应对不断增长的业务需求开始将.NET Rx迁移到JVM上面。并于13年二月份正式向外展示了RxJava。<br>从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。</p>
<p><img src="http://resources.baronzhang.com/rxjava/1/RxJava%E6%9D%A5%E5%8E%86.png" alt="RxJava来历"></p>
<h2 id="什么是RxJava"><a href="#什么是RxJava" class="headerlink" title="什么是RxJava"></a>什么是RxJava</h2><p>那么到底什么是RxJava呢？我对它的定义是：<strong>RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。</strong></p>
<h2 id="RxJava好在哪"><a href="#RxJava好在哪" class="headerlink" title="RxJava好在哪"></a>RxJava好在哪</h2><p>Android平台上为已经开发者提供了AsyncTask,Handler等用来做异步操作的类库，那我们为什么还要选择RxJava呢？答案是简洁！RxJava可以用非常简洁的代码逻辑来解决复杂问题；而且即使业务逻辑的越来越复杂，它依然能够保持简洁！再配合上Lambda用简单的几行代码分分钟就解决你负责的业务问题。简直逼格爆表，拿它装逼那是极好的！</p>
<p>多说无益，上代码！</p>
<p>假设我们安居客用户App上有个需求，需要从服务端拉取上海浦东新区塘桥板块的所有小区Community[] communities，每个小区下包含多套房源List<house> houses；我们需要把塘桥板块的所有总价大于500W的房源都展示在App的房源列表页。用于从服务端拉取communities需要发起网络请求，比较耗时，因此需要在后台运行。而这些房源信息需要展示到App的页面上，因此需要在UI线程上执行。(<em>此例子思路来源于扔物线的<a href="http://gank.io/post/560e15be2dca930e00da1083" target="_blank" rel="external">给Android开发者的RxJava详解</a>一文</em>)</house></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">new</span> Thread() &#123;</div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">            <span class="keyword">super</span>.run();</div><div class="line">            <span class="comment">//从服务端获取小区列表</span></div><div class="line">            List&lt;Community&gt; communities = getCommunitiesFromServer();</div><div class="line">            <span class="keyword">for</span> (Community community : communities) &#123;</div><div class="line">                List&lt;House&gt; houses = community.houses;</div><div class="line">                <span class="keyword">for</span> (House house : houses) &#123;</div><div class="line">                    <span class="keyword">if</span> (house.price &gt;= <span class="number">5000000</span>) &#123;</div><div class="line">                        runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</div><div class="line">                            <span class="meta">@Override</span></div><div class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</div><div class="line">                                <span class="comment">//将房子的信息添加到屏幕上</span></div><div class="line">                                addHouseInformationToScreen(house);</div><div class="line">                            &#125;</div><div class="line">                        &#125;);</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;.start();</div></pre></td></tr></table></figure>
<p>使用RxJava的写法是这样的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">Observable.from(getCommunitiesFromServer())</div><div class="line">            .flatMap(<span class="keyword">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Observable&lt;House&gt; <span class="title">call</span><span class="params">(Community community)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> Observable.from(community.houses);</div><div class="line">                &#125;</div><div class="line">            &#125;).filter(<span class="keyword">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> Boolean <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                    <span class="keyword">return</span> house.price&gt;=<span class="number">5000000</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;).subscribeOn(Schedulers.io())</div><div class="line">            .observeOn(AndroidSchedulers.mainThread())</div><div class="line">            .subscribe(<span class="keyword">new</span> Action1&lt;House&gt;() &#123;</div><div class="line">                <span class="meta">@Override</span></div><div class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(House house)</span> </span>&#123;</div><div class="line">                    <span class="comment">//将房子的信息添加到屏幕上</span></div><div class="line">                    addHouseInformationToScreen(house);</div><div class="line">                &#125;</div><div class="line">            &#125;);</div></pre></td></tr></table></figure>
<p>从上面这段代码我们可以看到：虽然代码量看起来变复杂了，但是RxJava的实现是一条链式调用，没有任何的嵌套；整个实现逻辑看起来异常简洁清晰，这对我们的编程实现和后期维护是有巨大帮助的。特别是对于那些回调嵌套的场景。配合Lambda表达式还可以简化成这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Observable.from(getCommunitiesFromServer())</div><div class="line">        .flatMap(community -&gt; Observable.from(community.houses))</div><div class="line">        .filter(house -&gt; house.price&gt;=<span class="number">5000000</span>).subscribeOn(Schedulers.io())</div><div class="line">        .observeOn(AndroidSchedulers.mainThread())</div><div class="line">        .subscribe(<span class="keyword">this</span>::addHouseInformationToScreen);</div></pre></td></tr></table></figure>
<p>简洁！有美感！这才是一个有情怀的程序员应该写出来的代码。</p>
<p>看完这篇文章大家应该能够理解RxJava为什么会越来越火了。它能极大的提高我们的开发效率和代码的可读性！当然了RxJava的学习曲线也是比较陡的，在后面的文章我会对主要的知识点做详细的介绍，敬请关注！</p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列1-简介/&quot;&gt;RxJava系列1(简介)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列2-基本概念及使用介绍/&quot;&gt;RxJava系列2(基本概念及使用介绍)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列3-转换操作符/&quot;&gt;RxJava系列3(转换操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列4-过滤操作符/&quot;&gt;RxJava系列4(过滤操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列5-组合操作符/&quot;&gt;RxJava系列5(组合操作符)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列6-从微观角度解读RxJava源码/&quot;&gt;RxJava系列6(从微观角度解读RxJava源码)&lt;/a&gt;   &lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://baronzhang.com/blog/RxJava/RxJava系列7-最佳实践/&quot;&gt;RxJava系列7(最佳实践)&lt;/a&gt;  &lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="RxJava" scheme="http://baronzhang.com/categories/RxJava/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="RxJava" scheme="http://baronzhang.com/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android WebView那些坑之上传文件</title>
    <link href="http://baronzhang.com//blog/Android/Android-WebView%E9%82%A3%E4%BA%9B%E5%9D%91%E4%B9%8B%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6/"/>
    <id>http://baronzhang.com//blog/Android/Android-WebView那些坑之上传文件/</id>
    <published>2017-02-05T16:16:41.000Z</published>
    <updated>2019-08-19T06:53:46.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>最近公司项目需要在<code>WebView</code>上调用手机系统相册来上传图片，开发过程中发现在很多机器上无法正常唤起系统相册来选择图片。</p>
<p>解决问题之前我们先来说说<code>WebView</code>上传文件的逻辑：当我们在Web页面上点击选择文件的控件(<code>&lt;input type=&quot;file&quot;&gt;</code>)时，会回调<code>WebChromeClient</code>下的<code>openFileChooser()</code>（5.0及以上系统回调<code>onShowFileChooser()</code>）。这个时候我们在<code>openFileChooser</code>方法中通过<code>Intent</code>打开系统相册或者支持该<code>Intent</code>的第三方应用来选择图片。like this：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback, String acceptType, String capture)</span> </span>&#123;</div><div class="line">	uploadMessage = valueCallback;</div><div class="line">   	openImageChooserActivity();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openImageChooserActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">    Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</div><div class="line">    i.addCategory(Intent.CATEGORY_OPENABLE);</div><div class="line">    i.setType(<span class="string">"image/*"</span>);</div><div class="line">    startActivityForResult(Intent.createChooser(i,</div><div class="line">    			<span class="string">"Image Chooser"</span>), FILE_CHOOSER_RESULT_CODE);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<a id="more"></a>
<p>最后我们在<code>onActivityResult()</code>中将选择的图片内容通过<code>ValueCallback</code>的<code>onReceiveValue</code>方法返回给<code>WebView</code>，然后通过js上传。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@Override</span></div><div class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line">    <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line">    <span class="keyword">if</span> (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;</div><div class="line">        Uri result = data == <span class="keyword">null</span> || resultCode != RESULT_OK ? <span class="keyword">null</span> : data.getData();</div><div class="line">        <span class="keyword">if</span> (uploadMessage != <span class="keyword">null</span>) &#123;</div><div class="line">            uploadMessage.onReceiveValue(result);</div><div class="line">            uploadMessage = <span class="keyword">null</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>PS:<code>ValueCallbacks</code>是<code>WebView</code>组件通过<code>openFileChooser()</code>或者<code>onShowFileChooser()</code>提供给我们的，它里面包含了一个或者一组<code>Uri</code>,然后我们在<code>onActivityResult()</code>里将<code>Uri</code>传给<code>ValueCallbacks</code>的<code>onReceiveValue()</code>方法，这样<code>WebView</code>就知道我们选择了什么文件。</p>
</blockquote>
<p>到这里你可能要问了，说了这么多还是没解释为什么在很多机型上无法唤起系统相册或者第三方app来选择图片啊？！这是因为为了最求完美的Google攻城狮们对<code>openFileChooser</code>做了多次修改，在5.0上更是将回调方法该为了<code>onShowFileChooser</code>。所以为了解决这一问题，兼容各个版本，我们需要对<code>openFileChooser()</code>进行重载，同时针对5.0及以上系统提供<code>onShowFileChooser()</code>方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line">webview.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;</div><div class="line"></div><div class="line">        <span class="comment">// For Android &lt; 3.0</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback)</span> </span>&#123;</div><div class="line">            ***</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// For Android  &gt;= 3.0</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback valueCallback, String acceptType)</span> </span>&#123;</div><div class="line">            ***</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//For Android  &gt;= 4.1</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback,</span></span></div><div class="line">        		String acceptType, String capture) &#123;</div><div class="line">            ***</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// For Android &gt;= 5.0</span></div><div class="line">        <span class="meta">@Override</span></div><div class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onShowFileChooser</span><span class="params">(WebView webView,</span></span></div><div class="line">        		ValueCallback&lt;Uri[]&gt; filePathCallback,</div><div class="line">        		WebChromeClient.FileChooserParams fileChooserParams) &#123;</div><div class="line">            ***</div><div class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>大家应该注意到<code>onShowFileChooser()</code>中的<code>ValueCallback</code>包含了一组<code>Uri(Uri[])</code>,所以针对5.0及以上系统，我们还需要对<code>onActivityResult()</code>做一点点处理。这里不做描述，最后我再贴上完整代码。</p>
<p>当处理完这些后你以为就万事大吉了？！当初我也这样天真，但当我们打好release包测试的时候却又发现没法选择图片了！！！真是坑了个爹啊！！！无奈去翻<code>WebChromeClient</code>的源码，发现<code>openFileChooser()</code>是系统API，我们的release包是开启了混淆的，所以在打包的时候混淆了<code>openFileChooser()</code>，这就导致无法回调<code>openFileChooser()</code>了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * Tell the client to open a file chooser.</div><div class="line"> * <span class="doctag">@param</span> uploadFile A ValueCallback to set the URI of the file to upload.</div><div class="line"> *      onReceiveValue must be called to wake up the thread.a</div><div class="line"> * <span class="doctag">@param</span> acceptType The value of the 'accept' attribute of the input tag</div><div class="line"> *         associated with this file picker.</div><div class="line"> * <span class="doctag">@param</span> capture The value of the 'capture' attribute of the input tag</div><div class="line"> *         associated with this file picker.</div><div class="line"> *</div><div class="line"> * <span class="doctag">@deprecated</span> Use &#123;<span class="doctag">@link</span> #showFileChooser&#125; instead.</div><div class="line"> * <span class="doctag">@hide</span> This method was not published in any SDK version.</div><div class="line"> */</div><div class="line"><span class="meta">@SystemApi</span></div><div class="line"><span class="meta">@Deprecated</span></div><div class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; uploadFile, String acceptType, String capture)</span> </span>&#123;</div><div class="line">    uploadFile.onReceiveValue(<span class="keyword">null</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>解决方案也很简单，直接不混淆<code>openFileChooser()</code>就好了。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">-keepclassmembers <span class="class"><span class="keyword">class</span> * <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">webkit</span>.<span class="title">WebChromeClient</span>&#123;</span></div><div class="line">		<span class="keyword">public</span> <span class="keyword">void</span> openFileChooser(...);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>支持关于上传文件的所有坑都填完了，最后附上完整源码：<br>(源码地址:<a href="https://github.com/BaronZ88/WebViewSample" target="_blank" rel="external">https://github.com/BaronZ88/WebViewSample</a>)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> ValueCallback&lt;Uri&gt; uploadMessage;</div><div class="line">    <span class="keyword">private</span> ValueCallback&lt;Uri[]&gt; uploadMessageAboveL;</div><div class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> FILE_CHOOSER_RESULT_CODE = <span class="number">10000</span>;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</div><div class="line">        setContentView(R.layout.activity_main);</div><div class="line"></div><div class="line">        WebView webview = (WebView) findViewById(R.id.web_view);</div><div class="line">        <span class="keyword">assert</span> webview != <span class="keyword">null</span>;</div><div class="line">        WebSettings settings = webview.getSettings();</div><div class="line">        settings.setUseWideViewPort(<span class="keyword">true</span>);</div><div class="line">        settings.setLoadWithOverviewMode(<span class="keyword">true</span>);</div><div class="line">        settings.setJavaScriptEnabled(<span class="keyword">true</span>);</div><div class="line">        webview.setWebChromeClient(<span class="keyword">new</span> WebChromeClient() &#123;</div><div class="line"></div><div class="line">            <span class="comment">// For Android &lt; 3.0</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback)</span> </span>&#123;</div><div class="line">                uploadMessage = valueCallback;</div><div class="line">                openImageChooserActivity();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// For Android  &gt;= 3.0</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback valueCallback, String acceptType)</span> </span>&#123;</div><div class="line">                uploadMessage = valueCallback;</div><div class="line">                openImageChooserActivity();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">//For Android  &gt;= 4.1</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openFileChooser</span><span class="params">(ValueCallback&lt;Uri&gt; valueCallback, String acceptType, String capture)</span> </span>&#123;</div><div class="line">                uploadMessage = valueCallback;</div><div class="line">                openImageChooserActivity();</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// For Android &gt;= 5.0</span></div><div class="line">            <span class="meta">@Override</span></div><div class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onShowFileChooser</span><span class="params">(WebView webView, ValueCallback&lt;Uri[]&gt; filePathCallback, WebChromeClient.FileChooserParams fileChooserParams)</span> </span>&#123;</div><div class="line">                uploadMessageAboveL = filePathCallback;</div><div class="line">                openImageChooserActivity();</div><div class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">        String targetUrl = <span class="string">"file:///android_asset/up.html"</span>;</div><div class="line">        webview.loadUrl(targetUrl);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openImageChooserActivity</span><span class="params">()</span> </span>&#123;</div><div class="line">        Intent i = <span class="keyword">new</span> Intent(Intent.ACTION_GET_CONTENT);</div><div class="line">        i.addCategory(Intent.CATEGORY_OPENABLE);</div><div class="line">        i.setType(<span class="string">"image/*"</span>);</div><div class="line">        startActivityForResult(Intent.createChooser(i, <span class="string">"Image Chooser"</span>), FILE_CHOOSER_RESULT_CODE);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</div><div class="line">        <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</div><div class="line">        <span class="keyword">if</span> (requestCode == FILE_CHOOSER_RESULT_CODE) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == uploadMessage &amp;&amp; <span class="keyword">null</span> == uploadMessageAboveL) <span class="keyword">return</span>;</div><div class="line">            Uri result = data == <span class="keyword">null</span> || resultCode != RESULT_OK ? <span class="keyword">null</span> : data.getData();</div><div class="line">            <span class="keyword">if</span> (uploadMessageAboveL != <span class="keyword">null</span>) &#123;</div><div class="line">                onActivityResultAboveL(requestCode, resultCode, data);</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (uploadMessage != <span class="keyword">null</span>) &#123;</div><div class="line">                uploadMessage.onReceiveValue(result);</div><div class="line">                uploadMessage = <span class="keyword">null</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@TargetApi</span>(Build.VERSION_CODES.LOLLIPOP)</div><div class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onActivityResultAboveL</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent intent)</span> </span>&#123;</div><div class="line">        <span class="keyword">if</span> (requestCode != FILE_CHOOSER_RESULT_CODE || uploadMessageAboveL == <span class="keyword">null</span>)</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        Uri[] results = <span class="keyword">null</span>;</div><div class="line">        <span class="keyword">if</span> (resultCode == Activity.RESULT_OK) &#123;</div><div class="line">            <span class="keyword">if</span> (intent != <span class="keyword">null</span>) &#123;</div><div class="line">                String dataString = intent.getDataString();</div><div class="line">                ClipData clipData = intent.getClipData();</div><div class="line">                <span class="keyword">if</span> (clipData != <span class="keyword">null</span>) &#123;</div><div class="line">                    results = <span class="keyword">new</span> Uri[clipData.getItemCount()];</div><div class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; clipData.getItemCount(); i++) &#123;</div><div class="line">                        ClipData.Item item = clipData.getItemAt(i);</div><div class="line">                        results[i] = item.getUri();</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">                <span class="keyword">if</span> (dataString != <span class="keyword">null</span>)</div><div class="line">                    results = <span class="keyword">new</span> Uri[]&#123;Uri.parse(dataString)&#125;;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        uploadMessageAboveL.onReceiveValue(results);</div><div class="line">        uploadMessageAboveL = <span class="keyword">null</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>源码地址:<a href="https://github.com/BaronZ88/WebViewSample" target="_blank" rel="external">https://github.com/BaronZ88/WebViewSample</a></p>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最近公司项目需要在&lt;code&gt;WebView&lt;/code&gt;上调用手机系统相册来上传图片，开发过程中发现在很多机器上无法正常唤起系统相册来选择图片。&lt;/p&gt;
&lt;p&gt;解决问题之前我们先来说说&lt;code&gt;WebView&lt;/code&gt;上传文件的逻辑：当我们在Web页面上点击选择文件的控件(&lt;code&gt;&amp;lt;input type=&amp;quot;file&amp;quot;&amp;gt;&lt;/code&gt;)时，会回调&lt;code&gt;WebChromeClient&lt;/code&gt;下的&lt;code&gt;openFileChooser()&lt;/code&gt;（5.0及以上系统回调&lt;code&gt;onShowFileChooser()&lt;/code&gt;）。这个时候我们在&lt;code&gt;openFileChooser&lt;/code&gt;方法中通过&lt;code&gt;Intent&lt;/code&gt;打开系统相册或者支持该&lt;code&gt;Intent&lt;/code&gt;的第三方应用来选择图片。like this：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;4&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;5&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;6&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;7&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;8&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;9&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;10&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;11&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;12&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openFileChooser&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ValueCallback&amp;lt;Uri&amp;gt; valueCallback, String acceptType, String capture)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	uploadMessage = valueCallback;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;   	openImageChooserActivity();&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;openImageChooserActivity&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    Intent i = &lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Intent(Intent.ACTION_GET_CONTENT);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i.addCategory(Intent.CATEGORY_OPENABLE);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    i.setType(&lt;span class=&quot;string&quot;&gt;&quot;image/*&quot;&lt;/span&gt;);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    startActivityForResult(Intent.createChooser(i,&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;    			&lt;span class=&quot;string&quot;&gt;&quot;Image Chooser&quot;&lt;/span&gt;), FILE_CHOOSER_RESULT_CODE);&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Android" scheme="http://baronzhang.com/categories/Android/"/>
    
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
      <category term="WebView" scheme="http://baronzhang.com/tags/WebView/"/>
    
  </entry>
  
  <entry>
    <title>观察者模式(ObserverPattern)</title>
    <link href="http://baronzhang.com//blog/DesignPatterns/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-ObserverPattern/"/>
    <id>http://baronzhang.com//blog/DesignPatterns/观察者模式-ObserverPattern/</id>
    <published>2017-02-05T16:16:14.000Z</published>
    <updated>2019-08-19T06:53:46.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>我们接到一个来自气象局的需求：气象局需要我们构建一套系统，这系统有两个公告牌，分别用于显示当前的实时天气和未来几天的天气预报。当气象局发布新的天气数据（WeatherData）后，两个公告牌上显示的天气数据必须实时更新。气象局同时要求我们保证程序拥有足够的可扩展性，因为后期随时可能要新增新的公告牌。</p>
<a id="more"></a>
<h2 id="概况"><a href="#概况" class="headerlink" title="概况"></a>概况</h2><p>这套系统中主要包括三个部分：气象站（获取天气数据的物理设备）、WeatherData（追踪来自气象站的数据，并更新公告牌）、公告牌（用于展示天气数据）</p>
<p><img src="http://resources.baronzhang.com/DesignPatterns/ObserverPattern/WeatherStation.png" alt="WeatherStation"></p>
<p>WeatherData知道如何跟气象站联系，以获得天气数据。当天气数据有更新时，WeatherData会更新两个公告牌用于展示新的天气数据。</p>
<h2 id="错误示范"><a href="#错误示范" class="headerlink" title="错误示范"></a>错误示范</h2><p>我们现来看看隔壁老王的实现思路：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">//实例变量声明</span></div><div class="line">    ...</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</div><div class="line"></div><div class="line">        <span class="keyword">float</span> temperature = getTemperature();</div><div class="line">        <span class="keyword">float</span> humidity = getHumidity();</div><div class="line">        <span class="keyword">float</span> pressure = getPressure();</div><div class="line">        List&lt;Float&gt; forecastTemperatures = getForecastTemperatures();</div><div class="line"></div><div class="line">        <span class="comment">//更新公告牌</span></div><div class="line">        currentConditionsDisplay.update(temperature, humidity, pressure);</div><div class="line">        forecastDisplay.update(forecastTemperatures);</div><div class="line">    &#125;</div><div class="line">    ...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这段代码是典型的针对实现编程，这会导致我们以后增加或删除公告牌时必须修改程序。我们现在来看看观察者模式，然后再回来看看如何将观察者模式应用到这个程序。</p>
<h2 id="观察者模式介绍"><a href="#观察者模式介绍" class="headerlink" title="观察者模式介绍"></a>观察者模式介绍</h2><p>观察者模式面向的需求是：A对象（观察者）对B对象（被观察者）的某种变化高度敏感，需要在B变化的一瞬间做出反应。举个例子，新闻里喜闻乐见的警察抓小偷，警察需要在小偷伸手作案的时候实施抓捕。在这个例子里，警察是观察者、小偷是被观察者，警察需要时刻盯着小偷的一举一动，才能保证不会错过任何瞬间。程序里的观察者和这种真正的【观察】略有不同，观察者不需要时刻盯着被观察者（例如A不需要每隔1ms就检查一次B的状态），二是采用<strong>注册</strong>(<em>Register</em>)或者成为<strong>订阅</strong>(<em>Subscribe</em>)的方式告诉被观察者：我需要你的某某状态，你要在它变化时通知我。采取这样被动的观察方式，既省去了反复检索状态的资源消耗，也能够得到最高的反馈速度。</p>
<p>观察者模式通常基于<strong>Subject</strong>和<strong>Observer</strong>接口类来设计，下面是是类图：<br><img src="http://resources.baronzhang.com/DesignPatterns/ObserverPattern/Observer.png" alt="Observer"></p>
<h2 id="观察者模式的应用"><a href="#观察者模式的应用" class="headerlink" title="观察者模式的应用"></a>观察者模式的应用</h2><p>结合上面的类图，我们现在将观察者模式应用到WeatherData项目中来。于是有了下面这张类图：<br><img src="http://resources.baronzhang.com/DesignPatterns/ObserverPattern/ObserverForWeatherStation.png" alt="ObserverForWeatherStation"></p>
<p><strong>主题接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"> * 主题（发布者、被观察者）</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 注册观察者</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 移除观察者</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</div><div class="line"></div><div class="line">    <span class="comment">/**</span></div><div class="line">     * 通知观察者</div><div class="line">     */</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>观察者接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"> * 观察者</div><div class="line"> */</div><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>公告牌用于显示的公共接口</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DisplayElement</span> </span>&#123;</div><div class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>下面我们再来看看WeatherData是如何实现的</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeatherData</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;<span class="comment">//温度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;<span class="comment">//湿度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;<span class="comment">//气压</span></div><div class="line">    <span class="keyword">private</span> List&lt;Float&gt; forecastTemperatures;<span class="comment">//未来几天的温度</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WeatherData</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observers.add(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.observers.remove(observer);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">for</span> (Observer observer : observers) &#123;</div><div class="line">            observer.update();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">measurementsChanged</span><span class="params">()</span> </span>&#123;</div><div class="line">        notifyObservers();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMeasurements</span><span class="params">(<span class="keyword">float</span> temperature, <span class="keyword">float</span> humidity,</span></span></div><div class="line">    <span class="keyword">float</span> pressure, List&lt;Float&gt; forecastTemperatures) &#123;</div><div class="line">        <span class="keyword">this</span>.temperature = temperature;</div><div class="line">        <span class="keyword">this</span>.humidity = humidity;</div><div class="line">        <span class="keyword">this</span>.pressure = pressure;</div><div class="line">        <span class="keyword">this</span>.forecastTemperatures = forecastTemperatures;</div><div class="line">        measurementsChanged();</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getTemperature</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> temperature;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getHumidity</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> humidity;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getPressure</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> pressure;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> List&lt;Float&gt; <span class="title">getForecastTemperatures</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">return</span> forecastTemperatures;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>显示当前天气的公告牌CurrentConditionsDisplay</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CurrentConditionsDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> WeatherData weatherData;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> temperature;<span class="comment">//温度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> humidity;<span class="comment">//湿度</span></div><div class="line">    <span class="keyword">private</span> <span class="keyword">float</span> pressure;<span class="comment">//气压</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CurrentConditionsDisplay</span><span class="params">(WeatherData weatherData)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.weatherData = weatherData;</div><div class="line">        <span class="keyword">this</span>.weatherData.registerObserver(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"当前温度为："</span> + <span class="keyword">this</span>.temperature + <span class="string">"℃"</span>);</div><div class="line">        System.out.println(<span class="string">"当前湿度为："</span> + <span class="keyword">this</span>.humidity);</div><div class="line">        System.out.println(<span class="string">"当前气压为："</span> + <span class="keyword">this</span>.pressure);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.temperature = <span class="keyword">this</span>.weatherData.getTemperature();</div><div class="line">        <span class="keyword">this</span>.humidity = <span class="keyword">this</span>.weatherData.getHumidity();</div><div class="line">        <span class="keyword">this</span>.pressure = <span class="keyword">this</span>.weatherData.getPressure();</div><div class="line">        display();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>显示未来几天天气的公告牌ForecastDisplay</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ForecastDisplay</span> <span class="keyword">implements</span> <span class="title">Observer</span>, <span class="title">DisplayElement</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> WeatherData weatherData;</div><div class="line"></div><div class="line">    <span class="keyword">private</span> List&lt;Float&gt; forecastTemperatures;<span class="comment">//未来几天的温度</span></div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ForecastDisplay</span><span class="params">(WeatherData weatherData)</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.weatherData = weatherData;</div><div class="line">        <span class="keyword">this</span>.weatherData.registerObserver(<span class="keyword">this</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</div><div class="line">        System.out.println(<span class="string">"未来几天的气温"</span>);</div><div class="line">        <span class="keyword">int</span> count = forecastTemperatures.size();</div><div class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</div><div class="line">            System.out.println(<span class="string">"第"</span> + i + <span class="string">"天:"</span> + forecastTemperatures.get(i) + <span class="string">"℃"</span>);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">this</span>.forecastTemperatures = <span class="keyword">this</span>.weatherData.getForecastTemperatures();</div><div class="line">        display();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>到这里，我们整个气象局的WeatherData应用就改造完成了。两个公告牌<code>CurrentConditionsDisplay</code>和<code>ForecastDisplay</code>实现了<code>Observer</code>和<code>DisplayElement</code>接口，在他们的构造方法中会调用<code>WeatherData</code>的<code>registerObserver</code>方法将自己注册成观察者，这样被观察者<code>WeatherData</code>就会持有观察者的应用，并将它们保存到一个集合中。当被观察者<code>`WeatherData</code>状态发送变化时就会遍历这个集合，循环调用观察者<code>公告牌</code>更新数据的方法。后面如果我们需要增加或者删除公告牌就只需要新增或者删除实现了<code>Observer</code>和<code>DisplayElement</code>接口的公告牌就好了。</p>
<p>观察者模式将观察者和主题（被观察者）彻底解耦，主题只知道观察者实现了某一接口（也就是Observer接口）。并不需要观察者的具体类是谁、做了些什么或者其他任何细节。任何时候我们都可以增加新的观察者。因为主题唯一依赖的东西是一个实现了<code>Observer</code>接口的对象列表。</p>
<p>好了，我们测试下利用观察者模式重构后的程序：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverPatternTest</span> </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</div><div class="line"></div><div class="line">        WeatherData weatherData = <span class="keyword">new</span> WeatherData();</div><div class="line">        CurrentConditionsDisplay currentConditionsDisplay = <span class="keyword">new</span> CurrentConditionsDisplay(weatherData);</div><div class="line">        ForecastDisplay forecastDisplay = <span class="keyword">new</span> ForecastDisplay(weatherData);</div><div class="line"></div><div class="line">        List&lt;Float&gt; forecastTemperatures = <span class="keyword">new</span> ArrayList&lt;Float&gt;();</div><div class="line">        forecastTemperatures.add(<span class="number">22f</span>);</div><div class="line">        forecastTemperatures.add(-<span class="number">1f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">9f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">23f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">27f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">30f</span>);</div><div class="line">        forecastTemperatures.add(<span class="number">10f</span>);</div><div class="line">        weatherData.setMeasurements(<span class="number">22f</span>, <span class="number">0.8f</span>, <span class="number">1.2f</span>, forecastTemperatures);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出结果：</p>
<pre><code>当前温度为：22.0℃
当前湿度为：0.8
当前气压为：1.2
未来几天的气温
第0天:22.0℃
第1天:-1.0℃
第2天:9.0℃
第3天:23.0℃
第4天:27.0℃
第5天:30.0℃
第6天:10.0℃
</code></pre><blockquote>
<p>源码地址：<a href="https://github.com/BaronZ88/DesignPatterns/tree/master/src/com/baron/patterns/observer" target="_blank" rel="external">https://github.com/BaronZ88/DesignPatterns/tree/master/src/com/baron/patterns/observer</a></p>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;场景&quot;&gt;&lt;a href=&quot;#场景&quot; class=&quot;headerlink&quot; title=&quot;场景&quot;&gt;&lt;/a&gt;场景&lt;/h2&gt;&lt;p&gt;我们接到一个来自气象局的需求：气象局需要我们构建一套系统，这系统有两个公告牌，分别用于显示当前的实时天气和未来几天的天气预报。当气象局发布新的天气数据（WeatherData）后，两个公告牌上显示的天气数据必须实时更新。气象局同时要求我们保证程序拥有足够的可扩展性，因为后期随时可能要新增新的公告牌。&lt;/p&gt;
    
    </summary>
    
      <category term="DesignPatterns" scheme="http://baronzhang.com/categories/DesignPatterns/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
      <category term="Design Pattern" scheme="http://baronzhang.com/tags/Design-Pattern/"/>
    
  </entry>
  
  <entry>
    <title>在Android项目中使用Java8</title>
    <link href="http://baronzhang.com//blog/Java/%E5%9C%A8Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E4%BD%BF%E7%94%A8Java8/"/>
    <id>http://baronzhang.com//blog/Java/在Android项目中使用Java8/</id>
    <published>2017-02-05T15:37:48.000Z</published>
    <updated>2019-08-19T06:53:46.656Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在过去的文章中我介绍过Java8的一些新特性，包括：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/20540175" target="_blank" rel="external">Java8新特性第1章(Lambda表达式)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20540188" target="_blank" rel="external">Java8新特性第2章(接口默认方法)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/20540202" target="_blank" rel="external">Java8新特性第3章(Stream API)</a></li>
</ol>
<p>之前由于Android平台不支持Java8，如果我们想在Android项目中使用Lambda表达式、Stream API等Java8中的新特性就必须使用Retrolambda、Lightweight-Stream-API等第三方开源库来实现。现在Google爸爸终于让Android平台支持Java8了，这篇文章中便来和大家聊聊如何在Android项目中配置使用Java8。</p>
<p>遗憾的是目前Android平台仅支持Java8的部分新特性，当我们在开发面向Android N及以上版本的应用时(即minSdkVersion&gt;=24)，可以使用如下新特性：</p>
<a id="more"></a>
<ul>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="external">Lambda表达式(Lambda Expressions)</a>（也可以在minSdkVersion&lt;24的情况下使用）</li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="external">方法引用(Method References)</a>（也可以在minSdkVersion&lt;24的情况下使用）</li>
<li><a href="http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html" target="_blank" rel="external">Stream API(Streams)</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="external">接口默认方法(Default Methods)</a></li>
<li><a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="external">重复注解(Repeating Annotations)</a></li>
</ul>
<p>简单的说就是现在你的项目要想使用Stream API、接口默认方法和重复注解就要求你的minSdkVersion&gt;=24，而Lambda表达式和方法引用则对minSdkVersion无要求。关于这些新特的使用及分析可以看看我之前的文章。</p>
<h2 id="Jack-Java-Android-Compiler-Kit"><a href="#Jack-Java-Android-Compiler-Kit" class="headerlink" title="Jack(Java Android Compiler Kit)"></a>Jack(Java Android Compiler Kit)</h2><p>要想在Android项目中使用Java8的新特性，需要将你的Android Studio升级到2.1及以上版本，并采用新的Jack(Java Android Compiler Kit)编译。新的 Android 工具链将 Java 源语言编译成 Android 可读取的 Dalvik 可执行文件字节码，且有其自己的 .jack 库格式，在一个工具中提供了大多数工具链功能：重新打包、压缩、模糊化以及 Dalvik 可执行文件分包。</p>
<p>以下是构建 Android Dalvik 可执行文件可用的两种工具链的对比：</p>
<ul>
<li>旧版 javac 工具链：  <font color="ff0000"> <code>javac (.java --&gt; .class) --&gt; dx (.class --&gt; .dex)</code> </font></li>
<li>新版 Jack 工具链：  <font color="ff0000"> <code>Jack (.java --&gt; .jack --&gt; .dex)</code> </font>

</li>
</ul>
<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>为了在项目中使用Java8，我们还需要项目module中的gradle.build文件中加入如下代码：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">android &#123;</div><div class="line"></div><div class="line">  compileSdkVersion <span class="number">24</span></div><div class="line">  buildToolsVersion <span class="string">"24.0.3"</span></div><div class="line"></div><div class="line">  defaultConfig &#123;</div><div class="line"></div><div class="line">    applicationId <span class="string">"me.baron.hellojava8"</span></div><div class="line">    minSdkVersion <span class="number">24</span></div><div class="line">    targetSdkVersion <span class="number">24</span></div><div class="line">    versionCode <span class="number">1</span></div><div class="line">    versionName <span class="string">"1.0"</span></div><div class="line"></div><div class="line">    jackOptions &#123;</div><div class="line">      enabled <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  compileOptions &#123;</div><div class="line">    sourceCompatibility JavaVersion.VERSION_1_8</div><div class="line">    targetCompatibility JavaVersion.VERSION_1_8</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>进行上述配置后大家就可以在Android项目中尽情的探索使用Java8的新特性了。比如之前我们实现button的点击事件时需要这这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</div><div class="line">    <span class="meta">@Override</span></div><div class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</div><div class="line">		v.setText(<span class="string">"lalala"</span>);</div><div class="line">   	&#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>现在我们便可以使用Java8的Lambda表达式来实现了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">button.setOnClickListener(v -&gt; v.setText(<span class="string">"lalala"</span>));</div></pre></td></tr></table></figure>
<p>如果你项目的minSdkVersion&gt;=24，我们还可以使用Stream API。比方说有一个形状集合shapes，现在我们想把所有蓝色的形状提取到新的List里。通过Stream API则可以很轻易的办到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Shape&gt; blue = shapes.stream()</div><div class="line">	.filter(s -&gt; s.getColor() == BLUE)</div><div class="line">	.collect(Collectors.toList());</div></pre></td></tr></table></figure>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java8的新特性并不是本文的重点，对此有兴趣的同学可以去翻看我之前的文章。当前Jack编译器还有诸多限制，比如在使用新的Jack工具链时会禁用Instant Run以及前面提到的新特性对我们的最低支持版本和编译版本有要求等等(我猜想Jack对Buck、Layoutcast、Freeline等编译方案也会有影响，没做过验证，有了解的同学可以在评论区留言和大家交流下)；总之要想在Android项目中愉快的使用Java8全部的新特性还需时日。期待Google爸爸尽快优化吧！</p>
<p>参考资料：</p>
<ul>
<li><a href="https://developer.android.com/guide/platform/j8-jack.html" target="_blank" rel="external">https://developer.android.com/guide/platform/j8-jack.html</a></li>
<li><a href="https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad" target="_blank" rel="external">https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad</a></li>
</ul>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在过去的文章中我介绍过Java8的一些新特性，包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20540175&quot;&gt;Java8新特性第1章(Lambda表达式)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20540188&quot;&gt;Java8新特性第2章(接口默认方法)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/20540202&quot;&gt;Java8新特性第3章(Stream API)&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之前由于Android平台不支持Java8，如果我们想在Android项目中使用Lambda表达式、Stream API等Java8中的新特性就必须使用Retrolambda、Lightweight-Stream-API等第三方开源库来实现。现在Google爸爸终于让Android平台支持Java8了，这篇文章中便来和大家聊聊如何在Android项目中配置使用Java8。&lt;/p&gt;
&lt;p&gt;遗憾的是目前Android平台仅支持Java8的部分新特性，当我们在开发面向Android N及以上版本的应用时(即minSdkVersion&amp;gt;=24)，可以使用如下新特性：&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://baronzhang.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
      <category term="Android" scheme="http://baronzhang.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性第3章(Stream API)</title>
    <link href="http://baronzhang.com//blog/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%AC3%E7%AB%A0-Stream-API/"/>
    <id>http://baronzhang.com//blog/Java/Java8新特性第3章-Stream-API/</id>
    <published>2017-02-05T15:37:32.000Z</published>
    <updated>2019-08-19T06:53:46.657Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>Stream作为Java8的新特性之一，他与Java IO包中的InputStream和OutputStream完全不是一个概念。Java8中的Stream是对集合功能的一种增强，主要用于对集合对象进行各种非常便利高效的聚合和大批量数据的操作。结合Lambda表达式可以极大的提高开发效率和代码可读性。</p>
<p>假设我们需要把一个集合中的所有形状设置成红色，那么我们可以这样写</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (Shape shape : shapes)&#123;</div><div class="line">	shape.setColor(RED)</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>如果使用Java8扩展后的集合框架则可以这样写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">shapes.foreach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure>
<a id="more"></a>
<p><strong>第一种</strong>写法我们叫外部迭代，for-each调用<code>shapes</code>的<code>iterator()</code>依次遍历集合中的元素。这种外部迭代有一些问题：</p>
<ul>
<li>for循环是串行的，而且必须按照集合中元素的顺序依次进行；</li>
<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路求值以及惰性求值改善性能。<blockquote>
<p>上面这两个问题我们会在后面的文章中逐步解答。</p>
</blockquote>
</li>
</ul>
<p><strong>第二种</strong>写法我们叫内部迭代，两段代码虽然看起来只是语法上的区别，但实际上他们内部的区别其实非常大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>
<p>外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历），而内部迭代只负责做什么，而把怎么做留给类库。这样代码会变得更加清晰，而集合类库则可以在内部进行各种优化。</p>
<h2 id="一、什么是Stream"><a href="#一、什么是Stream" class="headerlink" title="一、什么是Stream"></a>一、什么是Stream</h2><p>Stream不是集合元素，它也不是数据结构、不能保存数据，它更像一个更高级的<code>Interator</code>。Stream提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。流的操作可以被组合成流水线（Pipeline）。拿前面的例子来说，如果我只想把蓝色改成红色：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">shapes.stream()</div><div class="line">      .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">      .forEach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure>
<p>在<code>Collection</code>上调用<code>stream()</code>会生成该集合元素的流，接下来<code>filter()</code>操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被<code>forEach</code>操作设为红色。</p>
<p>如果我们想把蓝色的形状提取到新的List里，则可以：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">List&lt;Shape&gt; blue = shapes.stream()</div><div class="line">						  .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">						  .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<p><code>collect()</code>操作会把其接收的元素聚集到一起（这里是List），<code>collect()</code>方法的参数则被用来指定如何进行聚集操作。在这里我们使用<code>toList()</code>以把元素输出到List中。</p>
<p>如果每个形状都被保存在<code>Box</code>里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">Set&lt;Box&gt; hasBlueShape = shapes.stream()</div><div class="line">        .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">        .map(s -&gt; s.getContainingBox())</div><div class="line">        .collect(Collectors.toSet());</div></pre></td></tr></table></figure>
<p><code>map()</code>操作符通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>
<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></td><td class="code"><pre><div class="line">int sum = shapes.stream()</div><div class="line">        .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">        .mapToInt(s -&gt; s.getWeight())</div><div class="line">        .sum();</div><div class="line">```            </div><div class="line"></div><div class="line"></div><div class="line">## 二、Stream vs Collection</div><div class="line"></div><div class="line">流（Stream）和集合（Collection）的区别：</div><div class="line"></div><div class="line">* Collection主要用来对元素进行管理和访问；</div><div class="line">* Stream并不支持对其元素进行直接操作和直接访问，而只支持通过声明式操作在其之上进行运算后得到结果；</div><div class="line">* Stream不存储值</div><div class="line">* 对Stream的操作会产生一个结果，但是Stream并不会改变数据源；</div><div class="line">* 大多数Stream的操作(filter,map,sort等)都是以惰性的方式实现的。这使得我们可以使用一次遍历完成整个流水线操作,并可以用短路操作提供更高效的实现。</div><div class="line"></div><div class="line"></div><div class="line">## 三、惰性求值 vs 急性求值</div><div class="line"></div><div class="line">`filter()`和`map()`这样的操作既可以被急性求值（以`filter()`为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被惰性求值（用`Stream`代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）</div><div class="line"></div><div class="line">对于`filter()`和`map()`这样的操作符，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像`sum()`这样生成值的操作和`forEach()`这样产生副作用的操作都是__天然急性求值__，因为它们必须要产生具体的结果。</div><div class="line"></div><div class="line">我们拿下面这段代码举例：</div><div class="line"></div><div class="line">```java</div><div class="line">int sum = shapes.stream()</div><div class="line">        .filter(s -&gt; s.getColor() == BLUE)</div><div class="line">        .mapToInt(s -&gt; s.getWeight())</div><div class="line">        .sum();</div><div class="line">```                </div><div class="line"></div><div class="line">这里的`filter()`和`map()`都是惰性的，这就意味着在调用`sum()`之前不会从数据源中提取任何元素。在`sum()`操作之后才会把`filter()`、`map()`和`sum()`放在对数据源一次遍历中。这样可以大大减少维持中间结果所带来的开销。</div><div class="line"></div><div class="line"></div><div class="line">## 四、举个栗子🌰</div><div class="line"></div><div class="line">前面长篇大论的介绍概念实在太枯燥，为了方便大家理解我们用Streams API来实现一个具体的业务场景。</div><div class="line"></div><div class="line">假设我们有一个房源库项目，这个房源库中有一系列的小区，每个小区都有小区名和房源列表，每套房子又有价格、面积等属性。现在我们需要筛选出含有100平米以上房源的小区，并按照小区名排序。</div><div class="line"></div><div class="line">我们先来看看不用Streams API如何实现：</div><div class="line"></div><div class="line"></div><div class="line">```java</div><div class="line">List&lt;Community&gt; result = new ArrayList&lt;&gt;();</div><div class="line">for (Community community : communities) &#123;</div><div class="line">        for (House house : community.houses) &#123;</div><div class="line">            if (house.area &gt; 100) &#123;</div><div class="line">                result.add(community);</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    Collections.sort(result, new Comparator&lt;Community&gt;() &#123;</div><div class="line">        @Override</div><div class="line">        public int compare(Community c1, Community c2) &#123;</div><div class="line">            return c1.name.compareTo(c2.name);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">    return result;</div></pre></td></tr></table></figure>
<p>如果使用Streams API:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">return</span> communities.stream()</div><div class="line">          .filter(c -&gt; c.houses.stream().anyMatch(h -&gt; h.area&gt;<span class="number">100</span>))</div><div class="line">          .sorted(Comparator.comparing(c -&gt; c.name))</div><div class="line">          .collect(Collectors.toList());</div></pre></td></tr></table></figure>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Stream作为Java8的新特性之一，他与Java IO包中的InputStream和OutputStream完全不是一个概念。Java8中的Stream是对集合功能的一种增强，主要用于对集合对象进行各种非常便利高效的聚合和大批量数据的操作。结合Lambda表达式可以极大的提高开发效率和代码可读性。&lt;/p&gt;
&lt;p&gt;假设我们需要把一个集合中的所有形状设置成红色，那么我们可以这样写&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;2&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;3&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (Shape shape : shapes)&amp;#123;&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;	shape.setColor(RED)&lt;/div&gt;&lt;div class=&quot;line&quot;&gt;&amp;#125;&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果使用Java8扩展后的集合框架则可以这样写：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;1&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;div class=&quot;line&quot;&gt;shapes.foreach(s -&amp;gt; s.setColor(RED));&lt;/div&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="Java" scheme="http://baronzhang.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Java8新特性第2章(接口默认方法)</title>
    <link href="http://baronzhang.com//blog/Java/Java8%E6%96%B0%E7%89%B9%E6%80%A7%E7%AC%AC2%E7%AB%A0-%E6%8E%A5%E5%8F%A3%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95/"/>
    <id>http://baronzhang.com//blog/Java/Java8新特性第2章-接口默认方法/</id>
    <published>2017-02-05T15:37:11.000Z</published>
    <updated>2019-08-19T06:53:46.654Z</updated>
    
    <content type="html"><![CDATA[<blockquote>
<p>微信公众号：<strong>BaronTalk</strong></p>
</blockquote>
<p>在Java中一个接口一旦发布就已经被定型，除非我们能够一次性的更新所有该接口的实现，否者在接口的添加新方法将会破坏现有接口的实现。默认方法就是为了解决这一问题的，这样接口在发布之后依然能够继续演化。</p>
<p>默认方法就是向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或者是默认的。默认方法拥有默认实现，接口实现类通过继承得到该默认实现。默认方法不是抽象的，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口单抽象方法的限制。</p>
<a id="more"></a>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</div><div class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"remove"</span>);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">void</span> <span class="title">forEachRemaining</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> E&gt; action)</span> </span>&#123;</div><div class="line">        Objects.requireNonNull(action);</div><div class="line">        <span class="keyword">while</span> (hasNext())</div><div class="line">            action.accept(next());</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>和其他方法一样，默认方法也可以被继承。</p>
<p>除了上面看到的默认方法，Java8中还允许我们在接口中定义静态方法。这使得我们可以从接口中直接调用它相关的辅助方法，而不是从其它的辅助类中调用（如Collections）。在做集合中元素比较的时候，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java8中我们可以直接把该静态方法定义在Comparator接口中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T, U extends Comparable&lt;? <span class="keyword">super</span> U&gt;&gt;</div><div class="line">    <span class="function">Comparator&lt;T&gt; <span class="title">comparing</span><span class="params">(Function&lt;T, U&gt; keyExtractor)</span> </span>&#123;</div><div class="line">    <span class="keyword">return</span> (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<blockquote>
<p>如果你喜欢我的文章，就关注下我的公众号 <strong>BaronTalk</strong> 、 <a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external"><strong>知乎专栏</strong></a> 或者在 <a href="https://github.com/BaronZ88" target="_blank" rel="external"><strong>GitHub</strong></a> 上添个 Star 吧！</p>
<ul>
<li>微信公众号：<strong>BaronTalk</strong></li>
<li>知乎专栏：<a href="https://zhuanlan.zhihu.com/baron" target="_blank" rel="external">https://zhuanlan.zhihu.com/baron</a>  </li>
<li>GitHub：<a href="https://github.com/BaronZ88" target="_blank" rel="external">https://github.com/BaronZ88</a></li>
<li>个人博客：<a href="http://baronzhang.com">http://baronzhang.com</a></li>
</ul>
</blockquote>
<p><img src="http://resources.baronzhang.com/blog/common/qrcode1.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;微信公众号：&lt;strong&gt;BaronTalk&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在Java中一个接口一旦发布就已经被定型，除非我们能够一次性的更新所有该接口的实现，否者在接口的添加新方法将会破坏现有接口的实现。默认方法就是为了解决这一问题的，这样接口在发布之后依然能够继续演化。&lt;/p&gt;
&lt;p&gt;默认方法就是向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或者是默认的。默认方法拥有默认实现，接口实现类通过继承得到该默认实现。默认方法不是抽象的，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口单抽象方法的限制。&lt;/p&gt;
    
    </summary>
    
      <category term="Java" scheme="http://baronzhang.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://baronzhang.com/tags/Java/"/>
    
  </entry>
  
</feed>
