{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1},{"_id":"themes/next/source/uploads/avatar.jpg","path":"uploads/avatar.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"002b51c28c95a45e7597acb4fd63fbfb1edce746","modified":1486348288000},{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1486234060000},{"_id":"themes/next/.DS_Store","hash":"7bfc5f7c6c08b3037255a42e740131ff5663f98a","modified":1486348288000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1486234060000},{"_id":"themes/next/.gitignore","hash":"5f09fca02e030b7676c1d312cd88ce8fbccf381c","modified":1486234060000},{"_id":"themes/next/.hound.yml","hash":"b76daa84c9ca3ad292c78412603370a367cc2bc3","modified":1486234060000},{"_id":"themes/next/.javascript_ignore","hash":"f9ea3c5395f8feb225a24e2c32baa79afda30c16","modified":1486234060000},{"_id":"themes/next/.jshintrc","hash":"9928f81bd822f6a8d67fdbc909b517178533bca9","modified":1486234060000},{"_id":"themes/next/README.en.md","hash":"3b0c7998cf17f9cf9e1a5bfcd65679a43a00c817","modified":1486234060000},{"_id":"themes/next/README.md","hash":"500b5606eb6a09c979d16128f8b00f4bf9bc95ac","modified":1486234060000},{"_id":"themes/next/_config.yml","hash":"03c7bdec9d4491bdea4dc4aa30193c361cca10e6","modified":1486281175000},{"_id":"themes/next/gulpfile.coffee","hash":"61ef0606a8134894d7ac796bc8d0fa4ba6a94483","modified":1486234060000},{"_id":"themes/next/bower.json","hash":"5abc236d9cc2512f5457ed57c1fba76669eb7399","modified":1486234060000},{"_id":"themes/next/package.json","hash":"877cb98025e59015532c4c9a04a33e2af4ad56f9","modified":1486234060000},{"_id":"source/_posts/2017-02-05-Java8新特性第1章-Lambda表达式.md","hash":"93b3a6425438957779e1c5e332267b52e37a5204","modified":1486310550000},{"_id":"source/_posts/2017-02-05-Java8新特性第2章-接口默认方法.md","hash":"75e17a54d6547fd062af5ae29e1bf92e19159440","modified":1486310559000},{"_id":"source/_posts/2017-02-05-在Android项目中使用Java8.md","hash":"6418babb69b26251954d7735410952fe8d4d11d6","modified":1486310866000},{"_id":"source/_posts/2017-02-05-Java8新特性第3章-Stream-API.md","hash":"0d276de2bb96fbe66277e05b55d66a7a9c251176","modified":1486310563000},{"_id":"source/_posts/2017-02-06-Android-WebView那些坑之上传文件.md","hash":"ce44192ad98efbbfc12759a4c0e67abfd8a6c190","modified":1486311401000},{"_id":"source/_posts/2017-02-06-RxJava系列1-简介.md","hash":"45a3cd477298c9ddde572878789f4248d561f29b","modified":1486317503000},{"_id":"source/_posts/2017-02-06-RxJava系列2-基本概念及使用介绍.md","hash":"7bee9a5e5f197d5bbde166300e54592c0db281ec","modified":1486352362000},{"_id":"source/_posts/2017-02-06-RxJava系列3-转换操作符.md","hash":"20caa1d16c95c37939ff54310853dcbe3d334095","modified":1486317523000},{"_id":"source/_posts/2017-02-06-RxJava系列4-过滤操作符.md","hash":"d866bee1cdff0b1f8c4c37ae2586bbfbdbf7f332","modified":1486317528000},{"_id":"source/_posts/2017-02-06-RxJava系列5-组合操作符.md","hash":"42095e987a0d9384b34854330145f9ac997f2212","modified":1486317533000},{"_id":"source/_posts/2017-02-06-RxJava系列7-最佳实践.md","hash":"d9a2011409ae7e18a9bfe939fe5da29af3ac095e","modified":1486352691000},{"_id":"source/_posts/2017-02-06-RxJava系列6-从微观角度解读RxJava源码.md","hash":"0142b9a50b34b75d9c3f1751918bd0dec667426f","modified":1486317537000},{"_id":"source/_posts/2017-02-06-RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例.md","hash":"e6ff47bcf3b62cda90987c5397f3adec512a9043","modified":1486317552000},{"_id":"source/_posts/2017-02-06-观察者模式-ObserverPattern.md","hash":"f4f009b04ef68345cf9c79ecf8e222b9e0e050da","modified":1486311374000},{"_id":"themes/next/.git/COMMIT_EDITMSG","hash":"f73ee080cfb5894aa897c6f45ab0d60954e69f93","modified":1486279718000},{"_id":"themes/next/.git/.DS_Store","hash":"06ca14b61dd87ab7b1269ddc9856a069ce398705","modified":1486348288000},{"_id":"themes/next/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1486234060000},{"_id":"themes/next/.git/config","hash":"bf7d1df65cf34d0f25a7184a58c37a09f72e4be7","modified":1486234060000},{"_id":"themes/next/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1486234044000},{"_id":"themes/next/.git/index","hash":"57aa3da1a25816c600fdfd47e6d67062bb3baef7","modified":1486279718000},{"_id":"themes/next/.git/packed-refs","hash":"12ca02d8374d9a441a6c8a6c9ed061432cb0a8c9","modified":1486234060000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5ab257af816986cd0e53f9527a92d5934ac70ae9","modified":1486234060000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"c2024ded82143807c28a299c5fe6b927ef3525ff","modified":1486234060000},{"_id":"themes/next/languages/de.yml","hash":"1fdea1f84b7f691f5b4dd4d2b43eeb27b10fa0c8","modified":1486234060000},{"_id":"themes/next/languages/fr-FR.yml","hash":"9fca01ef917d33ae2ae6bc04561ec6799dff5351","modified":1486234060000},{"_id":"themes/next/languages/en.yml","hash":"40057d6608e825d06e0864bac4dcd27ed88ada87","modified":1486234060000},{"_id":"themes/next/languages/default.yml","hash":"767470a80dc257e23e14c3a78e8c52a46c9d6209","modified":1486234060000},{"_id":"themes/next/languages/ko.yml","hash":"b6bc5d6b0c000deb44099b42d3aebb8c49dbfca9","modified":1486234060000},{"_id":"themes/next/languages/ja.yml","hash":"49f12149edcc1892b26a6207328cda64da20116d","modified":1486234060000},{"_id":"themes/next/languages/pt-BR.yml","hash":"7742ba4c0d682cbe1d38305332ebc928abd754b5","modified":1486234060000},{"_id":"themes/next/languages/id.yml","hash":"34396bef27c4ab9e9a3c5d3e3aa94b0e3b3a7b0d","modified":1486234060000},{"_id":"themes/next/languages/ru.yml","hash":"257d11e626cbe4b9b78785a764190b9278f95c28","modified":1486234060000},{"_id":"themes/next/languages/pt.yml","hash":"6b660b117314cad93f08757601df3adb04c68beb","modified":1486234060000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"f6c9fafa0f5f0050cd07ca2cf5e38fbae3e28145","modified":1486234060000},{"_id":"themes/next/languages/zh-hk.yml","hash":"34c84c6d04447a25bd5eac576922a13947c000e2","modified":1486234060000},{"_id":"themes/next/languages/zh-tw.yml","hash":"c97a5c41149de9b17f33439b0ecf0eff6fdae50e","modified":1486234060000},{"_id":"themes/next/layout/_layout.swig","hash":"2fa3c74066843a859fac77803324a1de51044da9","modified":1486281642000},{"_id":"themes/next/layout/archive.swig","hash":"b5b59d70fc1563f482fa07afd435752774ad5981","modified":1486234060000},{"_id":"themes/next/layout/category.swig","hash":"6422d196ceaff4220d54b8af770e7e957f3364ad","modified":1486234060000},{"_id":"themes/next/layout/index.swig","hash":"427d0b95b854e311ae363088ab39a393bf8fdc8b","modified":1486234060000},{"_id":"themes/next/layout/page.swig","hash":"3727fab9dadb967e9c2204edca787dc72264674a","modified":1486234060000},{"_id":"themes/next/scripts/merge-configs.js","hash":"0c56be2e85c694247cfa327ea6d627b99ca265e8","modified":1486234060000},{"_id":"themes/next/layout/schedule.swig","hash":"1f1cdc268f4ef773fd3ae693bbdf7d0b2f45c3a3","modified":1486234060000},{"_id":"themes/next/layout/post.swig","hash":"e2e512142961ddfe77eba29eaa88f4a2ee43ae18","modified":1486234060000},{"_id":"themes/next/layout/tag.swig","hash":"07cf49c49c39a14dfbe9ce8e7d7eea3d4d0a4911","modified":1486234060000},{"_id":"themes/next/source/.DS_Store","hash":"0958653add94c49b4f8b6335c71b56c300e97361","modified":1486348288000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1486234060000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1486234060000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1486234060000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486234060000},{"_id":"themes/next/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1486234044000},{"_id":"themes/next/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1486234044000},{"_id":"themes/next/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1486234044000},{"_id":"themes/next/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1486234044000},{"_id":"themes/next/.git/hooks/pre-commit.sample","hash":"36aed8976dcc08b5076844f0ec645b18bc37758f","modified":1486234044000},{"_id":"themes/next/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1486234044000},{"_id":"themes/next/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1486234044000},{"_id":"themes/next/.git/hooks/pre-rebase.sample","hash":"5885a56ab4fca8075a05a562d005e922cde9853b","modified":1486234044000},{"_id":"themes/next/.git/hooks/prepare-commit-msg.sample","hash":"2b6275eda365cad50d167fe3a387c9bc9fedd54f","modified":1486234044000},{"_id":"themes/next/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1486234044000},{"_id":"themes/next/.git/logs/HEAD","hash":"db5a8911f6029e4861ef8521482816d89e283875","modified":1486279718000},{"_id":"themes/next/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1486234044000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1486234060000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1486234060000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"14e785adeb0e671ba0ff9a553e6f0d8def6c670c","modified":1486234060000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"37e5b7c42ec17b9b6b786c5512bcc481a21c974e","modified":1486234060000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"78ccfc1dc915247c1fec3c86d742e0f4c2f6d99c","modified":1486234060000},{"_id":"themes/next/layout/_partials/duoshuo-hot-articles.swig","hash":"5d4638c46aef65bf32a01681495b62416ccc98db","modified":1486234060000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"7172c6053118b7c291a56a7860128a652ae66b83","modified":1486234060000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"5864f5567ba5efeabcf6ea355013c0b603ee07f2","modified":1486234060000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"43d8830bb19da4fc7a5773866be19fa066b62645","modified":1486234060000},{"_id":"themes/next/layout/_macro/post.swig","hash":"e6016def9b512188f4c2725399c9adc7bc41cdae","modified":1486234060000},{"_id":"themes/next/layout/_partials/head.swig","hash":"ca56f92e2fa82b03853869f5073ee1a5626a4796","modified":1486234060000},{"_id":"themes/next/layout/_partials/header.swig","hash":"adab5c3f7b173f1b45454787f39dde07aea03483","modified":1486234060000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"39d613e5a9f8389d4ea52d6082502af8e833b9f2","modified":1486234060000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"9e8e21d194ef44d271b1cca0bc1448c14d7edf4f","modified":1486234060000},{"_id":"themes/next/layout/_partials/search.swig","hash":"1431719d1dbba3f5ee385eebc46376d1a960b2d5","modified":1486234060000},{"_id":"themes/next/layout/_scripts/baidu-push.swig","hash":"c057b17f79e8261680fbae8dc4e81317a127c799","modified":1486234060000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"03aaebe9d50f6acb007ec38cc04acd1cfceb404d","modified":1486234060000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"766b2bdda29523ed6cd8d7aa197f996022f8fd94","modified":1486234060000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"4512867d80d9eddfc3a0f5fea3c456f33aa9d522","modified":1486234060000},{"_id":"themes/next/scripts/tags/button.js","hash":"62e6dbeb53d07627a048132c79630b45d9a8f2cc","modified":1486234060000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"535fc542781021c4326dec24d8495cbb1387634a","modified":1486234060000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"8eeb3fb89540299bdbb799edfdfdac3743b50596","modified":1486234060000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"49252824cd53184dc9b97b2f2d87ff28e1b3ef27","modified":1486234060000},{"_id":"themes/next/scripts/tags/note.js","hash":"6752925eedbdb939d8ec4d11bdfb75199f18dd70","modified":1486234060000},{"_id":"themes/next/source/css/.DS_Store","hash":"551915066f9968d86974208e847e228e75fc0ef5","modified":1486348288000},{"_id":"themes/next/source/css/main.styl","hash":"20702c48d6053c92c5bcdbc68e8d0ef1369848a0","modified":1486234060000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1486234060000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1486234060000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1486234060000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1486234060000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1486234060000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1486234060000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1486234060000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1486234060000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1486234060000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1486234060000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1486234060000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1486234060000},{"_id":"themes/next/source/js/.DS_Store","hash":"b98e0cac65b8182dd5709cd9a5f3d3f1a2bde433","modified":1486237728000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1486234060000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1486234060000},{"_id":"themes/next/source/lib/.DS_Store","hash":"272e7deb3af96860e123c739d6d1fdc731755672","modified":1486237728000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486234060000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486234060000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486234060000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486234060000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486234060000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1486234060000},{"_id":"themes/next/.git/objects/6c/dd9134ea0b20b557de708f9e689619b530cc85","hash":"ed53c1fad365f6f1e540ca9141fff8af202b0df7","modified":1486279714000},{"_id":"themes/next/.git/objects/3c/3288e7e141b50455eb75231d57fce83a1d5946","hash":"bd3a02e281809dddf8b70ff20804e7429c1d8bcb","modified":1486279718000},{"_id":"themes/next/.git/objects/5c/1c1e58ceee6dc8282186bb92743d0aa276c62b","hash":"eb7f6a25283fbf38758595e0e9a27ab589eed2e2","modified":1486279714000},{"_id":"themes/next/.git/objects/8c/6bdc30c0b22ecd4514d95542a26279811f2b13","hash":"a448382970990b12a9f11d2c92e1fa59a2947e6b","modified":1486279718000},{"_id":"themes/next/.git/objects/82/9d44a3a12473f55f12ccca574e85ae683fccbe","hash":"66fd48e8dd8a7cf374df7f999f468e6157c679ae","modified":1486279718000},{"_id":"themes/next/.git/objects/af/2ffcbbb499e389c7630eb43b57b39e433e0711","hash":"99584c75da430f279b60a54cef24d2c166d419ce","modified":1486279718000},{"_id":"themes/next/.git/objects/f0/a708e4aeaae85a56fc64ddc1a7491bf1b717c4","hash":"a6bc779edb1ed07c5356adbf513d8973cff22be8","modified":1486279718000},{"_id":"themes/next/.git/objects/b4/5760b66b17dfbee4010c41ede64ebfe083852c","hash":"83c833379110b8c9fb4bde55e2ba7e722243e5a6","modified":1486279718000},{"_id":"themes/next/layout/_components/algolia-search/assets.swig","hash":"28ff4ed6714c59124569ffcbd10f1173d53ca923","modified":1486234060000},{"_id":"themes/next/layout/_components/algolia-search/dom.swig","hash":"636f1181dd5887a70b4a08ca8f655d4e46635792","modified":1486234060000},{"_id":"themes/next/.git/refs/heads/master","hash":"ca3cd00a485c057f6c7d298acaf4ee26c1eaa323","modified":1486279718000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"7ce76358411184482bb0934e70037949dd0da8ca","modified":1486234060000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1486234060000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"959b7e04a96a5596056e4009b73b6489c117597e","modified":1486234060000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"eefe2388ff3d424694045eda21346989b123977c","modified":1486234060000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"ff5523d5dacaa77a55a24e50e6e6530c3b98bfad","modified":1486234060000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"23e23dc0f76ef3c631f24c65277adf7ea517b383","modified":1486234060000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"1f1107468aaf03f7d0dcd7eb2b653e2813a675b4","modified":1486234060000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"89c5a5240ecb223acfe1d12377df5562a943fd5d","modified":1486234060000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"63315fcf210799f894208c9f512737096df84962","modified":1486234060000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"069d1357c717572256e5cdee09574ebce529cbae","modified":1486234060000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a44acf9b0d0f44ef3dfc767376a95c984cc127de","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/analytics.swig","hash":"394d9fff7951287cc90f52acc2d4cbfd1bae079d","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/comments.swig","hash":"4abc01bc870e1d7a783cdbd26166edc782a6a4f4","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/lean-analytics.swig","hash":"92dc60821307fc9769bea9b2d60adaeb798342af","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/localsearch.swig","hash":"b460e27db3dcd4ab40b17d8926a5c4e624f293a9","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/mathjax.swig","hash":"6d25596d6a7c57700d37b607f8d9a62d89708683","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/tinysou.swig","hash":"cb3a5d36dbe1630bab84e03a52733a46df7c219b","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/schedule.swig","hash":"22369026c87fc23893c35a7f250b42f3bb1b60f1","modified":1486234060000},{"_id":"themes/next/source/css/_common/.DS_Store","hash":"9b3817ebbb9444e857c4e8baf64a67b56c20abd2","modified":1486237723000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1486281267000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"78a83c38f69a8747bb74e420e6c9eeef1ea76525","modified":1486234060000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"715d5b40dc52f319fe4bff0325beb874774d9bd9","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/.DS_Store","hash":"621696fdcc83c11e18ac8389fd2cd1252bd6922b","modified":1486237723000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"c8d35a6b9e3bff6d8fdb66de853065af9d37562d","modified":1486234060000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"fc185c6cec79593775d1c2440dbe2a71cfbe2e99","modified":1486234060000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"5c1f1410d68954844d02be1121c2133f3519a09a","modified":1486308800000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"c459aa6d607d8bcb747544e74f6ad0b8374aa3b1","modified":1486234060000},{"_id":"themes/next/source/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1486234060000},{"_id":"themes/next/source/js/src/.DS_Store","hash":"2c518cfdba029f84814e1eabf01ddab0b83575ab","modified":1486237723000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1486234060000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1486234060000},{"_id":"themes/next/source/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1486234060000},{"_id":"themes/next/source/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1486234060000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1486234060000},{"_id":"themes/next/source/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1486234060000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1486234060000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1486234060000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"cc40a9b11e52348e554c84e4a5c058056f6b7aeb","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/.DS_Store","hash":"229ef1a1559b790a61b51d90d1745691143f6025","modified":1486237723000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"2db21acfbd457452462f71cc4048a943ee61b8e0","modified":1486234060000},{"_id":"themes/next/source/lib/fastclick/.DS_Store","hash":"2831c7aca85cfdf19abb169f21c2c8ea8aad7b2d","modified":1486237723000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1486234060000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"93ebd5b35e632f714dcf1753e1f6db77ec74449b","modified":1486234060000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"1decd8e1adad2cd6db0ab50cf56de6035156f4ea","modified":1486234060000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"13379463c7463b4b96d13556b46faa4cc38d81e6","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/.DS_Store","hash":"b286257670c70e9ed7d4f3a71fb42b2a7bcb4478","modified":1486237723000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"c1072942459fa0880e8a33a1bd929176b62b4171","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1486234060000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"91745c2cc6c946c7275f952b2b0760b880cea69e","modified":1486234060000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"b7638afc93e9cd350d0783565ee9a7da6805ad8e","modified":1486234060000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1486234060000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4891864c24c28efecd81a6a8d3f261145190f901","modified":1486234060000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"895d50fa29759af7835256522e9dd7dac597765c","modified":1486234060000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"65bc85d12197e71c40a55c0cd7f6823995a05222","modified":1486234060000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1486234060000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"05f960846f1c7a93dab1d3f9a1121e86812e8c88","modified":1486234060000},{"_id":"themes/next/source/lib/ua-parser-js/.DS_Store","hash":"31bbd5907a0aa64496bd7635454944df1b8160a3","modified":1486237723000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"2ec99573e84c7117368beccb9e94b6bf35d2db03","modified":1486234060000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1486234060000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1486234060000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1486234060000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1486234060000},{"_id":"themes/next/.git/logs/refs/heads/master","hash":"db5a8911f6029e4861ef8521482816d89e283875","modified":1486279718000},{"_id":"themes/next/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/analytics/application-insights.swig","hash":"60426bf73f8a89ba61fb1be2df3ad5398e32c4ef","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/analytics/baidu-analytics.swig","hash":"deda6a814ed48debc694c4e0c466f06c127163d0","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/analytics/busuanzi-counter.swig","hash":"4fcbf57c4918528ab51d3d042cff92cf5aefb599","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/analytics/cnzz-analytics.swig","hash":"8160b27bee0aa372c7dc7c8476c05bae57f58d0f","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/analytics/facebook-sdk.swig","hash":"394d008e5e94575280407ad8a1607a028026cbc3","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/analytics/google-analytics.swig","hash":"30a23fa7e816496fdec0e932aa42e2d13098a9c2","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/analytics/tencent-analytics.swig","hash":"3658414379e0e8a34c45c40feadc3edc8dc55f88","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/comments/disqus.swig","hash":"fb1d04ede838b52ca7541973f86c3810f1ad396e","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/comments/duoshuo.swig","hash":"a356b2185d40914447fde817eb3d358ab6b3e4c3","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/comments/gentie.swig","hash":"03592d1d731592103a41ebb87437fe4b0a4c78ca","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/comments/hypercomments.swig","hash":"3e8dc5c6c912628a37e3b5f886bec7b2e5ed14ea","modified":1486234060000},{"_id":"themes/next/layout/_scripts/third-party/comments/youyan.swig","hash":"ea8078fa9e10be2bb042749d8b6a97adc38f914c","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"b49efc66bd055a2d0be7deabfcb02ee72a9a28c8","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"0dfb4b3ba3180d7285e66f270e1d3fa0f132c3d2","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"10994990d6e0b4d965a728a22cf7f6ee29cae9f6","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"711c8830886619d4f4a0598b0cde5499dce50c62","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"dd8a3b22fc2f222ac6e6c05bd8a773fb039169c0","modified":1486234060000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"2186be20e317505cd31886f1291429cc21f76703","modified":1486234060000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"5304f99581da3a31de3ecec959b7adf9002fde83","modified":1486234060000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"54c90cf7bdbf5c596179d8dae6e671bad1292662","modified":1486234060000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1486234060000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"013619c472c7e4b08311c464fcbe9fcf5edde603","modified":1486234060000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"64f5d56c08d74a338813df1265580ca0cbf0190b","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"c2d079788d6fc2e9a191ccdae94e50d55bf849dc","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"5ae7906dc7c1d9468c7f4b4a6feddddc555797a1","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"b0dcca862cd0cc6e732e33d975b476d744911742","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fda14bc35be2e1b332809b55b3d07155a833dbf4","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9a5581a770af8964064fef7afd3e16963e45547f","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"8829bc556ca38bfec4add4f15a2f028092ac6d46","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"82bbaa6322764779a1ac2e2c8390ce901c7972e2","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"1452cbe674cc1d008e1e9640eb4283841058fc64","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"a0e2030a606c934fb2c5c7373aaae04a1caac4c5","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"ff9f163bb05c0709577040a875924d36c9ab99d6","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"dcf9fe43b2ef78b923118ba39efedb38760e76b1","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"1408209dfb9a22a0982a30bdbd14842c2b53f264","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"9b63bd8effc7cf4b96acdea4d73add7df934a222","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"69ecd6c97e7cdfd822ac8102b45ad0ede85050db","modified":1486234060000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1486234060000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1486234060000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1486234060000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1486234060000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1486234060000},{"_id":"themes/next/.git/objects/pack/pack-a53cc289c75babf041d708b8ebd1f560676ee348.idx","hash":"360246dfc39fbe894d460fc58bc6b2a989f8f382","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1486234060000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1486234060000},{"_id":"themes/next/.git/logs/refs/remotes/origin/HEAD","hash":"757893f47021f16cd2580c68a4c9a2235cf6cde5","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"8994ffcce84deac0471532f270f97c44fea54dc0","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"ae1ca14e51de67b07dba8f61ec79ee0e2e344574","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"c890ce7fe933abad7baf39764a01894924854e92","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"6c00f6e0978f4d8f9a846a15579963728aaa6a17","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"4b7f81e1006e7acee3d1c840ccba155239f830cc","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"7778920dd105fa4de3a7ab206eeba30b1a7bac45","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"2039590632bba3943c39319d80ef630af7928185","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"a82afbb72d83ee394aedc7b37ac0008a9823b4f4","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"fdfadbb4483043c7e0afd541ee9712389e633517","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"8fae54591877a73dff0b29b2be2e8935e3c63575","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"2cdc094ecf907a02fce25ad4a607cd5c40da0f2b","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"b25132fe6a7ad67059a2c3afc60feabb479bdd75","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"387ce23bba52b22a586b2dfb4ec618fe1ffd3926","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"7f1aab694caf603809e33cff82beea84cd0128fd","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"c6dab7661a6b8c678b21b7eb273cef7100f970f6","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"963105a531403d7aad6d9e5e23e3bfabb8ec065a","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"bfd806d0a9f21446a22df82ac02e37d0075cc3b5","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"2e7ec9aaa3293941106b1bdd09055246aa3c3dc6","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"920343e41c124221a17f050bbb989494d44f7a24","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"e792c8dc41561c96d128e9b421187f1c3dc978a0","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"c44f6a553ec7ea5508f2054a13be33a62a15d3a9","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"9486ddd2cb255227db102d09a7df4cae0fabad72","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"45fa7193435a8eae9960267438750b4c9fa9587f","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"7690b9596ec3a49befbe529a5a2649abec0faf76","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"2d3abbc85b979a648e0e579e45f16a6eba49d1e7","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"234facd038f144bd0fe09a31ed1357c5d74c517f","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"3623e7fa4324ec1307370f33d8f287a9e20a5578","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"b8969e1654eec89a0fd10d88b337fee9cb03cd44","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"74d0ba86f698165d13402670382a822c8736a556","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"3eb73cee103b810fa56901577ecb9c9bb1793cff","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"93b08815c4d17e2b96fef8530ec1f1064dede6ef","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"b03f891883446f3a5548b7cc90d29c77e62f1053","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"2340dd9b3202c61d73cc708b790fac5adddbfc7f","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/third-party/gentie.styl","hash":"586a3ec0f1015e7207cd6a2474362e068c341744","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"327b5f63d55ec26f7663185c1a778440588d9803","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"eba491ae624b4c843c8be4c94a044085dad4ba0f","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"637c6b32c58ecf40041be6e911471cd82671919b","modified":1486234060000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"42348219db93a85d2ee23cb06cebd4d8ab121726","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1486234060000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"8b8e8cbce98a9296c8fd77f512ae85d945f65d40","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1486234060000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1486234060000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1486234060000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1486234060000},{"_id":"themes/next/source/uploads/avatar.jpg","hash":"8addf680bf948a5e60e512e926017bca4c878c94","modified":1471314421000},{"_id":"themes/next/.git/objects/71/6a4d3a8bdf5f1d9de3490cca32f10a9241c686","hash":"28027159723ae1de58a35c038fb1309ee0f16c7a","modified":1486279714000},{"_id":"themes/next/.git/objects/pack/pack-a53cc289c75babf041d708b8ebd1f560676ee348.pack","hash":"0a8d4b0f87e50d3c9cae3f2ac034cd565110aeb7","modified":1486234060000},{"_id":"public/atom.xml","hash":"e1e237f619602c8dcb4b801e03f5f03ef703e673","modified":1486352768370},{"_id":"public/sitemap.xml","hash":"9373e3f015fd043e0d4de209e8f05136b1ad9d9c","modified":1486352768396},{"_id":"public/bolg/uncategorized/Android-WebView那些坑之上传文件/index.html","hash":"bd485af3c87a1bd9e141286be9ef8c48fd647f06","modified":1486352768429},{"_id":"public/bolg/uncategorized/观察者模式-ObserverPattern/index.html","hash":"51e6be39df81c5a8393684ff23fdaef6363f66c2","modified":1486352768429},{"_id":"public/archives/page/2/index.html","hash":"8f3359f8d13d1ccb29fbea743765bae8181cf344","modified":1486352768429},{"_id":"public/archives/2017/page/2/index.html","hash":"ef8d1f7c63bc2de5effdff57daa172c821f46e42","modified":1486352768429},{"_id":"public/archives/2017/02/page/2/index.html","hash":"3799d4c19742450486972553eb3b69b3b580a7d1","modified":1486352768429},{"_id":"public/categories/java/index.html","hash":"43d39227ceb970fb3dd7c9cd92e345a22f7ec411","modified":1486352768429},{"_id":"public/categories/rxjava/index.html","hash":"d82bd67a36b727e76835c4063c6ea80f3bc2aaa6","modified":1486352768429},{"_id":"public/tags/Java/index.html","hash":"d4c0feab263f9614ccf560a199f509fdc73089c2","modified":1486352768429},{"_id":"public/tags/Android/index.html","hash":"984224e699f116559d33e5cf4ba16fe650176b55","modified":1486352768429},{"_id":"public/tags/RxJava/index.html","hash":"f0956f1bc553fb347143a1540a64ded15ecfdfed","modified":1486352768429},{"_id":"public/bolg/rxjava/RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例/index.html","hash":"1dc082c16c9498ab80153ce02ac8e5b5a2efaab2","modified":1486352768429},{"_id":"public/bolg/rxjava/RxJava系列7-最佳实践/index.html","hash":"525fb20875ee550e0a239783454fa884563ccf23","modified":1486352768429},{"_id":"public/bolg/rxjava/RxJava系列6-从微观角度解读RxJava源码/index.html","hash":"90647703304788f189a7c85d97297efba8085309","modified":1486352768429},{"_id":"public/bolg/rxjava/RxJava系列5-组合操作符/index.html","hash":"fd1bd0eed0b26e48d6f1c0d0d4b16d92a71acc0a","modified":1486352768429},{"_id":"public/bolg/rxjava/RxJava系列4-过滤操作符/index.html","hash":"b93184730a58f20f741c04280ada8df62323ef67","modified":1486352768429},{"_id":"public/bolg/rxjava/RxJava系列3-转换操作符/index.html","hash":"6ec05fdeb8e421d8a531c2350937b46cdc7bc809","modified":1486352768429},{"_id":"public/bolg/rxjava/RxJava系列2-基本概念及使用介绍/index.html","hash":"6cb1cf85132c1e8696d95b7da9243b4f0dc58efb","modified":1486352768429},{"_id":"public/bolg/rxjava/RxJava系列1-简介/index.html","hash":"62b8ccbed20d54bdcb53c6e518cb600a42b63d54","modified":1486352768429},{"_id":"public/bolg/java/在Android项目中使用Java8/index.html","hash":"6e3330016caef432cb385fffd78e9d7a7074f302","modified":1486352768429},{"_id":"public/bolg/java/Java8新特性第3章-Stream-API/index.html","hash":"015e5bfebc31bb8f20b3845bc3b7f885fbb2c5ec","modified":1486352768429},{"_id":"public/bolg/java/Java8新特性第2章-接口默认方法/index.html","hash":"f2a466b78cc6f1b81353e8638c95218156ecddd6","modified":1486352768429},{"_id":"public/bolg/java/Java8新特性第1章-Lambda表达式/index.html","hash":"dadf9c22261de0627f874037d01b9537422221ec","modified":1486352768430},{"_id":"public/archives/index.html","hash":"322ef6dbb8baeac33f509f6e19d5004a504a4417","modified":1486352768430},{"_id":"public/archives/2017/index.html","hash":"339c9631b17e2b3d340972eee65246a7b0d32477","modified":1486352768430},{"_id":"public/archives/2017/02/index.html","hash":"687662283721422fa04777bdf38ec5a617af8dd4","modified":1486352768430},{"_id":"public/index.html","hash":"b22080560e3fe39e5745f386decc1e63a1e3f062","modified":1486352768430},{"_id":"public/page/2/index.html","hash":"7b65d092c9f415f39c5ea4fab45c6bfddd3459f9","modified":1486352768430},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1486352768447},{"_id":"public/images/algolia_logo.svg","hash":"90035272fa31a3f65b3c0e2cb8a633876ef457dc","modified":1486352768447},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1486352768447},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1486352768447},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1486352768447},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1486352768447},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1486352768447},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1486352768447},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1486352768447},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1486352768447},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1486352768447},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1486352768447},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1486352768447},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1486352768448},{"_id":"public/lib/fastclick/LICENSE","hash":"dcd5b6b43095d9e90353a28b09cb269de8d4838e","modified":1486352768448},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1486352768448},{"_id":"public/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1486352768448},{"_id":"public/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1486352768448},{"_id":"public/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1486352768448},{"_id":"public/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1486352768448},{"_id":"public/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1486352768448},{"_id":"public/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1486352768448},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1486352768448},{"_id":"public/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1486352768448},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"97e438cc545714309882fbceadbf344fcaddcec5","modified":1486352769599},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"965ce8f688fedbeed504efd498bc9c1622d12362","modified":1486352769613},{"_id":"public/lib/font-awesome/fonts/FontAwesome.otf","hash":"1b22f17fdc38070de50e6d1ab3a32da71aa2d819","modified":1486352769625},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"6d7e6a5fc802b13694d8820fc0138037c0977d2e","modified":1486352769625},{"_id":"public/js/src/affix.js","hash":"978e0422b5bf1b560236d8d10ebc1adcf66392e3","modified":1486352769641},{"_id":"public/js/src/algolia-search.js","hash":"96b29f69b8b916b22f62c9959a117b5a968200a5","modified":1486352769642},{"_id":"public/js/src/bootstrap.js","hash":"39bf93769d9080fa01a9a875183b43198f79bc19","modified":1486352769642},{"_id":"public/js/src/motion.js","hash":"269414e84df544a4ccb88519f6abae4943db3c67","modified":1486352769642},{"_id":"public/js/src/post-details.js","hash":"2038f54e289b6da5def09689e69f623187147be5","modified":1486352769642},{"_id":"public/js/src/scrollspy.js","hash":"fe4da1b9fe73518226446f5f27d2831e4426fc35","modified":1486352769642},{"_id":"public/js/src/utils.js","hash":"384e17ff857f073060f5bf8c6e4f4b7353236331","modified":1486352769642},{"_id":"public/js/src/hook-duoshuo.js","hash":"a6119070c0119f33e08b29da7d2cce2635eb40a0","modified":1486352769643},{"_id":"public/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1486352769643},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1486352769644},{"_id":"public/lib/fastclick/README.html","hash":"da3c74d484c73cc7df565e8abbfa4d6a5a18d4da","modified":1486352769644},{"_id":"public/lib/fastclick/bower.json","hash":"4dcecf83afddba148464d5339c93f6d0aa9f42e9","modified":1486352769644},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1486352769645},{"_id":"public/lib/jquery_lazyload/jquery.lazyload.js","hash":"481fd478650e12b67c201a0ea41e92743f8b45a3","modified":1486352769645},{"_id":"public/lib/jquery_lazyload/CONTRIBUTING.html","hash":"a6358170d346af13b1452ac157b60505bec7015c","modified":1486352769645},{"_id":"public/lib/jquery_lazyload/README.html","hash":"bde24335f6bc09d8801c0dcd7274f71b466552bd","modified":1486352769645},{"_id":"public/lib/jquery_lazyload/bower.json","hash":"ae3c3b61e6e7f9e1d7e3585ad854380ecc04cf53","modified":1486352769645},{"_id":"public/lib/jquery_lazyload/jquery.scrollstop.js","hash":"0e9a81785a011c98be5ea821a8ed7d411818cfd1","modified":1486352769645},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1486352769645},{"_id":"public/lib/velocity/bower.json","hash":"0ef14e7ccdfba5db6eb3f8fc6aa3b47282c36409","modified":1486352769645},{"_id":"public/js/src/schemes/pisces.js","hash":"9ccee9189c910b8a264802d7b2ec305d12dedcd0","modified":1486352769645},{"_id":"public/lib/fancybox/source/jquery.fancybox.css","hash":"5f163444617b6cf267342f06ac166a237bb62df9","modified":1486352769646},{"_id":"public/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1486352769646},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1486352769646},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1486352769646},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1486352769646},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"53e194f4a72e649c04fb586dd57762b8c022800b","modified":1486352769646},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1486352769646},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"91e41741c2e93f732c82aaacec4cfc6e3f3ec876","modified":1486352769646},{"_id":"public/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"3bdf69ed2469e4fb57f5a95f17300eef891ff90d","modified":1486352769646},{"_id":"public/css/main.css","hash":"483b407b519ff82227bfb9c71fba8a8630a9de31","modified":1486352769646},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1486352769646},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1486352769646},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1486352769646},{"_id":"public/lib/fancybox/source/jquery.fancybox.pack.js","hash":"53360764b429c212f424399384417ccc233bb3be","modified":1486352769646},{"_id":"public/lib/fancybox/source/jquery.fancybox.js","hash":"1cf3d47b5ccb7cb6e9019c64f2a88d03a64853e4","modified":1486352769647},{"_id":"public/lib/fastclick/lib/fastclick.js","hash":"06cef196733a710e77ad7e386ced6963f092dc55","modified":1486352769647},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"fb5b49426dee7f1508500e698d1b3c6b04c8fcce","modified":1486352769647},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"4eda182cbcc046dbf449aef97c02c230cf80a494","modified":1486352769647},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1486352769647},{"_id":"public/lib/algolia-instant-search/instantsearch.min.js","hash":"9ccc6f8144f54e86df9a3fd33a18368d81cf3a4f","modified":1486352769648},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"61d8d967807ef12598d81582fa95b9f600c3ee01","modified":1486352769648},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"c0522272bbaef2acb3d341912754d6ea2d0ecfc0","modified":1486352769683},{"_id":"public/uploads/avatar.jpg","hash":"8addf680bf948a5e60e512e926017bca4c878c94","modified":1486352769765}],"Category":[{"name":"java","_id":"ciytk26e400026st6pnlss1ck"},{"name":"rxjava","_id":"ciytk26ev000l6st6adlom09m"}],"Data":[],"Page":[],"Post":[{"title":"Java8新特性第1章(Lambda表达式)","date":"2017-02-05T06:24:30.000Z","_content":"\n在介绍Lambda表达式之前，我们先来看只有单个方法的Interface（通常我们称之为回调接口）：\n\n```java\npublic interface OnClickListener {\n\tvoid onClick(View v);\n}\n```\n\t\n我们是这样使用它的：\n\n```java\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n\t\tv.setText(\"lalala\");\n   \t}\n});\n```\n\n这种回调模式在各种框架中非常流行,但是像上面这样的匿名内部类并不是一个好的选择，因为：\n\n* 语法冗余；\n* 匿名内部类中的this指针和变量容易产生误解；\n* 无法捕获非final局部变量；\n* 非静态内部类默认持有外部类的引用，部分情况下会导致外部类无法被GC回收，导致内存泄露。\n\n令人高兴的是Java8为我们带来了Lambda,下面我们看看利用Lambda如何实现上面的功能：\n\n```java\nbutton.setOnClickListener(v -> v.setText(\"lalala\"));\n```\n\n怎么样？！五行代码用一行就搞定了！！！\n\n> 在这里补充个概念`函数式接口`；前面提到的OnClickListener接口只有一个方法，Java中大多数回调接口都有这个特征：比如Runnable和Comparator；我们把这些只拥有一个方法的接口称之为`函数式接口`。\n\n## 一、Lambda表达式\n\n匿名内部类最大的问题在于其冗余的语法，比如前面的OnClickListener中五行代码仅有一行是在执行任务。Lambda表达式是匿名方法，前面我们也看到了它用极其轻量的语法解决了这一问题。\n\n下面给大家看几个Lambda表达式的例子：\n\n```java\n(int x, int y) -> x + y                      //接收x和y两个整形参数并返回他们的和\n() -> 66                                     //不接收任何参数直接返回66\n(String name) -> {System.out.println(name);} //接收一个字符串然后打印出来\n(View view) -> {view.setText(\"lalala\");}     //接收一个View对象并调用setText方法\n```\n\t\nLambda表达式语法由`参数列表`、`->`和`函数体`组成。函数体既可以是一个表达式也可以是一个代码块。\n\n* __表达式__：表达式会被执行然后返回结果。它简化掉了`return`关键字。\n* __代码块__：顾名思义就是一坨代码，和普通方法中的语句一样。\n\n<!--lambda经常出现在嵌套环境中，如作为方法的参数：\n\n\tRunnable runnable = () -> {doSomething();};\n\tnew Thread(runnable);\n\t\n\t//也可以这样写\n\tnew Thread(() -> {doSomething();});-->\n\n## 二、目标类型\n\n通过前面的例子我们可以看到，lambda表达式没有名字，那我们怎么知道它的类型呢？答案是通过上下文推导而来的。例如，下面的表达式的类型是`OnClickListener`\n\n```java\nOnClickListener listener = (View v) -> {v.setText(\"lalala\");};\n```\n\t\n这就意味着同样的lambda表达式在不同的上下文里有不同的类型\n\n```java\nRunnable runnable = () -> doSomething();  //这个表达式是Runnable类型的\nCallback callback = () -> doSomething();  //这个表达式是Callback类型的\n```\n\t\n编译器利用lambda表达式所在的上下文所期待的类型来推导表达式的类型，这个__被期待的类型__被称为`目标类型`。lambda表达式只能出现在__目标类型__为`函数式接口`的上下文中。\n\nLambda表达式的类型和目标类型的方法签名必须一致，编译器会对此做检查，一个lambda表达式要想赋值给目标类型`T`则必须满足下面所有的条件：\n\n* `T`是一个函数式接口\n* lambda表达式的参数必须和`T`的方法参数在数量、类型和顺序上一致（一一对应）\n* lambda表达式的返回值必须和`T`的方法的返回值一致或者是它的子类\n* lambda表达式抛出的异常和`T`的方法的异常一致或者是它的子类\n\n由于目标类型是知道lambda表达式的参数类型，所以我们没必要把已知的类型重复一遍。也就是说lambda表达式的参数类型可以从目标类型获取：\n\n```java\n//编译器可以推导出s1和s2是String类型\nComparator<String> c = (s1, s2) -> s1.compareTo(s2);\n//当表达式的参数只有一个时括号也是可以省略的\nbutton.setOnClickListener(v -> v.setText(\"lalala\"));\n```\n\t\n> Java7中的泛型方法和<>构造器也是通过目标类型来进行类型推导的,如：\n> \n> \t\t```java\n> \t\tList<Integer> intList = Collections.emptyList<>();\n> \t\tList<String> strList = new ArrayList<>();\n> \t\t```\n\n## 三、作用域\n在内部类中使用变量名和this非常容易出错。内部类通过继承得到的成员变量（包括来说object的）可能会把外部类的成员变量覆盖掉，未做限制的this引用会指向内部类自己而非外部类。\n\n而lambda表达式的语义就十分简单：它不会从父类中继承任何变量，也不用引入新的作用域。lambda表达式的参数及函数体里面的变量和它外部环境的变量具有相同的语义（this关键字也是一样）。\n\n下面我们举个栗子吧!\n\n```java\npublic class HelloLambda {\n\n    Runnable r1 = () -> System.out.println(this);\n    Runnable r2 = () -> System.out.println(toString());\n\n    @Override\n    public String toString() {\n        return \"Hello, lambda!\";\n    }\n\n    public static void main(String[] args) {\n        new HelloLambda().r1.run();  \n        new HelloLambda().r2.run();\n    }\n}\n```\n\n上面的代码最终会打印两个`Hello, lambda!`，与之相类似的内部类则会打印出类似`HelloLambda$1@32a890`和`HelloLambda$1@6b32098`这种出乎意料的字符串。\n\n总结：基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文的局部变量。\n\n## 四、变量捕获\n在Java7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为`final`就会产生一个编译错误。但是在Java8中放宽了这一限制--对于lambda表达式和内部类，允许在其中捕获那些符合有效只读的局部变量（如果一个局部变量在初始化后从未被修改过，那么它就是有效只读）。\n\n```java\nRunnable getRunnable(String name){\n    String hello = \"hello\";\n    return () -> System.out.println(hello+\",\"+name);\n}\n```\n\n对于`this`的引用以及通过`this`对未限定字段的引用和未限定方法的调用本质上都属于使用`final`局部变量。包含此类引用的lambda表达式相当于捕获了`this`实例。在其他情况下，lambda对象不会保留任何对`this`的应用。\n\n这个特性对内存管理是极好的：要知道在java中一个非静态内部类会默认持有外部类实例的强引用，这往往会造成内存泄露。而在lambda表达式中如果没有捕获外部类成员则不会保留对外部类实例的引用。\n\n不过尽管Java8放宽了对捕获变量的语法限制，但试图修改捕获变量的行为是被禁止的，比如下面这个例子就是非法的：\n\n```java\nint sum  = 0;\nlist.forEach(i -> {sum += i;});\n```\n\t\n为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起[race condition](https://zh.wikipedia.org/zh-cn/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3)\n\nlambda表达式不支持修改捕获变量的另外一个原因是我们可以使用更好的方式来实现同样的效果：使用规约(condition)。java.util.stream包提供了各种规约操作，关于Java8中的`Stream API`我们放到下一章介绍。\n\n## 五、方法引用\nlambda表达式允许我们定义一个匿名方法，并以函数式接口的方式使用它。Java8能够在已有的方法上实现同样的特性。\n\n方法引用和lambda表达式拥有相同的特性（他们都需要一个目标类型，并且需要被转化为函数式接口的实例）,不过我们不需要为方法引用提供方法体，我们可以直接通过方法名引用已有方法。\n\n以下面的代码为例，假设我们要按照`userName`排序\n\n```java\nclass User{\n\n    private String userName;\n\n    public String getUserName() {\n        return userName;\n    }\n    ...\n}\n\nList<User> users = new ArrayList<>();\nComparator<User> comparator = Comparator.comparing(u -> u.getUserName());\nCollections.sort(users, comparator);\n```\n\n我们可以用方法引用替换上面的lambda表达式\n\n```java\nComparator<User> comparator = Comparator.comparing(User::getUserName);\n```\n\t\n这里的`User::getUserName`被看做是lambda表达式的简写形式。尽管方法引用不一定会把代码变得更紧凑，但它拥有更明确的语义--如果我们想要调用的方法拥有一个名字，那么我们就可以通过方法名调用它。\n\n<!--因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：\n\n\tConsumer<Integer> b1 = System::exit;    // void exit(int status)\n\tConsumer<String[]> b2 = Arrays:sort;    // void sort(Object[] a)\n\tConsumer<String> b3 = MyProgram::main;  // void main(String... args)\n\tRunnable r = Myprogram::mapToInt        // void main(String... args)-->\n\n方法引用有很多种，它们的语法如下：\n\n* 静态方法引用：ClassName::methodName\n* 实例上的实例方法引用：instanceReference::methodName\n* 超类上的实例方法引用：super::methodName\n* 类型上的实例方法引用：ClassName::methodName\n* 构造方法引用：Class::new\n* 数组构造方法引用：TypeName[]::new\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n\n\n\n\n\n\n\n","source":"_posts/2017-02-05-Java8新特性第1章-Lambda表达式.md","raw":"---\ntitle: Java8新特性第1章(Lambda表达式)\ndate: 2017-02-05 14:24:30\ncategories: java\ntags: Java\n---\n\n在介绍Lambda表达式之前，我们先来看只有单个方法的Interface（通常我们称之为回调接口）：\n\n```java\npublic interface OnClickListener {\n\tvoid onClick(View v);\n}\n```\n\t\n我们是这样使用它的：\n\n```java\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n\t\tv.setText(\"lalala\");\n   \t}\n});\n```\n\n这种回调模式在各种框架中非常流行,但是像上面这样的匿名内部类并不是一个好的选择，因为：\n\n* 语法冗余；\n* 匿名内部类中的this指针和变量容易产生误解；\n* 无法捕获非final局部变量；\n* 非静态内部类默认持有外部类的引用，部分情况下会导致外部类无法被GC回收，导致内存泄露。\n\n令人高兴的是Java8为我们带来了Lambda,下面我们看看利用Lambda如何实现上面的功能：\n\n```java\nbutton.setOnClickListener(v -> v.setText(\"lalala\"));\n```\n\n怎么样？！五行代码用一行就搞定了！！！\n\n> 在这里补充个概念`函数式接口`；前面提到的OnClickListener接口只有一个方法，Java中大多数回调接口都有这个特征：比如Runnable和Comparator；我们把这些只拥有一个方法的接口称之为`函数式接口`。\n\n## 一、Lambda表达式\n\n匿名内部类最大的问题在于其冗余的语法，比如前面的OnClickListener中五行代码仅有一行是在执行任务。Lambda表达式是匿名方法，前面我们也看到了它用极其轻量的语法解决了这一问题。\n\n下面给大家看几个Lambda表达式的例子：\n\n```java\n(int x, int y) -> x + y                      //接收x和y两个整形参数并返回他们的和\n() -> 66                                     //不接收任何参数直接返回66\n(String name) -> {System.out.println(name);} //接收一个字符串然后打印出来\n(View view) -> {view.setText(\"lalala\");}     //接收一个View对象并调用setText方法\n```\n\t\nLambda表达式语法由`参数列表`、`->`和`函数体`组成。函数体既可以是一个表达式也可以是一个代码块。\n\n* __表达式__：表达式会被执行然后返回结果。它简化掉了`return`关键字。\n* __代码块__：顾名思义就是一坨代码，和普通方法中的语句一样。\n\n<!--lambda经常出现在嵌套环境中，如作为方法的参数：\n\n\tRunnable runnable = () -> {doSomething();};\n\tnew Thread(runnable);\n\t\n\t//也可以这样写\n\tnew Thread(() -> {doSomething();});-->\n\n## 二、目标类型\n\n通过前面的例子我们可以看到，lambda表达式没有名字，那我们怎么知道它的类型呢？答案是通过上下文推导而来的。例如，下面的表达式的类型是`OnClickListener`\n\n```java\nOnClickListener listener = (View v) -> {v.setText(\"lalala\");};\n```\n\t\n这就意味着同样的lambda表达式在不同的上下文里有不同的类型\n\n```java\nRunnable runnable = () -> doSomething();  //这个表达式是Runnable类型的\nCallback callback = () -> doSomething();  //这个表达式是Callback类型的\n```\n\t\n编译器利用lambda表达式所在的上下文所期待的类型来推导表达式的类型，这个__被期待的类型__被称为`目标类型`。lambda表达式只能出现在__目标类型__为`函数式接口`的上下文中。\n\nLambda表达式的类型和目标类型的方法签名必须一致，编译器会对此做检查，一个lambda表达式要想赋值给目标类型`T`则必须满足下面所有的条件：\n\n* `T`是一个函数式接口\n* lambda表达式的参数必须和`T`的方法参数在数量、类型和顺序上一致（一一对应）\n* lambda表达式的返回值必须和`T`的方法的返回值一致或者是它的子类\n* lambda表达式抛出的异常和`T`的方法的异常一致或者是它的子类\n\n由于目标类型是知道lambda表达式的参数类型，所以我们没必要把已知的类型重复一遍。也就是说lambda表达式的参数类型可以从目标类型获取：\n\n```java\n//编译器可以推导出s1和s2是String类型\nComparator<String> c = (s1, s2) -> s1.compareTo(s2);\n//当表达式的参数只有一个时括号也是可以省略的\nbutton.setOnClickListener(v -> v.setText(\"lalala\"));\n```\n\t\n> Java7中的泛型方法和<>构造器也是通过目标类型来进行类型推导的,如：\n> \n> \t\t```java\n> \t\tList<Integer> intList = Collections.emptyList<>();\n> \t\tList<String> strList = new ArrayList<>();\n> \t\t```\n\n## 三、作用域\n在内部类中使用变量名和this非常容易出错。内部类通过继承得到的成员变量（包括来说object的）可能会把外部类的成员变量覆盖掉，未做限制的this引用会指向内部类自己而非外部类。\n\n而lambda表达式的语义就十分简单：它不会从父类中继承任何变量，也不用引入新的作用域。lambda表达式的参数及函数体里面的变量和它外部环境的变量具有相同的语义（this关键字也是一样）。\n\n下面我们举个栗子吧!\n\n```java\npublic class HelloLambda {\n\n    Runnable r1 = () -> System.out.println(this);\n    Runnable r2 = () -> System.out.println(toString());\n\n    @Override\n    public String toString() {\n        return \"Hello, lambda!\";\n    }\n\n    public static void main(String[] args) {\n        new HelloLambda().r1.run();  \n        new HelloLambda().r2.run();\n    }\n}\n```\n\n上面的代码最终会打印两个`Hello, lambda!`，与之相类似的内部类则会打印出类似`HelloLambda$1@32a890`和`HelloLambda$1@6b32098`这种出乎意料的字符串。\n\n总结：基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文的局部变量。\n\n## 四、变量捕获\n在Java7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为`final`就会产生一个编译错误。但是在Java8中放宽了这一限制--对于lambda表达式和内部类，允许在其中捕获那些符合有效只读的局部变量（如果一个局部变量在初始化后从未被修改过，那么它就是有效只读）。\n\n```java\nRunnable getRunnable(String name){\n    String hello = \"hello\";\n    return () -> System.out.println(hello+\",\"+name);\n}\n```\n\n对于`this`的引用以及通过`this`对未限定字段的引用和未限定方法的调用本质上都属于使用`final`局部变量。包含此类引用的lambda表达式相当于捕获了`this`实例。在其他情况下，lambda对象不会保留任何对`this`的应用。\n\n这个特性对内存管理是极好的：要知道在java中一个非静态内部类会默认持有外部类实例的强引用，这往往会造成内存泄露。而在lambda表达式中如果没有捕获外部类成员则不会保留对外部类实例的引用。\n\n不过尽管Java8放宽了对捕获变量的语法限制，但试图修改捕获变量的行为是被禁止的，比如下面这个例子就是非法的：\n\n```java\nint sum  = 0;\nlist.forEach(i -> {sum += i;});\n```\n\t\n为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起[race condition](https://zh.wikipedia.org/zh-cn/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3)\n\nlambda表达式不支持修改捕获变量的另外一个原因是我们可以使用更好的方式来实现同样的效果：使用规约(condition)。java.util.stream包提供了各种规约操作，关于Java8中的`Stream API`我们放到下一章介绍。\n\n## 五、方法引用\nlambda表达式允许我们定义一个匿名方法，并以函数式接口的方式使用它。Java8能够在已有的方法上实现同样的特性。\n\n方法引用和lambda表达式拥有相同的特性（他们都需要一个目标类型，并且需要被转化为函数式接口的实例）,不过我们不需要为方法引用提供方法体，我们可以直接通过方法名引用已有方法。\n\n以下面的代码为例，假设我们要按照`userName`排序\n\n```java\nclass User{\n\n    private String userName;\n\n    public String getUserName() {\n        return userName;\n    }\n    ...\n}\n\nList<User> users = new ArrayList<>();\nComparator<User> comparator = Comparator.comparing(u -> u.getUserName());\nCollections.sort(users, comparator);\n```\n\n我们可以用方法引用替换上面的lambda表达式\n\n```java\nComparator<User> comparator = Comparator.comparing(User::getUserName);\n```\n\t\n这里的`User::getUserName`被看做是lambda表达式的简写形式。尽管方法引用不一定会把代码变得更紧凑，但它拥有更明确的语义--如果我们想要调用的方法拥有一个名字，那么我们就可以通过方法名调用它。\n\n<!--因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：\n\n\tConsumer<Integer> b1 = System::exit;    // void exit(int status)\n\tConsumer<String[]> b2 = Arrays:sort;    // void sort(Object[] a)\n\tConsumer<String> b3 = MyProgram::main;  // void main(String... args)\n\tRunnable r = Myprogram::mapToInt        // void main(String... args)-->\n\n方法引用有很多种，它们的语法如下：\n\n* 静态方法引用：ClassName::methodName\n* 实例上的实例方法引用：instanceReference::methodName\n* 超类上的实例方法引用：super::methodName\n* 类型上的实例方法引用：ClassName::methodName\n* 构造方法引用：Class::new\n* 数组构造方法引用：TypeName[]::new\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n\n\n\n\n\n\n\n","slug":"Java8新特性第1章-Lambda表达式","published":1,"updated":"2017-02-05T16:02:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26dn00006st67g6ldh6h","content":"<p>在介绍Lambda表达式之前，我们先来看只有单个方法的Interface（通常我们称之为回调接口）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnClickListener</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们是这样使用它的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">\t\tv.setText(<span class=\"string\">\"lalala\"</span>);</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这种回调模式在各种框架中非常流行,但是像上面这样的匿名内部类并不是一个好的选择，因为：</p>\n<ul>\n<li>语法冗余；</li>\n<li>匿名内部类中的this指针和变量容易产生误解；</li>\n<li>无法捕获非final局部变量；</li>\n<li>非静态内部类默认持有外部类的引用，部分情况下会导致外部类无法被GC回收，导致内存泄露。</li>\n</ul>\n<p>令人高兴的是Java8为我们带来了Lambda,下面我们看看利用Lambda如何实现上面的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.setOnClickListener(v -&gt; v.setText(<span class=\"string\">\"lalala\"</span>));</div></pre></td></tr></table></figure>\n<p>怎么样？！五行代码用一行就搞定了！！！</p>\n<blockquote>\n<p>在这里补充个概念<code>函数式接口</code>；前面提到的OnClickListener接口只有一个方法，Java中大多数回调接口都有这个特征：比如Runnable和Comparator；我们把这些只拥有一个方法的接口称之为<code>函数式接口</code>。</p>\n</blockquote>\n<h2 id=\"一、Lambda表达式\"><a href=\"#一、Lambda表达式\" class=\"headerlink\" title=\"一、Lambda表达式\"></a>一、Lambda表达式</h2><p>匿名内部类最大的问题在于其冗余的语法，比如前面的OnClickListener中五行代码仅有一行是在执行任务。Lambda表达式是匿名方法，前面我们也看到了它用极其轻量的语法解决了这一问题。</p>\n<p>下面给大家看几个Lambda表达式的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y) -&gt; x + y                      <span class=\"comment\">//接收x和y两个整形参数并返回他们的和</span></div><div class=\"line\">() -&gt; <span class=\"number\">66</span>                                     <span class=\"comment\">//不接收任何参数直接返回66</span></div><div class=\"line\">(String name) -&gt; &#123;System.out.println(name);&#125; <span class=\"comment\">//接收一个字符串然后打印出来</span></div><div class=\"line\">(View view) -&gt; &#123;view.setText(<span class=\"string\">\"lalala\"</span>);&#125;     <span class=\"comment\">//接收一个View对象并调用setText方法</span></div></pre></td></tr></table></figure>\n<p>Lambda表达式语法由<code>参数列表</code>、<code>-&gt;</code>和<code>函数体</code>组成。函数体既可以是一个表达式也可以是一个代码块。</p>\n<ul>\n<li><strong>表达式</strong>：表达式会被执行然后返回结果。它简化掉了<code>return</code>关键字。</li>\n<li><strong>代码块</strong>：顾名思义就是一坨代码，和普通方法中的语句一样。</li>\n</ul>\n<!--lambda经常出现在嵌套环境中，如作为方法的参数：\n\n    Runnable runnable = () -> {doSomething();};\n    new Thread(runnable);\n\n    //也可以这样写\n    new Thread(() -> {doSomething();});-->\n<h2 id=\"二、目标类型\"><a href=\"#二、目标类型\" class=\"headerlink\" title=\"二、目标类型\"></a>二、目标类型</h2><p>通过前面的例子我们可以看到，lambda表达式没有名字，那我们怎么知道它的类型呢？答案是通过上下文推导而来的。例如，下面的表达式的类型是<code>OnClickListener</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OnClickListener listener = (View v) -&gt; &#123;v.setText(<span class=\"string\">\"lalala\"</span>);&#125;;</div></pre></td></tr></table></figure>\n<p>这就意味着同样的lambda表达式在不同的上下文里有不同的类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Runnable runnable = () -&gt; doSomething();  <span class=\"comment\">//这个表达式是Runnable类型的</span></div><div class=\"line\">Callback callback = () -&gt; doSomething();  <span class=\"comment\">//这个表达式是Callback类型的</span></div></pre></td></tr></table></figure>\n<p>编译器利用lambda表达式所在的上下文所期待的类型来推导表达式的类型，这个<strong>被期待的类型</strong>被称为<code>目标类型</code>。lambda表达式只能出现在<strong>目标类型</strong>为<code>函数式接口</code>的上下文中。</p>\n<p>Lambda表达式的类型和目标类型的方法签名必须一致，编译器会对此做检查，一个lambda表达式要想赋值给目标类型<code>T</code>则必须满足下面所有的条件：</p>\n<ul>\n<li><code>T</code>是一个函数式接口</li>\n<li>lambda表达式的参数必须和<code>T</code>的方法参数在数量、类型和顺序上一致（一一对应）</li>\n<li>lambda表达式的返回值必须和<code>T</code>的方法的返回值一致或者是它的子类</li>\n<li>lambda表达式抛出的异常和<code>T</code>的方法的异常一致或者是它的子类</li>\n</ul>\n<p>由于目标类型是知道lambda表达式的参数类型，所以我们没必要把已知的类型重复一遍。也就是说lambda表达式的参数类型可以从目标类型获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//编译器可以推导出s1和s2是String类型</span></div><div class=\"line\">Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareTo(s2);</div><div class=\"line\"><span class=\"comment\">//当表达式的参数只有一个时括号也是可以省略的</span></div><div class=\"line\">button.setOnClickListener(v -&gt; v.setText(<span class=\"string\">\"lalala\"</span>));</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Java7中的泛型方法和&lt;&gt;构造器也是通过目标类型来进行类型推导的,如：</p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; \t\tList&lt;Integer&gt; intList = Collections.emptyList&lt;&gt;();</div><div class=\"line\">&gt; \t\tList&lt;String&gt; strList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</code></pre></blockquote>\n<h2 id=\"三、作用域\"><a href=\"#三、作用域\" class=\"headerlink\" title=\"三、作用域\"></a>三、作用域</h2><p>在内部类中使用变量名和this非常容易出错。内部类通过继承得到的成员变量（包括来说object的）可能会把外部类的成员变量覆盖掉，未做限制的this引用会指向内部类自己而非外部类。</p>\n<p>而lambda表达式的语义就十分简单：它不会从父类中继承任何变量，也不用引入新的作用域。lambda表达式的参数及函数体里面的变量和它外部环境的变量具有相同的语义（this关键字也是一样）。</p>\n<p>下面我们举个栗子吧!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloLambda</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    Runnable r1 = () -&gt; System.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">    Runnable r2 = () -&gt; System.out.println(toString());</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello, lambda!\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> HelloLambda().r1.run();  </div><div class=\"line\">        <span class=\"keyword\">new</span> HelloLambda().r2.run();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码最终会打印两个<code>Hello, lambda!</code>，与之相类似的内部类则会打印出类似<code>HelloLambda$1@32a890</code>和<code>HelloLambda$1@6b32098</code>这种出乎意料的字符串。</p>\n<p>总结：基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文的局部变量。</p>\n<h2 id=\"四、变量捕获\"><a href=\"#四、变量捕获\" class=\"headerlink\" title=\"四、变量捕获\"></a>四、变量捕获</h2><p>在Java7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为<code>final</code>就会产生一个编译错误。但是在Java8中放宽了这一限制–对于lambda表达式和内部类，允许在其中捕获那些符合有效只读的局部变量（如果一个局部变量在初始化后从未被修改过，那么它就是有效只读）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Runnable <span class=\"title\">getRunnable</span><span class=\"params\">(String name)</span></span>&#123;</div><div class=\"line\">    String hello = <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> () -&gt; System.out.println(hello+<span class=\"string\">\",\"</span>+name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于<code>this</code>的引用以及通过<code>this</code>对未限定字段的引用和未限定方法的调用本质上都属于使用<code>final</code>局部变量。包含此类引用的lambda表达式相当于捕获了<code>this</code>实例。在其他情况下，lambda对象不会保留任何对<code>this</code>的应用。</p>\n<p>这个特性对内存管理是极好的：要知道在java中一个非静态内部类会默认持有外部类实例的强引用，这往往会造成内存泄露。而在lambda表达式中如果没有捕获外部类成员则不会保留对外部类实例的引用。</p>\n<p>不过尽管Java8放宽了对捕获变量的语法限制，但试图修改捕获变量的行为是被禁止的，比如下面这个例子就是非法的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> sum  = <span class=\"number\">0</span>;</div><div class=\"line\">list.forEach(i -&gt; &#123;sum += i;&#125;);</div></pre></td></tr></table></figure>\n<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起<a href=\"https://zh.wikipedia.org/zh-cn/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3\" target=\"_blank\" rel=\"external\">race condition</a></p>\n<p>lambda表达式不支持修改捕获变量的另外一个原因是我们可以使用更好的方式来实现同样的效果：使用规约(condition)。java.util.stream包提供了各种规约操作，关于Java8中的<code>Stream API</code>我们放到下一章介绍。</p>\n<h2 id=\"五、方法引用\"><a href=\"#五、方法引用\" class=\"headerlink\" title=\"五、方法引用\"></a>五、方法引用</h2><p>lambda表达式允许我们定义一个匿名方法，并以函数式接口的方式使用它。Java8能够在已有的方法上实现同样的特性。</p>\n<p>方法引用和lambda表达式拥有相同的特性（他们都需要一个目标类型，并且需要被转化为函数式接口的实例）,不过我们不需要为方法引用提供方法体，我们可以直接通过方法名引用已有方法。</p>\n<p>以下面的代码为例，假设我们要按照<code>userName</code>排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> String userName;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> userName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">List&lt;User&gt; users = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">Comparator&lt;User&gt; comparator = Comparator.comparing(u -&gt; u.getUserName());</div><div class=\"line\">Collections.sort(users, comparator);</div></pre></td></tr></table></figure>\n<p>我们可以用方法引用替换上面的lambda表达式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Comparator&lt;User&gt; comparator = Comparator.comparing(User::getUserName);</div></pre></td></tr></table></figure>\n<p>这里的<code>User::getUserName</code>被看做是lambda表达式的简写形式。尽管方法引用不一定会把代码变得更紧凑，但它拥有更明确的语义–如果我们想要调用的方法拥有一个名字，那么我们就可以通过方法名调用它。</p>\n<!--因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：\n\n    Consumer<Integer> b1 = System::exit;    // void exit(int status)\n    Consumer<String[]> b2 = Arrays:sort;    // void sort(Object[] a)\n    Consumer<String> b3 = MyProgram::main;  // void main(String... args)\n    Runnable r = Myprogram::mapToInt        // void main(String... args)-->\n<p>方法引用有很多种，它们的语法如下：</p>\n<ul>\n<li>静态方法引用：ClassName::methodName</li>\n<li>实例上的实例方法引用：instanceReference::methodName</li>\n<li>超类上的实例方法引用：super::methodName</li>\n<li>类型上的实例方法引用：ClassName::methodName</li>\n<li>构造方法引用：Class::new</li>\n<li>数组构造方法引用：TypeName[]::new</li>\n</ul>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<p>在介绍Lambda表达式之前，我们先来看只有单个方法的Interface（通常我们称之为回调接口）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">OnClickListener</span> </span>&#123;</div><div class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们是这样使用它的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">\t\tv.setText(<span class=\"string\">\"lalala\"</span>);</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>这种回调模式在各种框架中非常流行,但是像上面这样的匿名内部类并不是一个好的选择，因为：</p>\n<ul>\n<li>语法冗余；</li>\n<li>匿名内部类中的this指针和变量容易产生误解；</li>\n<li>无法捕获非final局部变量；</li>\n<li>非静态内部类默认持有外部类的引用，部分情况下会导致外部类无法被GC回收，导致内存泄露。</li>\n</ul>\n<p>令人高兴的是Java8为我们带来了Lambda,下面我们看看利用Lambda如何实现上面的功能：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.setOnClickListener(v -&gt; v.setText(<span class=\"string\">\"lalala\"</span>));</div></pre></td></tr></table></figure>\n<p>怎么样？！五行代码用一行就搞定了！！！</p>\n<blockquote>\n<p>在这里补充个概念<code>函数式接口</code>；前面提到的OnClickListener接口只有一个方法，Java中大多数回调接口都有这个特征：比如Runnable和Comparator；我们把这些只拥有一个方法的接口称之为<code>函数式接口</code>。</p>\n</blockquote>\n<h2 id=\"一、Lambda表达式\"><a href=\"#一、Lambda表达式\" class=\"headerlink\" title=\"一、Lambda表达式\"></a>一、Lambda表达式</h2><p>匿名内部类最大的问题在于其冗余的语法，比如前面的OnClickListener中五行代码仅有一行是在执行任务。Lambda表达式是匿名方法，前面我们也看到了它用极其轻量的语法解决了这一问题。</p>\n<p>下面给大家看几个Lambda表达式的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">(<span class=\"keyword\">int</span> x, <span class=\"keyword\">int</span> y) -&gt; x + y                      <span class=\"comment\">//接收x和y两个整形参数并返回他们的和</span></div><div class=\"line\">() -&gt; <span class=\"number\">66</span>                                     <span class=\"comment\">//不接收任何参数直接返回66</span></div><div class=\"line\">(String name) -&gt; &#123;System.out.println(name);&#125; <span class=\"comment\">//接收一个字符串然后打印出来</span></div><div class=\"line\">(View view) -&gt; &#123;view.setText(<span class=\"string\">\"lalala\"</span>);&#125;     <span class=\"comment\">//接收一个View对象并调用setText方法</span></div></pre></td></tr></table></figure>\n<p>Lambda表达式语法由<code>参数列表</code>、<code>-&gt;</code>和<code>函数体</code>组成。函数体既可以是一个表达式也可以是一个代码块。</p>\n<ul>\n<li><strong>表达式</strong>：表达式会被执行然后返回结果。它简化掉了<code>return</code>关键字。</li>\n<li><strong>代码块</strong>：顾名思义就是一坨代码，和普通方法中的语句一样。</li>\n</ul>\n<!--lambda经常出现在嵌套环境中，如作为方法的参数：\n\n    Runnable runnable = () -> {doSomething();};\n    new Thread(runnable);\n\n    //也可以这样写\n    new Thread(() -> {doSomething();});-->\n<h2 id=\"二、目标类型\"><a href=\"#二、目标类型\" class=\"headerlink\" title=\"二、目标类型\"></a>二、目标类型</h2><p>通过前面的例子我们可以看到，lambda表达式没有名字，那我们怎么知道它的类型呢？答案是通过上下文推导而来的。例如，下面的表达式的类型是<code>OnClickListener</code></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">OnClickListener listener = (View v) -&gt; &#123;v.setText(<span class=\"string\">\"lalala\"</span>);&#125;;</div></pre></td></tr></table></figure>\n<p>这就意味着同样的lambda表达式在不同的上下文里有不同的类型</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">Runnable runnable = () -&gt; doSomething();  <span class=\"comment\">//这个表达式是Runnable类型的</span></div><div class=\"line\">Callback callback = () -&gt; doSomething();  <span class=\"comment\">//这个表达式是Callback类型的</span></div></pre></td></tr></table></figure>\n<p>编译器利用lambda表达式所在的上下文所期待的类型来推导表达式的类型，这个<strong>被期待的类型</strong>被称为<code>目标类型</code>。lambda表达式只能出现在<strong>目标类型</strong>为<code>函数式接口</code>的上下文中。</p>\n<p>Lambda表达式的类型和目标类型的方法签名必须一致，编译器会对此做检查，一个lambda表达式要想赋值给目标类型<code>T</code>则必须满足下面所有的条件：</p>\n<ul>\n<li><code>T</code>是一个函数式接口</li>\n<li>lambda表达式的参数必须和<code>T</code>的方法参数在数量、类型和顺序上一致（一一对应）</li>\n<li>lambda表达式的返回值必须和<code>T</code>的方法的返回值一致或者是它的子类</li>\n<li>lambda表达式抛出的异常和<code>T</code>的方法的异常一致或者是它的子类</li>\n</ul>\n<p>由于目标类型是知道lambda表达式的参数类型，所以我们没必要把已知的类型重复一遍。也就是说lambda表达式的参数类型可以从目标类型获取：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"comment\">//编译器可以推导出s1和s2是String类型</span></div><div class=\"line\">Comparator&lt;String&gt; c = (s1, s2) -&gt; s1.compareTo(s2);</div><div class=\"line\"><span class=\"comment\">//当表达式的参数只有一个时括号也是可以省略的</span></div><div class=\"line\">button.setOnClickListener(v -&gt; v.setText(<span class=\"string\">\"lalala\"</span>));</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Java7中的泛型方法和&lt;&gt;构造器也是通过目标类型来进行类型推导的,如：</p>\n<pre><code><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">&gt; \t\tList&lt;Integer&gt; intList = Collections.emptyList&lt;&gt;();</div><div class=\"line\">&gt; \t\tList&lt;String&gt; strList = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">&gt;</div></pre></td></tr></table></figure>\n</code></pre></blockquote>\n<h2 id=\"三、作用域\"><a href=\"#三、作用域\" class=\"headerlink\" title=\"三、作用域\"></a>三、作用域</h2><p>在内部类中使用变量名和this非常容易出错。内部类通过继承得到的成员变量（包括来说object的）可能会把外部类的成员变量覆盖掉，未做限制的this引用会指向内部类自己而非外部类。</p>\n<p>而lambda表达式的语义就十分简单：它不会从父类中继承任何变量，也不用引入新的作用域。lambda表达式的参数及函数体里面的变量和它外部环境的变量具有相同的语义（this关键字也是一样）。</p>\n<p>下面我们举个栗子吧!</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">HelloLambda</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    Runnable r1 = () -&gt; System.out.println(<span class=\"keyword\">this</span>);</div><div class=\"line\">    Runnable r2 = () -&gt; System.out.println(toString());</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"Hello, lambda!\"</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">new</span> HelloLambda().r1.run();  </div><div class=\"line\">        <span class=\"keyword\">new</span> HelloLambda().r2.run();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码最终会打印两个<code>Hello, lambda!</code>，与之相类似的内部类则会打印出类似<code>HelloLambda$1@32a890</code>和<code>HelloLambda$1@6b32098</code>这种出乎意料的字符串。</p>\n<p>总结：基于词法作用域的理念，lambda表达式不可以掩盖任何其所在上下文的局部变量。</p>\n<h2 id=\"四、变量捕获\"><a href=\"#四、变量捕获\" class=\"headerlink\" title=\"四、变量捕获\"></a>四、变量捕获</h2><p>在Java7中，编译器对内部类中引用的外部变量（即捕获的变量）要求非常严格：如果捕获的变量没有被声明为<code>final</code>就会产生一个编译错误。但是在Java8中放宽了这一限制–对于lambda表达式和内部类，允许在其中捕获那些符合有效只读的局部变量（如果一个局部变量在初始化后从未被修改过，那么它就是有效只读）。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\">Runnable <span class=\"title\">getRunnable</span><span class=\"params\">(String name)</span></span>&#123;</div><div class=\"line\">    String hello = <span class=\"string\">\"hello\"</span>;</div><div class=\"line\">    <span class=\"keyword\">return</span> () -&gt; System.out.println(hello+<span class=\"string\">\",\"</span>+name);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>对于<code>this</code>的引用以及通过<code>this</code>对未限定字段的引用和未限定方法的调用本质上都属于使用<code>final</code>局部变量。包含此类引用的lambda表达式相当于捕获了<code>this</code>实例。在其他情况下，lambda对象不会保留任何对<code>this</code>的应用。</p>\n<p>这个特性对内存管理是极好的：要知道在java中一个非静态内部类会默认持有外部类实例的强引用，这往往会造成内存泄露。而在lambda表达式中如果没有捕获外部类成员则不会保留对外部类实例的引用。</p>\n<p>不过尽管Java8放宽了对捕获变量的语法限制，但试图修改捕获变量的行为是被禁止的，比如下面这个例子就是非法的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">int</span> sum  = <span class=\"number\">0</span>;</div><div class=\"line\">list.forEach(i -&gt; &#123;sum += i;&#125;);</div></pre></td></tr></table></figure>\n<p>为什么要禁止这种行为呢？因为这样的lambda表达式很容易引起<a href=\"https://zh.wikipedia.org/zh-cn/%E7%AB%B6%E7%88%AD%E5%8D%B1%E5%AE%B3\">race condition</a></p>\n<p>lambda表达式不支持修改捕获变量的另外一个原因是我们可以使用更好的方式来实现同样的效果：使用规约(condition)。java.util.stream包提供了各种规约操作，关于Java8中的<code>Stream API</code>我们放到下一章介绍。</p>\n<h2 id=\"五、方法引用\"><a href=\"#五、方法引用\" class=\"headerlink\" title=\"五、方法引用\"></a>五、方法引用</h2><p>lambda表达式允许我们定义一个匿名方法，并以函数式接口的方式使用它。Java8能够在已有的方法上实现同样的特性。</p>\n<p>方法引用和lambda表达式拥有相同的特性（他们都需要一个目标类型，并且需要被转化为函数式接口的实例）,不过我们不需要为方法引用提供方法体，我们可以直接通过方法名引用已有方法。</p>\n<p>以下面的代码为例，假设我们要按照<code>userName</code>排序</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">User</span></span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">private</span> String userName;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getUserName</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> userName;</div><div class=\"line\">    &#125;</div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">List&lt;User&gt; users = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">Comparator&lt;User&gt; comparator = Comparator.comparing(u -&gt; u.getUserName());</div><div class=\"line\">Collections.sort(users, comparator);</div></pre></td></tr></table></figure>\n<p>我们可以用方法引用替换上面的lambda表达式</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">Comparator&lt;User&gt; comparator = Comparator.comparing(User::getUserName);</div></pre></td></tr></table></figure>\n<p>这里的<code>User::getUserName</code>被看做是lambda表达式的简写形式。尽管方法引用不一定会把代码变得更紧凑，但它拥有更明确的语义–如果我们想要调用的方法拥有一个名字，那么我们就可以通过方法名调用它。</p>\n<!--因为函数式接口的方法参数对应于隐式方法调用时的参数，所以被引用方法签名可以通过放宽类型，装箱以及组织到参数数组中的方式对其参数进行操作，就像在调用实际方法一样：\n\n    Consumer<Integer> b1 = System::exit;    // void exit(int status)\n    Consumer<String[]> b2 = Arrays:sort;    // void sort(Object[] a)\n    Consumer<String> b3 = MyProgram::main;  // void main(String... args)\n    Runnable r = Myprogram::mapToInt        // void main(String... args)-->\n<p>方法引用有很多种，它们的语法如下：</p>\n<ul>\n<li>静态方法引用：ClassName::methodName</li>\n<li>实例上的实例方法引用：instanceReference::methodName</li>\n<li>超类上的实例方法引用：super::methodName</li>\n<li>类型上的实例方法引用：ClassName::methodName</li>\n<li>构造方法引用：Class::new</li>\n<li>数组构造方法引用：TypeName[]::new</li>\n</ul>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"Java8新特性第2章(接口默认方法)","date":"2017-02-05T15:37:11.000Z","_content":"\n在Java中一个接口一旦发布就已经被定型，除非我们能够一次性的更新所有该接口的实现，否者在接口的添加新方法将会破坏现有接口的实现。默认方法就是为了解决这一问题的，这样接口在发布之后依然能够继续演化。\n\n默认方法就是向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或者是默认的。默认方法拥有默认实现，接口实现类通过继承得到该默认实现。默认方法不是抽象的，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口单抽象方法的限制。\n\n```java\npublic interface Iterator<E> {\n\n    boolean hasNext();\n\n    E next();\n\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n\n    default void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n\n和其他方法一样，默认方法也可以被继承。\n\n除了上面看到的默认方法，Java8中还允许我们在接口中定义静态方法。这使得我们可以从接口中直接调用它相关的辅助方法，而不是从其它的辅助类中调用（如Collections）。在做集合中元素比较的时候，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java8中我们可以直接把该静态方法定义在Comparator接口中：\n\n```java\npublic static <T, U extends Comparable<? super U>>\n    Comparator<T> comparing(Function<T, U> keyExtractor) {\n    return (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));\n}\n```\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n\n","source":"_posts/2017-02-05-Java8新特性第2章-接口默认方法.md","raw":"---\ntitle: Java8新特性第2章(接口默认方法)\ndate: 2017-02-05 23:37:11\ncategories: java\ntags: Java\n---\n\n在Java中一个接口一旦发布就已经被定型，除非我们能够一次性的更新所有该接口的实现，否者在接口的添加新方法将会破坏现有接口的实现。默认方法就是为了解决这一问题的，这样接口在发布之后依然能够继续演化。\n\n默认方法就是向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或者是默认的。默认方法拥有默认实现，接口实现类通过继承得到该默认实现。默认方法不是抽象的，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口单抽象方法的限制。\n\n```java\npublic interface Iterator<E> {\n\n    boolean hasNext();\n\n    E next();\n\n    default void remove() {\n        throw new UnsupportedOperationException(\"remove\");\n    }\n\n    default void forEachRemaining(Consumer<? super E> action) {\n        Objects.requireNonNull(action);\n        while (hasNext())\n            action.accept(next());\n    }\n}\n```\n\n和其他方法一样，默认方法也可以被继承。\n\n除了上面看到的默认方法，Java8中还允许我们在接口中定义静态方法。这使得我们可以从接口中直接调用它相关的辅助方法，而不是从其它的辅助类中调用（如Collections）。在做集合中元素比较的时候，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java8中我们可以直接把该静态方法定义在Comparator接口中：\n\n```java\npublic static <T, U extends Comparable<? super U>>\n    Comparator<T> comparing(Function<T, U> keyExtractor) {\n    return (c1, c2) -> keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));\n}\n```\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n\n","slug":"Java8新特性第2章-接口默认方法","published":1,"updated":"2017-02-05T16:02:39.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26dv00016st66hlb0qs1","content":"<p>在Java中一个接口一旦发布就已经被定型，除非我们能够一次性的更新所有该接口的实现，否者在接口的添加新方法将会破坏现有接口的实现。默认方法就是为了解决这一问题的，这样接口在发布之后依然能够继续演化。</p>\n<p>默认方法就是向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或者是默认的。默认方法拥有默认实现，接口实现类通过继承得到该默认实现。默认方法不是抽象的，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口单抽象方法的限制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">E <span class=\"title\">next</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"remove\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">forEachRemaining</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</div><div class=\"line\">        Objects.requireNonNull(action);</div><div class=\"line\">        <span class=\"keyword\">while</span> (hasNext())</div><div class=\"line\">            action.accept(next());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>和其他方法一样，默认方法也可以被继承。</p>\n<p>除了上面看到的默认方法，Java8中还允许我们在接口中定义静态方法。这使得我们可以从接口中直接调用它相关的辅助方法，而不是从其它的辅助类中调用（如Collections）。在做集合中元素比较的时候，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java8中我们可以直接把该静态方法定义在Comparator接口中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T, U extends Comparable&lt;? <span class=\"keyword\">super</span> U&gt;&gt;</div><div class=\"line\">    <span class=\"function\">Comparator&lt;T&gt; <span class=\"title\">comparing</span><span class=\"params\">(Function&lt;T, U&gt; keyExtractor)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<p>在Java中一个接口一旦发布就已经被定型，除非我们能够一次性的更新所有该接口的实现，否者在接口的添加新方法将会破坏现有接口的实现。默认方法就是为了解决这一问题的，这样接口在发布之后依然能够继续演化。</p>\n<p>默认方法就是向接口增加新的行为。它是一种新的方法：接口方法可以是抽象的或者是默认的。默认方法拥有默认实现，接口实现类通过继承得到该默认实现。默认方法不是抽象的，所以我们可以放心的向函数式接口里增加默认方法，而不用担心函数式接口单抽象方法的限制。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\">E <span class=\"title\">next</span><span class=\"params\">()</span></span>;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException(<span class=\"string\">\"remove\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">default</span> <span class=\"keyword\">void</span> <span class=\"title\">forEachRemaining</span><span class=\"params\">(Consumer&lt;? <span class=\"keyword\">super</span> E&gt; action)</span> </span>&#123;</div><div class=\"line\">        Objects.requireNonNull(action);</div><div class=\"line\">        <span class=\"keyword\">while</span> (hasNext())</div><div class=\"line\">            action.accept(next());</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>和其他方法一样，默认方法也可以被继承。</p>\n<p>除了上面看到的默认方法，Java8中还允许我们在接口中定义静态方法。这使得我们可以从接口中直接调用它相关的辅助方法，而不是从其它的辅助类中调用（如Collections）。在做集合中元素比较的时候，我们一般需要使用静态辅助方法生成实现Comparator的比较器，在Java8中我们可以直接把该静态方法定义在Comparator接口中：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T, U extends Comparable&lt;? <span class=\"keyword\">super</span> U&gt;&gt;</div><div class=\"line\">    <span class=\"function\">Comparator&lt;T&gt; <span class=\"title\">comparing</span><span class=\"params\">(Function&lt;T, U&gt; keyExtractor)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> (c1, c2) -&gt; keyExtractor.apply(c1).compareTo(keyExtractor.apply(c2));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"在Android项目中使用Java8","date":"2017-02-05T15:37:48.000Z","_content":"\n## 前言\n\n在过去的文章中我介绍过Java8的一些新特性，包括：\n\n1. [Java8新特性第1章\\(Lambda表达式\\)](https://zhuanlan.zhihu.com/p/20540175)\n2. [Java8新特性第2章\\(接口默认方法\\)](https://zhuanlan.zhihu.com/p/20540188)\n3. [Java8新特性第3章\\(Stream API\\)](https://zhuanlan.zhihu.com/p/20540202)\n\n之前由于Android平台不支持Java8，如果我们想在Android项目中使用Lambda表达式、Stream API等Java8中的新特性就必须使用Retrolambda、Lightweight-Stream-API等第三方开源库来实现。现在Google爸爸终于让Android平台支持Java8了，这篇文章中便来和大家聊聊如何在Android项目中配置使用Java8。\n\n遗憾的是目前Android平台仅支持Java8的部分新特性，当我们在开发面向Android N及以上版本的应用时(即minSdkVersion>=24)，可以使用如下新特性：\n\n* [Lambda表达式\\(Lambda Expressions\\)](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)（也可以在minSdkVersion<24的情况下使用）\n* [方法引用\\(Method References\\)](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)（也可以在minSdkVersion<24的情况下使用）\n* [Stream API\\(Streams\\)](http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html)\n* [接口默认方法\\(Default Methods\\)](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html) \n* [重复注解\\(Repeating Annotations\\)](https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html)\n\n简单的说就是现在你的项目要想使用Stream API、接口默认方法和重复注解就要求你的minSdkVersion>=24，而Lambda表达式和方法引用则对minSdkVersion无要求。关于这些新特的使用及分析可以看看我之前的文章。\n\n## Jack(Java Android Compiler Kit)\n\n要想在Android项目中使用Java8的新特性，需要将你的Android Studio升级到2.1及以上版本，并采用新的Jack(Java Android Compiler Kit)编译。新的 Android 工具链将 Java 源语言编译成 Android 可读取的 Dalvik 可执行文件字节码，且有其自己的 .jack 库格式，在一个工具中提供了大多数工具链功能：重新打包、压缩、模糊化以及 Dalvik 可执行文件分包。\n\n以下是构建 Android Dalvik 可执行文件可用的两种工具链的对比：\n\n* 旧版 javac 工具链：  \n  <font color=\"ff0000\"> `javac (.java --> .class) --> dx (.class --> .dex)` </font>\n* 新版 Jack 工具链：  \n  <font color=\"ff0000\"> `Jack (.java --> .jack --> .dex)` </font>\n\t\n## 配置\n\n为了在项目中使用Java8，我们还需要项目module中的gradle.build文件中加入如下代码：\n\n```Groovy\nandroid {\n\n  compileSdkVersion 24\n  buildToolsVersion \"24.0.3\"\n    \n  defaultConfig {\n    \n    applicationId \"me.baron.hellojava8\"\n    minSdkVersion 24\n    targetSdkVersion 24\n    versionCode 1\n    versionName \"1.0\"\n        \n    jackOptions {\n      enabled true\n    }\n  }\n  \n  compileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n  }\n}\n```\n\n## 使用\n\n进行上述配置后大家就可以在Android项目中尽情的探索使用Java8的新特性了。比如之前我们实现button的点击事件时需要这这样写：\n\n```java\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n\t\tv.setText(\"lalala\");\n   \t}\n});\n```\n\n现在我们便可以使用Java8的Lambda表达式来实现了：\n\n```java\nbutton.setOnClickListener(v -> v.setText(\"lalala\"));\n```\n\n如果你项目的minSdkVersion>=24，我们还可以使用Stream API。比方说有一个形状集合shapes，现在我们想把所有蓝色的形状提取到新的List里。通过Stream API则可以很轻易的办到：\n\n```java\nList<Shape> blue = shapes.stream()\n\t.filter(s -> s.getColor() == BLUE)\n\t.collect(Collectors.toList());\n```\n\n## 总结\n\nJava8的新特性并不是本文的重点，对此有兴趣的同学可以去翻看我之前的文章。当前Jack编译器还有诸多限制，比如在使用新的Jack工具链时会禁用Instant Run以及前面提到的新特性对我们的最低支持版本和编译版本有要求等等(我猜想Jack对Buck、Layoutcast、Freeline等编译方案也会有影响，没做过验证，有了解的同学可以在评论区留言和大家交流下)；总之要想在Android项目中愉快的使用Java8全部的新特性还需时日。期待Google爸爸尽快优化吧！\n\n参考资料：\n* [https://developer.android.com/guide/platform/j8-jack.html](https://developer.android.com/guide/platform/j8-jack.html)\n* [https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad](https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad)\n\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)","source":"_posts/2017-02-05-在Android项目中使用Java8.md","raw":"---\ntitle: 在Android项目中使用Java8\ndate: 2017-02-05 23:37:48\ncategories: java\ntags: \n- Java \n- Android\n---\n\n## 前言\n\n在过去的文章中我介绍过Java8的一些新特性，包括：\n\n1. [Java8新特性第1章\\(Lambda表达式\\)](https://zhuanlan.zhihu.com/p/20540175)\n2. [Java8新特性第2章\\(接口默认方法\\)](https://zhuanlan.zhihu.com/p/20540188)\n3. [Java8新特性第3章\\(Stream API\\)](https://zhuanlan.zhihu.com/p/20540202)\n\n之前由于Android平台不支持Java8，如果我们想在Android项目中使用Lambda表达式、Stream API等Java8中的新特性就必须使用Retrolambda、Lightweight-Stream-API等第三方开源库来实现。现在Google爸爸终于让Android平台支持Java8了，这篇文章中便来和大家聊聊如何在Android项目中配置使用Java8。\n\n遗憾的是目前Android平台仅支持Java8的部分新特性，当我们在开发面向Android N及以上版本的应用时(即minSdkVersion>=24)，可以使用如下新特性：\n\n* [Lambda表达式\\(Lambda Expressions\\)](https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html)（也可以在minSdkVersion<24的情况下使用）\n* [方法引用\\(Method References\\)](https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html)（也可以在minSdkVersion<24的情况下使用）\n* [Stream API\\(Streams\\)](http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html)\n* [接口默认方法\\(Default Methods\\)](https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html) \n* [重复注解\\(Repeating Annotations\\)](https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html)\n\n简单的说就是现在你的项目要想使用Stream API、接口默认方法和重复注解就要求你的minSdkVersion>=24，而Lambda表达式和方法引用则对minSdkVersion无要求。关于这些新特的使用及分析可以看看我之前的文章。\n\n## Jack(Java Android Compiler Kit)\n\n要想在Android项目中使用Java8的新特性，需要将你的Android Studio升级到2.1及以上版本，并采用新的Jack(Java Android Compiler Kit)编译。新的 Android 工具链将 Java 源语言编译成 Android 可读取的 Dalvik 可执行文件字节码，且有其自己的 .jack 库格式，在一个工具中提供了大多数工具链功能：重新打包、压缩、模糊化以及 Dalvik 可执行文件分包。\n\n以下是构建 Android Dalvik 可执行文件可用的两种工具链的对比：\n\n* 旧版 javac 工具链：  \n  <font color=\"ff0000\"> `javac (.java --> .class) --> dx (.class --> .dex)` </font>\n* 新版 Jack 工具链：  \n  <font color=\"ff0000\"> `Jack (.java --> .jack --> .dex)` </font>\n\t\n## 配置\n\n为了在项目中使用Java8，我们还需要项目module中的gradle.build文件中加入如下代码：\n\n```Groovy\nandroid {\n\n  compileSdkVersion 24\n  buildToolsVersion \"24.0.3\"\n    \n  defaultConfig {\n    \n    applicationId \"me.baron.hellojava8\"\n    minSdkVersion 24\n    targetSdkVersion 24\n    versionCode 1\n    versionName \"1.0\"\n        \n    jackOptions {\n      enabled true\n    }\n  }\n  \n  compileOptions {\n    sourceCompatibility JavaVersion.VERSION_1_8\n    targetCompatibility JavaVersion.VERSION_1_8\n  }\n}\n```\n\n## 使用\n\n进行上述配置后大家就可以在Android项目中尽情的探索使用Java8的新特性了。比如之前我们实现button的点击事件时需要这这样写：\n\n```java\nbutton.setOnClickListener(new View.OnClickListener() {\n    @Override\n    public void onClick(View v) {\n\t\tv.setText(\"lalala\");\n   \t}\n});\n```\n\n现在我们便可以使用Java8的Lambda表达式来实现了：\n\n```java\nbutton.setOnClickListener(v -> v.setText(\"lalala\"));\n```\n\n如果你项目的minSdkVersion>=24，我们还可以使用Stream API。比方说有一个形状集合shapes，现在我们想把所有蓝色的形状提取到新的List里。通过Stream API则可以很轻易的办到：\n\n```java\nList<Shape> blue = shapes.stream()\n\t.filter(s -> s.getColor() == BLUE)\n\t.collect(Collectors.toList());\n```\n\n## 总结\n\nJava8的新特性并不是本文的重点，对此有兴趣的同学可以去翻看我之前的文章。当前Jack编译器还有诸多限制，比如在使用新的Jack工具链时会禁用Instant Run以及前面提到的新特性对我们的最低支持版本和编译版本有要求等等(我猜想Jack对Buck、Layoutcast、Freeline等编译方案也会有影响，没做过验证，有了解的同学可以在评论区留言和大家交流下)；总之要想在Android项目中愉快的使用Java8全部的新特性还需时日。期待Google爸爸尽快优化吧！\n\n参考资料：\n* [https://developer.android.com/guide/platform/j8-jack.html](https://developer.android.com/guide/platform/j8-jack.html)\n* [https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad](https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad)\n\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)","slug":"在Android项目中使用Java8","published":1,"updated":"2017-02-05T16:07:46.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26ea00046st6muzn2f69","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在过去的文章中我介绍过Java8的一些新特性，包括：</p>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20540175\" target=\"_blank\" rel=\"external\">Java8新特性第1章(Lambda表达式)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20540188\" target=\"_blank\" rel=\"external\">Java8新特性第2章(接口默认方法)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20540202\" target=\"_blank\" rel=\"external\">Java8新特性第3章(Stream API)</a></li>\n</ol>\n<p>之前由于Android平台不支持Java8，如果我们想在Android项目中使用Lambda表达式、Stream API等Java8中的新特性就必须使用Retrolambda、Lightweight-Stream-API等第三方开源库来实现。现在Google爸爸终于让Android平台支持Java8了，这篇文章中便来和大家聊聊如何在Android项目中配置使用Java8。</p>\n<p>遗憾的是目前Android平台仅支持Java8的部分新特性，当我们在开发面向Android N及以上版本的应用时(即minSdkVersion&gt;=24)，可以使用如下新特性：</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\" target=\"_blank\" rel=\"external\">Lambda表达式(Lambda Expressions)</a>（也可以在minSdkVersion&lt;24的情况下使用）</li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html\" target=\"_blank\" rel=\"external\">方法引用(Method References)</a>（也可以在minSdkVersion&lt;24的情况下使用）</li>\n<li><a href=\"http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html\" target=\"_blank\" rel=\"external\">Stream API(Streams)</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html\" target=\"_blank\" rel=\"external\">接口默认方法(Default Methods)</a> </li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html\" target=\"_blank\" rel=\"external\">重复注解(Repeating Annotations)</a></li>\n</ul>\n<p>简单的说就是现在你的项目要想使用Stream API、接口默认方法和重复注解就要求你的minSdkVersion&gt;=24，而Lambda表达式和方法引用则对minSdkVersion无要求。关于这些新特的使用及分析可以看看我之前的文章。</p>\n<h2 id=\"Jack-Java-Android-Compiler-Kit\"><a href=\"#Jack-Java-Android-Compiler-Kit\" class=\"headerlink\" title=\"Jack(Java Android Compiler Kit)\"></a>Jack(Java Android Compiler Kit)</h2><p>要想在Android项目中使用Java8的新特性，需要将你的Android Studio升级到2.1及以上版本，并采用新的Jack(Java Android Compiler Kit)编译。新的 Android 工具链将 Java 源语言编译成 Android 可读取的 Dalvik 可执行文件字节码，且有其自己的 .jack 库格式，在一个工具中提供了大多数工具链功能：重新打包、压缩、模糊化以及 Dalvik 可执行文件分包。</p>\n<p>以下是构建 Android Dalvik 可执行文件可用的两种工具链的对比：</p>\n<ul>\n<li>旧版 javac 工具链：  <font color=\"ff0000\"> <code>javac (.java --&gt; .class) --&gt; dx (.class --&gt; .dex)</code> </font></li>\n<li>新版 Jack 工具链：  <font color=\"ff0000\"> <code>Jack (.java --&gt; .jack --&gt; .dex)</code> </font>\n\n</li>\n</ul>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>为了在项目中使用Java8，我们还需要项目module中的gradle.build文件中加入如下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\"></div><div class=\"line\">  compileSdkVersion <span class=\"number\">24</span></div><div class=\"line\">  buildToolsVersion <span class=\"string\">\"24.0.3\"</span></div><div class=\"line\">    </div><div class=\"line\">  defaultConfig &#123;</div><div class=\"line\">    </div><div class=\"line\">    applicationId <span class=\"string\">\"me.baron.hellojava8\"</span></div><div class=\"line\">    minSdkVersion <span class=\"number\">24</span></div><div class=\"line\">    targetSdkVersion <span class=\"number\">24</span></div><div class=\"line\">    versionCode <span class=\"number\">1</span></div><div class=\"line\">    versionName <span class=\"string\">\"1.0\"</span></div><div class=\"line\">        </div><div class=\"line\">    jackOptions &#123;</div><div class=\"line\">      enabled <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  compileOptions &#123;</div><div class=\"line\">    sourceCompatibility JavaVersion.VERSION_1_8</div><div class=\"line\">    targetCompatibility JavaVersion.VERSION_1_8</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>进行上述配置后大家就可以在Android项目中尽情的探索使用Java8的新特性了。比如之前我们实现button的点击事件时需要这这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">\t\tv.setText(<span class=\"string\">\"lalala\"</span>);</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在我们便可以使用Java8的Lambda表达式来实现了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.setOnClickListener(v -&gt; v.setText(<span class=\"string\">\"lalala\"</span>));</div></pre></td></tr></table></figure>\n<p>如果你项目的minSdkVersion&gt;=24，我们还可以使用Stream API。比方说有一个形状集合shapes，现在我们想把所有蓝色的形状提取到新的List里。通过Stream API则可以很轻易的办到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;Shape&gt; blue = shapes.stream()</div><div class=\"line\">\t.filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">\t.collect(Collectors.toList());</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Java8的新特性并不是本文的重点，对此有兴趣的同学可以去翻看我之前的文章。当前Jack编译器还有诸多限制，比如在使用新的Jack工具链时会禁用Instant Run以及前面提到的新特性对我们的最低支持版本和编译版本有要求等等(我猜想Jack对Buck、Layoutcast、Freeline等编译方案也会有影响，没做过验证，有了解的同学可以在评论区留言和大家交流下)；总之要想在Android项目中愉快的使用Java8全部的新特性还需时日。期待Google爸爸尽快优化吧！</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/guide/platform/j8-jack.html\" target=\"_blank\" rel=\"external\">https://developer.android.com/guide/platform/j8-jack.html</a></li>\n<li><a href=\"https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad\" target=\"_blank\" rel=\"external\">https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad</a></li>\n</ul>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>在过去的文章中我介绍过Java8的一些新特性，包括：</p>\n<ol>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20540175\">Java8新特性第1章(Lambda表达式)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20540188\">Java8新特性第2章(接口默认方法)</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/20540202\">Java8新特性第3章(Stream API)</a></li>\n</ol>\n<p>之前由于Android平台不支持Java8，如果我们想在Android项目中使用Lambda表达式、Stream API等Java8中的新特性就必须使用Retrolambda、Lightweight-Stream-API等第三方开源库来实现。现在Google爸爸终于让Android平台支持Java8了，这篇文章中便来和大家聊聊如何在Android项目中配置使用Java8。</p>\n<p>遗憾的是目前Android平台仅支持Java8的部分新特性，当我们在开发面向Android N及以上版本的应用时(即minSdkVersion&gt;=24)，可以使用如下新特性：</p>\n<ul>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\">Lambda表达式(Lambda Expressions)</a>（也可以在minSdkVersion&lt;24的情况下使用）</li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html\">方法引用(Method References)</a>（也可以在minSdkVersion&lt;24的情况下使用）</li>\n<li><a href=\"http://www.oracle.com/technetwork/articles/java/ma14-java-se-8-streams-2177646.html\">Stream API(Streams)</a></li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html\">接口默认方法(Default Methods)</a> </li>\n<li><a href=\"https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html\">重复注解(Repeating Annotations)</a></li>\n</ul>\n<p>简单的说就是现在你的项目要想使用Stream API、接口默认方法和重复注解就要求你的minSdkVersion&gt;=24，而Lambda表达式和方法引用则对minSdkVersion无要求。关于这些新特的使用及分析可以看看我之前的文章。</p>\n<h2 id=\"Jack-Java-Android-Compiler-Kit\"><a href=\"#Jack-Java-Android-Compiler-Kit\" class=\"headerlink\" title=\"Jack(Java Android Compiler Kit)\"></a>Jack(Java Android Compiler Kit)</h2><p>要想在Android项目中使用Java8的新特性，需要将你的Android Studio升级到2.1及以上版本，并采用新的Jack(Java Android Compiler Kit)编译。新的 Android 工具链将 Java 源语言编译成 Android 可读取的 Dalvik 可执行文件字节码，且有其自己的 .jack 库格式，在一个工具中提供了大多数工具链功能：重新打包、压缩、模糊化以及 Dalvik 可执行文件分包。</p>\n<p>以下是构建 Android Dalvik 可执行文件可用的两种工具链的对比：</p>\n<ul>\n<li>旧版 javac 工具链：  <font color=\"ff0000\"> <code>javac (.java --&gt; .class) --&gt; dx (.class --&gt; .dex)</code> </font></li>\n<li>新版 Jack 工具链：  <font color=\"ff0000\"> <code>Jack (.java --&gt; .jack --&gt; .dex)</code> </font>\n\n</li>\n</ul>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><p>为了在项目中使用Java8，我们还需要项目module中的gradle.build文件中加入如下代码：</p>\n<figure class=\"highlight groovy\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">android &#123;</div><div class=\"line\"></div><div class=\"line\">  compileSdkVersion <span class=\"number\">24</span></div><div class=\"line\">  buildToolsVersion <span class=\"string\">\"24.0.3\"</span></div><div class=\"line\">    </div><div class=\"line\">  defaultConfig &#123;</div><div class=\"line\">    </div><div class=\"line\">    applicationId <span class=\"string\">\"me.baron.hellojava8\"</span></div><div class=\"line\">    minSdkVersion <span class=\"number\">24</span></div><div class=\"line\">    targetSdkVersion <span class=\"number\">24</span></div><div class=\"line\">    versionCode <span class=\"number\">1</span></div><div class=\"line\">    versionName <span class=\"string\">\"1.0\"</span></div><div class=\"line\">        </div><div class=\"line\">    jackOptions &#123;</div><div class=\"line\">      enabled <span class=\"literal\">true</span></div><div class=\"line\">    &#125;</div><div class=\"line\">  &#125;</div><div class=\"line\">  </div><div class=\"line\">  compileOptions &#123;</div><div class=\"line\">    sourceCompatibility JavaVersion.VERSION_1_8</div><div class=\"line\">    targetCompatibility JavaVersion.VERSION_1_8</div><div class=\"line\">  &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><p>进行上述配置后大家就可以在Android项目中尽情的探索使用Java8的新特性了。比如之前我们实现button的点击事件时需要这这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.setOnClickListener(<span class=\"keyword\">new</span> View.OnClickListener() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onClick</span><span class=\"params\">(View v)</span> </span>&#123;</div><div class=\"line\">\t\tv.setText(<span class=\"string\">\"lalala\"</span>);</div><div class=\"line\">   \t&#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>现在我们便可以使用Java8的Lambda表达式来实现了：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">button.setOnClickListener(v -&gt; v.setText(<span class=\"string\">\"lalala\"</span>));</div></pre></td></tr></table></figure>\n<p>如果你项目的minSdkVersion&gt;=24，我们还可以使用Stream API。比方说有一个形状集合shapes，现在我们想把所有蓝色的形状提取到新的List里。通过Stream API则可以很轻易的办到：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;Shape&gt; blue = shapes.stream()</div><div class=\"line\">\t.filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">\t.collect(Collectors.toList());</div></pre></td></tr></table></figure>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>Java8的新特性并不是本文的重点，对此有兴趣的同学可以去翻看我之前的文章。当前Jack编译器还有诸多限制，比如在使用新的Jack工具链时会禁用Instant Run以及前面提到的新特性对我们的最低支持版本和编译版本有要求等等(我猜想Jack对Buck、Layoutcast、Freeline等编译方案也会有影响，没做过验证，有了解的同学可以在评论区留言和大家交流下)；总之要想在Android项目中愉快的使用Java8全部的新特性还需时日。期待Google爸爸尽快优化吧！</p>\n<p>参考资料：</p>\n<ul>\n<li><a href=\"https://developer.android.com/guide/platform/j8-jack.html\">https://developer.android.com/guide/platform/j8-jack.html</a></li>\n<li><a href=\"https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad\">https://medium.com/@sergii/java-8-in-android-n-preview-76184e2ab7ad</a></li>\n</ul>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"Java8新特性第3章(Stream API)","date":"2017-02-05T15:37:32.000Z","_content":"\nStream作为Java8的新特性之一，他与Java IO包中的InputStream和OutputStream完全不是一个概念。Java8中的Stream是对集合功能的一种增强，主要用于对集合对象进行各种非常便利高效的聚合和大批量数据的操作。结合Lambda表达式可以极大的提高开发效率和代码可读性。\n\n假设我们需要把一个集合中的所有形状设置成红色，那么我们可以这样写\n\n```java\nfor (Shape shape : shapes){\n\tshape.setColor(RED)\n}\n```\n\t\n如果使用Java8扩展后的集合框架则可以这样写：\n\n```java\nshapes.foreach(s -> s.setColor(RED));\n```\n\n__第一种__写法我们叫外部迭代，for-each调用`shapes`的`iterator()`依次遍历集合中的元素。这种外部迭代有一些问题：\n\n* for循环是串行的，而且必须按照集合中元素的顺序依次进行；\n* 集合框架无法对控制流进行优化，例如通过排序、并行、短路求值以及惰性求值改善性能。\n> 上面这两个问题我们会在后面的文章中逐步解答。\n\t\n__第二种__写法我们叫内部迭代，两段代码虽然看起来只是语法上的区别，但实际上他们内部的区别其实非常大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。\n\n外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历），而内部迭代只负责做什么，而把怎么做留给类库。这样代码会变得更加清晰，而集合类库则可以在内部进行各种优化。\n\n\n## 一、什么是Stream\nStream不是集合元素，它也不是数据结构、不能保存数据，它更像一个更高级的`Interator`。Stream提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。流的操作可以被组合成流水线（Pipeline）。拿前面的例子来说，如果我只想把蓝色改成红色：\n\n```java\nshapes.stream()\n      .filter(s -> s.getColor() == BLUE)\n      .forEach(s -> s.setColor(RED));\n```\n\n在`Collection`上调用`stream()`会生成该集合元素的流，接下来`filter()`操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被`forEach`操作设为红色。\n\n如果我们想把蓝色的形状提取到新的List里，则可以：\n\n```java\nList<Shape> blue = shapes.stream()\n\t\t\t\t\t\t  .filter(s -> s.getColor() == BLUE)\n\t\t\t\t\t\t  .collect(Collectors.toList());\n```\n\n`collect()`操作会把其接收的元素聚集到一起（这里是List），`collect()`方法的参数则被用来指定如何进行聚集操作。在这里我们使用`toList()`以把元素输出到List中。\n\n如果每个形状都被保存在`Box`里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：\n\n```java\nSet<Box> hasBlueShape = shapes.stream()\n                               .filter(s -> s.getColor() == BLUE)\n                              .map(s -> s.getContainingBox())\n                              .collect(Collectors.toSet());\n```\n                                  \n`map()`操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。\n\n如果我们需要得到蓝色物体的总重量，我们可以这样表达：\n\n```java\nint sum = shapes.stream()\n                .filter(s -> s.getColor() == BLUE)\n                .mapToInt(s -> s.getWeight())\n                .sum();\n```            \n\n## 二、Stream vs Collection\n流（Stream）和集合（Collection）的区别：\n\n* Collection主要用来对元素进行管理和访问；\n* Stream并不支持对其元素进行直接操作和直接访问，而只支持通过声明式操作在其之上进行运算后得到结果；\n* Stream不存储值\n* 对Stream的操作会产生一个结果，但是Stream并不会改变数据源；\n* 大多数Stream的操作(filter,map,sort等)都是以惰性的方式实现的。这使得我们可以使用一次遍历完成整个流水线操作,并可以用短路操作提供更高效的实现。\n\n## 三、惰性求值 vs 急性求值\n`filter()`和`map()`这样的操作既可以被急性求值（以`filter()`为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被惰性求值（用`Stream`代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）\n\n对于`filter()`和`map()`这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像`sum()`这样生成值的操作和`forEach()`这样产生副作用的操作都是__天然急性求值__，因为它们必须要产生具体的结果。\n\n我们拿下面这段代码举例：\n\n```java\nint sum = shapes.stream()\n                .filter(s -> s.getColor() == BLUE)\n                .mapToInt(s -> s.getWeight())\n                .sum();\n```                \n                    \n这里的`filter()`和`map()`都是惰性的，这就意味着在调用`sum()`之前不会从数据源中提取任何元素。在`sum()`操作之后才会把`filter()`、`map()`和`sum()`放在对数据源一次遍历中。这样可以大大减少维持中间结果所带来的开销。\n\n<!--####6.流水线(Pipeline)的并行操作\n流水线可以是串行的也可以是并行的，串行和并行是流的属性。默认情况下数据源返回的都是串行流，但是我们可以通过`parallel()`将串行流转换为并行流,就像下面这样：\n\n\tint sum = shapes.parallelStream()\n                .filter(s -> s.getColor = BLUE)\n                .mapToInt(s -> s.getWeight())\n                .sum();\n那么，串行流和并行流有什么区别呢？\n\n流的数据源可能是一个可变集合，如果当我们在遍历流时数据源被改变了，那么就会产生干扰。所以在进行流操作的时候，数据源应该保持不变。如果在单线程模型下，我们只需要保证lambda表达式不修改流的数据源就OK了；但如果是多线程环境，lambda在执行时可能会同时运行在多个线程上-->\n\n## 四、举个栗子🌰\n前面长篇大论的介绍概念实在太枯燥，为了方便大家理解我们用Streams API来实现一个具体的业务场景。\n\n假设我们有一个房源库项目，这个房源库中有一系列的小区，每个小区都有小区名和房源列表，每套房子又有价格、面积等属性。现在我们需要筛选出含有100平米以上房源的小区，并按照小区名排序。\n\n我们先来看看不用Streams API如何实现：\n\n```java\nList<Community> result = new ArrayList<>();\nfor (Community community : communities) {\n        for (House house : community.houses) {\n            if (house.area > 100) {\n                result.add(community);\n                break;\n            }\n        }\n    }\n    Collections.sort(result, new Comparator<Community>() {\n        @Override\n        public int compare(Community c1, Community c2) {\n            return c1.name.compareTo(c2.name);\n        }\n    });\n    return result;      \n```\n       \n如果使用Streams API:\n\n```java\nreturn communities.stream()\n          .filter(c -> c.houses.stream().anyMatch(h -> h.area>100))\n          .sorted(Comparator.comparing(c -> c.name))\n          .collect(Collectors.toList());\n```\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","source":"_posts/2017-02-05-Java8新特性第3章-Stream-API.md","raw":"---\ntitle: Java8新特性第3章(Stream API)\ndate: 2017-02-05 23:37:32\ncategories: java\ntags: Java\n---\n\nStream作为Java8的新特性之一，他与Java IO包中的InputStream和OutputStream完全不是一个概念。Java8中的Stream是对集合功能的一种增强，主要用于对集合对象进行各种非常便利高效的聚合和大批量数据的操作。结合Lambda表达式可以极大的提高开发效率和代码可读性。\n\n假设我们需要把一个集合中的所有形状设置成红色，那么我们可以这样写\n\n```java\nfor (Shape shape : shapes){\n\tshape.setColor(RED)\n}\n```\n\t\n如果使用Java8扩展后的集合框架则可以这样写：\n\n```java\nshapes.foreach(s -> s.setColor(RED));\n```\n\n__第一种__写法我们叫外部迭代，for-each调用`shapes`的`iterator()`依次遍历集合中的元素。这种外部迭代有一些问题：\n\n* for循环是串行的，而且必须按照集合中元素的顺序依次进行；\n* 集合框架无法对控制流进行优化，例如通过排序、并行、短路求值以及惰性求值改善性能。\n> 上面这两个问题我们会在后面的文章中逐步解答。\n\t\n__第二种__写法我们叫内部迭代，两段代码虽然看起来只是语法上的区别，但实际上他们内部的区别其实非常大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。\n\n外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历），而内部迭代只负责做什么，而把怎么做留给类库。这样代码会变得更加清晰，而集合类库则可以在内部进行各种优化。\n\n\n## 一、什么是Stream\nStream不是集合元素，它也不是数据结构、不能保存数据，它更像一个更高级的`Interator`。Stream提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。流的操作可以被组合成流水线（Pipeline）。拿前面的例子来说，如果我只想把蓝色改成红色：\n\n```java\nshapes.stream()\n      .filter(s -> s.getColor() == BLUE)\n      .forEach(s -> s.setColor(RED));\n```\n\n在`Collection`上调用`stream()`会生成该集合元素的流，接下来`filter()`操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被`forEach`操作设为红色。\n\n如果我们想把蓝色的形状提取到新的List里，则可以：\n\n```java\nList<Shape> blue = shapes.stream()\n\t\t\t\t\t\t  .filter(s -> s.getColor() == BLUE)\n\t\t\t\t\t\t  .collect(Collectors.toList());\n```\n\n`collect()`操作会把其接收的元素聚集到一起（这里是List），`collect()`方法的参数则被用来指定如何进行聚集操作。在这里我们使用`toList()`以把元素输出到List中。\n\n如果每个形状都被保存在`Box`里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：\n\n```java\nSet<Box> hasBlueShape = shapes.stream()\n                               .filter(s -> s.getColor() == BLUE)\n                              .map(s -> s.getContainingBox())\n                              .collect(Collectors.toSet());\n```\n                                  \n`map()`操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。\n\n如果我们需要得到蓝色物体的总重量，我们可以这样表达：\n\n```java\nint sum = shapes.stream()\n                .filter(s -> s.getColor() == BLUE)\n                .mapToInt(s -> s.getWeight())\n                .sum();\n```            \n\n## 二、Stream vs Collection\n流（Stream）和集合（Collection）的区别：\n\n* Collection主要用来对元素进行管理和访问；\n* Stream并不支持对其元素进行直接操作和直接访问，而只支持通过声明式操作在其之上进行运算后得到结果；\n* Stream不存储值\n* 对Stream的操作会产生一个结果，但是Stream并不会改变数据源；\n* 大多数Stream的操作(filter,map,sort等)都是以惰性的方式实现的。这使得我们可以使用一次遍历完成整个流水线操作,并可以用短路操作提供更高效的实现。\n\n## 三、惰性求值 vs 急性求值\n`filter()`和`map()`这样的操作既可以被急性求值（以`filter()`为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被惰性求值（用`Stream`代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）\n\n对于`filter()`和`map()`这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像`sum()`这样生成值的操作和`forEach()`这样产生副作用的操作都是__天然急性求值__，因为它们必须要产生具体的结果。\n\n我们拿下面这段代码举例：\n\n```java\nint sum = shapes.stream()\n                .filter(s -> s.getColor() == BLUE)\n                .mapToInt(s -> s.getWeight())\n                .sum();\n```                \n                    \n这里的`filter()`和`map()`都是惰性的，这就意味着在调用`sum()`之前不会从数据源中提取任何元素。在`sum()`操作之后才会把`filter()`、`map()`和`sum()`放在对数据源一次遍历中。这样可以大大减少维持中间结果所带来的开销。\n\n<!--####6.流水线(Pipeline)的并行操作\n流水线可以是串行的也可以是并行的，串行和并行是流的属性。默认情况下数据源返回的都是串行流，但是我们可以通过`parallel()`将串行流转换为并行流,就像下面这样：\n\n\tint sum = shapes.parallelStream()\n                .filter(s -> s.getColor = BLUE)\n                .mapToInt(s -> s.getWeight())\n                .sum();\n那么，串行流和并行流有什么区别呢？\n\n流的数据源可能是一个可变集合，如果当我们在遍历流时数据源被改变了，那么就会产生干扰。所以在进行流操作的时候，数据源应该保持不变。如果在单线程模型下，我们只需要保证lambda表达式不修改流的数据源就OK了；但如果是多线程环境，lambda在执行时可能会同时运行在多个线程上-->\n\n## 四、举个栗子🌰\n前面长篇大论的介绍概念实在太枯燥，为了方便大家理解我们用Streams API来实现一个具体的业务场景。\n\n假设我们有一个房源库项目，这个房源库中有一系列的小区，每个小区都有小区名和房源列表，每套房子又有价格、面积等属性。现在我们需要筛选出含有100平米以上房源的小区，并按照小区名排序。\n\n我们先来看看不用Streams API如何实现：\n\n```java\nList<Community> result = new ArrayList<>();\nfor (Community community : communities) {\n        for (House house : community.houses) {\n            if (house.area > 100) {\n                result.add(community);\n                break;\n            }\n        }\n    }\n    Collections.sort(result, new Comparator<Community>() {\n        @Override\n        public int compare(Community c1, Community c2) {\n            return c1.name.compareTo(c2.name);\n        }\n    });\n    return result;      \n```\n       \n如果使用Streams API:\n\n```java\nreturn communities.stream()\n          .filter(c -> c.houses.stream().anyMatch(h -> h.area>100))\n          .sorted(Comparator.comparing(c -> c.name))\n          .collect(Collectors.toList());\n```\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","slug":"Java8新特性第3章-Stream-API","published":1,"updated":"2017-02-05T16:02:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26eb00056st6uevra1lh","content":"<p>Stream作为Java8的新特性之一，他与Java IO包中的InputStream和OutputStream完全不是一个概念。Java8中的Stream是对集合功能的一种增强，主要用于对集合对象进行各种非常便利高效的聚合和大批量数据的操作。结合Lambda表达式可以极大的提高开发效率和代码可读性。</p>\n<p>假设我们需要把一个集合中的所有形状设置成红色，那么我们可以这样写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (Shape shape : shapes)&#123;</div><div class=\"line\">\tshape.setColor(RED)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果使用Java8扩展后的集合框架则可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">shapes.foreach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure>\n<p><strong>第一种</strong>写法我们叫外部迭代，for-each调用<code>shapes</code>的<code>iterator()</code>依次遍历集合中的元素。这种外部迭代有一些问题：</p>\n<ul>\n<li>for循环是串行的，而且必须按照集合中元素的顺序依次进行；</li>\n<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路求值以及惰性求值改善性能。<blockquote>\n<p>上面这两个问题我们会在后面的文章中逐步解答。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>第二种</strong>写法我们叫内部迭代，两段代码虽然看起来只是语法上的区别，但实际上他们内部的区别其实非常大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>\n<p>外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历），而内部迭代只负责做什么，而把怎么做留给类库。这样代码会变得更加清晰，而集合类库则可以在内部进行各种优化。</p>\n<h2 id=\"一、什么是Stream\"><a href=\"#一、什么是Stream\" class=\"headerlink\" title=\"一、什么是Stream\"></a>一、什么是Stream</h2><p>Stream不是集合元素，它也不是数据结构、不能保存数据，它更像一个更高级的<code>Interator</code>。Stream提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。流的操作可以被组合成流水线（Pipeline）。拿前面的例子来说，如果我只想把蓝色改成红色：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">shapes.stream()</div><div class=\"line\">      .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">      .forEach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure>\n<p>在<code>Collection</code>上调用<code>stream()</code>会生成该集合元素的流，接下来<code>filter()</code>操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被<code>forEach</code>操作设为红色。</p>\n<p>如果我们想把蓝色的形状提取到新的List里，则可以：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;Shape&gt; blue = shapes.stream()</div><div class=\"line\">\t\t\t\t\t\t  .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">\t\t\t\t\t\t  .collect(Collectors.toList());</div></pre></td></tr></table></figure>\n<p><code>collect()</code>操作会把其接收的元素聚集到一起（这里是List），<code>collect()</code>方法的参数则被用来指定如何进行聚集操作。在这里我们使用<code>toList()</code>以把元素输出到List中。</p>\n<p>如果每个形状都被保存在<code>Box</code>里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Set&lt;Box&gt; hasBlueShape = shapes.stream()</div><div class=\"line\">                               .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">                              .map(s -&gt; s.getContainingBox())</div><div class=\"line\">                              .collect(Collectors.toSet());</div></pre></td></tr></table></figure>\n<p><code>map()</code>操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>\n<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = shapes.stream()</div><div class=\"line\">                .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">                .mapToInt(s -&gt; s.getWeight())</div><div class=\"line\">                .sum();</div><div class=\"line\">```            </div><div class=\"line\"></div><div class=\"line\">## 二、Stream vs Collection</div><div class=\"line\">流（Stream）和集合（Collection）的区别：</div><div class=\"line\"></div><div class=\"line\">* Collection主要用来对元素进行管理和访问；</div><div class=\"line\">* Stream并不支持对其元素进行直接操作和直接访问，而只支持通过声明式操作在其之上进行运算后得到结果；</div><div class=\"line\">* Stream不存储值</div><div class=\"line\">* 对Stream的操作会产生一个结果，但是Stream并不会改变数据源；</div><div class=\"line\">* 大多数Stream的操作(filter,map,sort等)都是以惰性的方式实现的。这使得我们可以使用一次遍历完成整个流水线操作,并可以用短路操作提供更高效的实现。</div><div class=\"line\"></div><div class=\"line\">## 三、惰性求值 vs 急性求值</div><div class=\"line\">`filter()`和`map()`这样的操作既可以被急性求值（以`filter()`为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被惰性求值（用`Stream`代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）</div><div class=\"line\"></div><div class=\"line\">对于`filter()`和`map()`这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像`sum()`这样生成值的操作和`forEach()`这样产生副作用的操作都是__天然急性求值__，因为它们必须要产生具体的结果。</div><div class=\"line\"></div><div class=\"line\">我们拿下面这段代码举例：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">int sum = shapes.stream()</div><div class=\"line\">                .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">                .mapToInt(s -&gt; s.getWeight())</div><div class=\"line\">                .sum();</div><div class=\"line\">```                </div><div class=\"line\">                    </div><div class=\"line\">这里的`filter()`和`map()`都是惰性的，这就意味着在调用`sum()`之前不会从数据源中提取任何元素。在`sum()`操作之后才会把`filter()`、`map()`和`sum()`放在对数据源一次遍历中。这样可以大大减少维持中间结果所带来的开销。</div><div class=\"line\"></div><div class=\"line\">&lt;!--####6.流水线(Pipeline)的并行操作</div><div class=\"line\">流水线可以是串行的也可以是并行的，串行和并行是流的属性。默认情况下数据源返回的都是串行流，但是我们可以通过`parallel()`将串行流转换为并行流,就像下面这样：</div><div class=\"line\"></div><div class=\"line\">\tint sum = shapes.parallelStream()</div><div class=\"line\">                .filter(s -&gt; s.getColor = BLUE)</div><div class=\"line\">                .mapToInt(s -&gt; s.getWeight())</div><div class=\"line\">                .sum();</div><div class=\"line\">那么，串行流和并行流有什么区别呢？</div><div class=\"line\"></div><div class=\"line\">流的数据源可能是一个可变集合，如果当我们在遍历流时数据源被改变了，那么就会产生干扰。所以在进行流操作的时候，数据源应该保持不变。如果在单线程模型下，我们只需要保证lambda表达式不修改流的数据源就OK了；但如果是多线程环境，lambda在执行时可能会同时运行在多个线程上--&gt;</div><div class=\"line\"></div><div class=\"line\">## 四、举个栗子🌰</div><div class=\"line\">前面长篇大论的介绍概念实在太枯燥，为了方便大家理解我们用Streams API来实现一个具体的业务场景。</div><div class=\"line\"></div><div class=\"line\">假设我们有一个房源库项目，这个房源库中有一系列的小区，每个小区都有小区名和房源列表，每套房子又有价格、面积等属性。现在我们需要筛选出含有100平米以上房源的小区，并按照小区名排序。</div><div class=\"line\"></div><div class=\"line\">我们先来看看不用Streams API如何实现：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">List&lt;Community&gt; result = new ArrayList&lt;&gt;();</div><div class=\"line\">for (Community community : communities) &#123;</div><div class=\"line\">        for (House house : community.houses) &#123;</div><div class=\"line\">            if (house.area &gt; 100) &#123;</div><div class=\"line\">                result.add(community);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Collections.sort(result, new Comparator&lt;Community&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public int compare(Community c1, Community c2) &#123;</div><div class=\"line\">            return c1.name.compareTo(c2.name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return result;</div></pre></td></tr></table></figure>\n<p>如果使用Streams API:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> communities.stream()</div><div class=\"line\">          .filter(c -&gt; c.houses.stream().anyMatch(h -&gt; h.area&gt;<span class=\"number\">100</span>))</div><div class=\"line\">          .sorted(Comparator.comparing(c -&gt; c.name))</div><div class=\"line\">          .collect(Collectors.toList());</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<p>Stream作为Java8的新特性之一，他与Java IO包中的InputStream和OutputStream完全不是一个概念。Java8中的Stream是对集合功能的一种增强，主要用于对集合对象进行各种非常便利高效的聚合和大批量数据的操作。结合Lambda表达式可以极大的提高开发效率和代码可读性。</p>\n<p>假设我们需要把一个集合中的所有形状设置成红色，那么我们可以这样写</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">for</span> (Shape shape : shapes)&#123;</div><div class=\"line\">\tshape.setColor(RED)</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>如果使用Java8扩展后的集合框架则可以这样写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">shapes.foreach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure>\n<p><strong>第一种</strong>写法我们叫外部迭代，for-each调用<code>shapes</code>的<code>iterator()</code>依次遍历集合中的元素。这种外部迭代有一些问题：</p>\n<ul>\n<li>for循环是串行的，而且必须按照集合中元素的顺序依次进行；</li>\n<li>集合框架无法对控制流进行优化，例如通过排序、并行、短路求值以及惰性求值改善性能。<blockquote>\n<p>上面这两个问题我们会在后面的文章中逐步解答。</p>\n</blockquote>\n</li>\n</ul>\n<p><strong>第二种</strong>写法我们叫内部迭代，两段代码虽然看起来只是语法上的区别，但实际上他们内部的区别其实非常大。用户把对操作的控制权交还给类库，从而允许类库进行各种各样的优化（例如乱序执行、惰性求值和并行等等）。总的来说，内部迭代使得外部迭代中不可能实现的优化成为可能。</p>\n<p>外部迭代同时承担了做什么（把形状设为红色）和怎么做（得到Iterator实例然后依次遍历），而内部迭代只负责做什么，而把怎么做留给类库。这样代码会变得更加清晰，而集合类库则可以在内部进行各种优化。</p>\n<h2 id=\"一、什么是Stream\"><a href=\"#一、什么是Stream\" class=\"headerlink\" title=\"一、什么是Stream\"></a>一、什么是Stream</h2><p>Stream不是集合元素，它也不是数据结构、不能保存数据，它更像一个更高级的<code>Interator</code>。Stream提供了强大的数据集合操作功能，并被深入整合到现有的集合类和其它的JDK类型中。流的操作可以被组合成流水线（Pipeline）。拿前面的例子来说，如果我只想把蓝色改成红色：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">shapes.stream()</div><div class=\"line\">      .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">      .forEach(s -&gt; s.setColor(RED));</div></pre></td></tr></table></figure>\n<p>在<code>Collection</code>上调用<code>stream()</code>会生成该集合元素的流，接下来<code>filter()</code>操作会产生只包含蓝色形状的流，最后，这些蓝色形状会被<code>forEach</code>操作设为红色。</p>\n<p>如果我们想把蓝色的形状提取到新的List里，则可以：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;Shape&gt; blue = shapes.stream()</div><div class=\"line\">\t\t\t\t\t\t  .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">\t\t\t\t\t\t  .collect(Collectors.toList());</div></pre></td></tr></table></figure>\n<p><code>collect()</code>操作会把其接收的元素聚集到一起（这里是List），<code>collect()</code>方法的参数则被用来指定如何进行聚集操作。在这里我们使用<code>toList()</code>以把元素输出到List中。</p>\n<p>如果每个形状都被保存在<code>Box</code>里，然后我们想知道哪个盒子至少包含一个蓝色形状，我们可以这么写：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\">Set&lt;Box&gt; hasBlueShape = shapes.stream()</div><div class=\"line\">                               .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">                              .map(s -&gt; s.getContainingBox())</div><div class=\"line\">                              .collect(Collectors.toSet());</div></pre></td></tr></table></figure>\n<p><code>map()</code>操作通过映射函数（这里的映射函数接收一个形状，然后返回包含它的盒子）对输入流里面的元素进行依次转换，然后产生新流。</p>\n<p>如果我们需要得到蓝色物体的总重量，我们可以这样表达：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">int sum = shapes.stream()</div><div class=\"line\">                .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">                .mapToInt(s -&gt; s.getWeight())</div><div class=\"line\">                .sum();</div><div class=\"line\">```            </div><div class=\"line\"></div><div class=\"line\">## 二、Stream vs Collection</div><div class=\"line\">流（Stream）和集合（Collection）的区别：</div><div class=\"line\"></div><div class=\"line\">* Collection主要用来对元素进行管理和访问；</div><div class=\"line\">* Stream并不支持对其元素进行直接操作和直接访问，而只支持通过声明式操作在其之上进行运算后得到结果；</div><div class=\"line\">* Stream不存储值</div><div class=\"line\">* 对Stream的操作会产生一个结果，但是Stream并不会改变数据源；</div><div class=\"line\">* 大多数Stream的操作(filter,map,sort等)都是以惰性的方式实现的。这使得我们可以使用一次遍历完成整个流水线操作,并可以用短路操作提供更高效的实现。</div><div class=\"line\"></div><div class=\"line\">## 三、惰性求值 vs 急性求值</div><div class=\"line\">`filter()`和`map()`这样的操作既可以被急性求值（以`filter()`为例，急性求值需要在方法返回前完成对所有元素的过滤），也可以被惰性求值（用`Stream`代表过滤结果，当且仅当需要时才进行过滤操作）在实际中进行惰性运算可以带来很多好处。比如说，如果我们进行惰性过滤，我们就可以把过滤和流水线里的其它操作混合在一起，从而不需要对数据进行多遍遍历。相类似的，如果我们在一个大型集合里搜索第一个满足某个条件的元素，我们可以在找到后直接停止，而不是继续处理整个集合。（这一点对无限数据源是很重要，惰性求值对于有限数据源起到的是优化作用，但对无限数据源起到的是决定作用，没有惰性求值，对无限数据源的操作将无法终止）</div><div class=\"line\"></div><div class=\"line\">对于`filter()`和`map()`这样的操作，我们很自然的会把它当成是惰性求值操作，不过它们是否真的是惰性取决于它们的具体实现。另外，像`sum()`这样生成值的操作和`forEach()`这样产生副作用的操作都是__天然急性求值__，因为它们必须要产生具体的结果。</div><div class=\"line\"></div><div class=\"line\">我们拿下面这段代码举例：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">int sum = shapes.stream()</div><div class=\"line\">                .filter(s -&gt; s.getColor() == BLUE)</div><div class=\"line\">                .mapToInt(s -&gt; s.getWeight())</div><div class=\"line\">                .sum();</div><div class=\"line\">```                </div><div class=\"line\">                    </div><div class=\"line\">这里的`filter()`和`map()`都是惰性的，这就意味着在调用`sum()`之前不会从数据源中提取任何元素。在`sum()`操作之后才会把`filter()`、`map()`和`sum()`放在对数据源一次遍历中。这样可以大大减少维持中间结果所带来的开销。</div><div class=\"line\"></div><div class=\"line\">&lt;!--####6.流水线(Pipeline)的并行操作</div><div class=\"line\">流水线可以是串行的也可以是并行的，串行和并行是流的属性。默认情况下数据源返回的都是串行流，但是我们可以通过`parallel()`将串行流转换为并行流,就像下面这样：</div><div class=\"line\"></div><div class=\"line\">\tint sum = shapes.parallelStream()</div><div class=\"line\">                .filter(s -&gt; s.getColor = BLUE)</div><div class=\"line\">                .mapToInt(s -&gt; s.getWeight())</div><div class=\"line\">                .sum();</div><div class=\"line\">那么，串行流和并行流有什么区别呢？</div><div class=\"line\"></div><div class=\"line\">流的数据源可能是一个可变集合，如果当我们在遍历流时数据源被改变了，那么就会产生干扰。所以在进行流操作的时候，数据源应该保持不变。如果在单线程模型下，我们只需要保证lambda表达式不修改流的数据源就OK了；但如果是多线程环境，lambda在执行时可能会同时运行在多个线程上--&gt;</div><div class=\"line\"></div><div class=\"line\">## 四、举个栗子🌰</div><div class=\"line\">前面长篇大论的介绍概念实在太枯燥，为了方便大家理解我们用Streams API来实现一个具体的业务场景。</div><div class=\"line\"></div><div class=\"line\">假设我们有一个房源库项目，这个房源库中有一系列的小区，每个小区都有小区名和房源列表，每套房子又有价格、面积等属性。现在我们需要筛选出含有100平米以上房源的小区，并按照小区名排序。</div><div class=\"line\"></div><div class=\"line\">我们先来看看不用Streams API如何实现：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">List&lt;Community&gt; result = new ArrayList&lt;&gt;();</div><div class=\"line\">for (Community community : communities) &#123;</div><div class=\"line\">        for (House house : community.houses) &#123;</div><div class=\"line\">            if (house.area &gt; 100) &#123;</div><div class=\"line\">                result.add(community);</div><div class=\"line\">                break;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    Collections.sort(result, new Comparator&lt;Community&gt;() &#123;</div><div class=\"line\">        @Override</div><div class=\"line\">        public int compare(Community c1, Community c2) &#123;</div><div class=\"line\">            return c1.name.compareTo(c2.name);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div><div class=\"line\">    return result;</div></pre></td></tr></table></figure>\n<p>如果使用Streams API:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">return</span> communities.stream()</div><div class=\"line\">          .filter(c -&gt; c.houses.stream().anyMatch(h -&gt; h.area&gt;<span class=\"number\">100</span>))</div><div class=\"line\">          .sorted(Comparator.comparing(c -&gt; c.name))</div><div class=\"line\">          .collect(Collectors.toList());</div></pre></td></tr></table></figure>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"Android WebView那些坑之上传文件","date":"2017-02-05T16:16:41.000Z","_content":"","source":"_posts/2017-02-06-Android-WebView那些坑之上传文件.md","raw":"---\ntitle: Android WebView那些坑之上传文件\ndate: 2017-02-06 00:16:41\ncategories:\ntags:\n---\n","slug":"Android-WebView那些坑之上传文件","published":1,"updated":"2017-02-05T16:16:41.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26eg00066st68uw4nzff","content":"","excerpt":"","more":""},{"title":"RxJava系列1(简介)","date":"2017-02-05T16:19:48.000Z","_content":"\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)  \n\n***\n## 前言\n提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。\n\n> 由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。\n\n## 响应式编程\n在介绍RxJava前，我们先聊聊响应式编程。那么什么是响应式编程呢？响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。\n\n响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。\n\n今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。\n\n> 本章节中部分概念摘自《RxJava Essentials》一书\n\n## RxJava的来历\nRx是微软.Net的一个响应式扩展，Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012年Netflix为了应对不断增长的业务需求开始将.NET Rx迁移到JVM上面。并于13年二月份正式向外展示了RxJava。\n从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。\n\n![RxJava来历](http://ocjtywvav.bkt.clouddn.com/rxjava/1/RxJava%E6%9D%A5%E5%8E%86.png)\n\n## 什么是RxJava\n\n那么到底什么是RxJava呢？我对它的定义是：**RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。**\n\n## RxJava好在哪\nAndroid平台上为已经开发者提供了AsyncTask,Handler等用来做异步操作的类库，那我们为什么还要选择RxJava呢？答案是简洁！RxJava可以用非常简洁的代码逻辑来解决复杂问题；而且即使业务逻辑的越来越复杂，它依然能够保持简洁！再配合上Lambda用简单的几行代码分分钟就解决你负责的业务问题。简直逼格爆表，拿它装逼那是极好的！\n\n多说无益，上代码！\n\n假设我们安居客用户App上有个需求，需要从服务端拉取上海浦东新区塘桥板块的所有小区Community[] communities，每个小区下包含多套房源List<House> houses；我们需要把塘桥板块的所有总价大于500W的房源都展示在App的房源列表页。用于从服务端拉取communities需要发起网络请求，比较耗时，因此需要在后台运行。而这些房源信息需要展示到App的页面上，因此需要在UI线程上执行。(*此例子思路来源于扔物线的[给Android开发者的RxJava详解](http://gank.io/post/560e15be2dca930e00da1083)一文*)\n\n```java       \nnew Thread() {\n        @Override\n        public void run() {\n            super.run();\n            //从服务端获取小区列表\n            List<Community> communities = getCommunitiesFromServer();\n            for (Community community : communities) {\n                List<House> houses = community.houses;\n                for (House house : houses) {\n                    if (house.price >= 5000000) {\n                        runOnUiThread(new Runnable() {\n                            @Override\n                            public void run() {\n                                //将房子的信息添加到屏幕上\n                                addHouseInformationToScreen(house);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }.start();\n```\n\n使用RxJava的写法是这样的：\n\n```java\nObservable.from(getCommunitiesFromServer())\n            .flatMap(new Func1<Community, Observable<House>>() {\n                @Override\n                public Observable<House> call(Community community) {\n                    return Observable.from(community.houses);\n                }\n            }).filter(new Func1<House, Boolean>() {\n                @Override\n                public Boolean call(House house) {\n                    return house.price>=5000000;\n                }\n            }).subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Action1<House>() {\n                @Override\n                public void call(House house) {\n                    //将房子的信息添加到屏幕上\n                    addHouseInformationToScreen(house);\n                }\n            });\n```\n            \n从上面这段代码我们可以看到：虽然代码量看起来变复杂了，但是RxJava的实现是一条链式调用，没有任何的嵌套；整个实现逻辑看起来异常简洁清晰，这对我们的编程实现和后期维护是有巨大帮助的。特别是对于那些回调嵌套的场景。配合Lambda表达式还可以简化成这样：\n\n```java \nObservable.from(getCommunitiesFromServer())\n        .flatMap(community -> Observable.from(community.houses))\n        .filter(house -> house.price>=5000000).subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(this::addHouseInformationToScreen);\n```\n\n简洁！有美感！这才是一个有情怀的程序员应该写出来的代码。\n\n看完这篇文章大家应该能够理解RxJava为什么会越来越火了。它能极大的提高我们的开发效率和代码的可读性！当然了RxJava的学习曲线也是比较陡的，在后面的文章我会对主要的知识点做详细的介绍，敬请关注！\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88) \n","source":"_posts/2017-02-06-RxJava系列1-简介.md","raw":"---\ntitle: RxJava系列1(简介)\ndate: 2017-02-06 00:19:48\ncategories: rxjava\ntags: \n- RxJava\n- Android\n---\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)  \n\n***\n## 前言\n提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。\n\n> 由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。\n\n## 响应式编程\n在介绍RxJava前，我们先聊聊响应式编程。那么什么是响应式编程呢？响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。\n\n响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。\n\n今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。\n\n> 本章节中部分概念摘自《RxJava Essentials》一书\n\n## RxJava的来历\nRx是微软.Net的一个响应式扩展，Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012年Netflix为了应对不断增长的业务需求开始将.NET Rx迁移到JVM上面。并于13年二月份正式向外展示了RxJava。\n从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。\n\n![RxJava来历](http://ocjtywvav.bkt.clouddn.com/rxjava/1/RxJava%E6%9D%A5%E5%8E%86.png)\n\n## 什么是RxJava\n\n那么到底什么是RxJava呢？我对它的定义是：**RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。**\n\n## RxJava好在哪\nAndroid平台上为已经开发者提供了AsyncTask,Handler等用来做异步操作的类库，那我们为什么还要选择RxJava呢？答案是简洁！RxJava可以用非常简洁的代码逻辑来解决复杂问题；而且即使业务逻辑的越来越复杂，它依然能够保持简洁！再配合上Lambda用简单的几行代码分分钟就解决你负责的业务问题。简直逼格爆表，拿它装逼那是极好的！\n\n多说无益，上代码！\n\n假设我们安居客用户App上有个需求，需要从服务端拉取上海浦东新区塘桥板块的所有小区Community[] communities，每个小区下包含多套房源List<House> houses；我们需要把塘桥板块的所有总价大于500W的房源都展示在App的房源列表页。用于从服务端拉取communities需要发起网络请求，比较耗时，因此需要在后台运行。而这些房源信息需要展示到App的页面上，因此需要在UI线程上执行。(*此例子思路来源于扔物线的[给Android开发者的RxJava详解](http://gank.io/post/560e15be2dca930e00da1083)一文*)\n\n```java       \nnew Thread() {\n        @Override\n        public void run() {\n            super.run();\n            //从服务端获取小区列表\n            List<Community> communities = getCommunitiesFromServer();\n            for (Community community : communities) {\n                List<House> houses = community.houses;\n                for (House house : houses) {\n                    if (house.price >= 5000000) {\n                        runOnUiThread(new Runnable() {\n                            @Override\n                            public void run() {\n                                //将房子的信息添加到屏幕上\n                                addHouseInformationToScreen(house);\n                            }\n                        });\n                    }\n                }\n            }\n        }\n    }.start();\n```\n\n使用RxJava的写法是这样的：\n\n```java\nObservable.from(getCommunitiesFromServer())\n            .flatMap(new Func1<Community, Observable<House>>() {\n                @Override\n                public Observable<House> call(Community community) {\n                    return Observable.from(community.houses);\n                }\n            }).filter(new Func1<House, Boolean>() {\n                @Override\n                public Boolean call(House house) {\n                    return house.price>=5000000;\n                }\n            }).subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(new Action1<House>() {\n                @Override\n                public void call(House house) {\n                    //将房子的信息添加到屏幕上\n                    addHouseInformationToScreen(house);\n                }\n            });\n```\n            \n从上面这段代码我们可以看到：虽然代码量看起来变复杂了，但是RxJava的实现是一条链式调用，没有任何的嵌套；整个实现逻辑看起来异常简洁清晰，这对我们的编程实现和后期维护是有巨大帮助的。特别是对于那些回调嵌套的场景。配合Lambda表达式还可以简化成这样：\n\n```java \nObservable.from(getCommunitiesFromServer())\n        .flatMap(community -> Observable.from(community.houses))\n        .filter(house -> house.price>=5000000).subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(this::addHouseInformationToScreen);\n```\n\n简洁！有美感！这才是一个有情怀的程序员应该写出来的代码。\n\n看完这篇文章大家应该能够理解RxJava为什么会越来越火了。它能极大的提高我们的开发效率和代码的可读性！当然了RxJava的学习曲线也是比较陡的，在后面的文章我会对主要的知识点做详细的介绍，敬请关注！\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88) \n","slug":"RxJava系列1-简介","published":1,"updated":"2017-02-05T17:58:23.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26ej000a6st6hu9lbwpr","content":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>  </li>\n</ul>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。</p>\n<blockquote>\n<p>由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。</p>\n</blockquote>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><p>在介绍RxJava前，我们先聊聊响应式编程。那么什么是响应式编程呢？响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</p>\n<p>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。</p>\n<p>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</p>\n<blockquote>\n<p>本章节中部分概念摘自《RxJava Essentials》一书</p>\n</blockquote>\n<h2 id=\"RxJava的来历\"><a href=\"#RxJava的来历\" class=\"headerlink\" title=\"RxJava的来历\"></a>RxJava的来历</h2><p>Rx是微软.Net的一个响应式扩展，Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012年Netflix为了应对不断增长的业务需求开始将.NET Rx迁移到JVM上面。并于13年二月份正式向外展示了RxJava。<br>从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/1/RxJava%E6%9D%A5%E5%8E%86.png\" alt=\"RxJava来历\"></p>\n<h2 id=\"什么是RxJava\"><a href=\"#什么是RxJava\" class=\"headerlink\" title=\"什么是RxJava\"></a>什么是RxJava</h2><p>那么到底什么是RxJava呢？我对它的定义是：<strong>RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。</strong></p>\n<h2 id=\"RxJava好在哪\"><a href=\"#RxJava好在哪\" class=\"headerlink\" title=\"RxJava好在哪\"></a>RxJava好在哪</h2><p>Android平台上为已经开发者提供了AsyncTask,Handler等用来做异步操作的类库，那我们为什么还要选择RxJava呢？答案是简洁！RxJava可以用非常简洁的代码逻辑来解决复杂问题；而且即使业务逻辑的越来越复杂，它依然能够保持简洁！再配合上Lambda用简单的几行代码分分钟就解决你负责的业务问题。简直逼格爆表，拿它装逼那是极好的！</p>\n<p>多说无益，上代码！</p>\n<p>假设我们安居客用户App上有个需求，需要从服务端拉取上海浦东新区塘桥板块的所有小区Community[] communities，每个小区下包含多套房源List<house> houses；我们需要把塘桥板块的所有总价大于500W的房源都展示在App的房源列表页。用于从服务端拉取communities需要发起网络请求，比较耗时，因此需要在后台运行。而这些房源信息需要展示到App的页面上，因此需要在UI线程上执行。(<em>此例子思路来源于扔物线的<a href=\"http://gank.io/post/560e15be2dca930e00da1083\" target=\"_blank\" rel=\"external\">给Android开发者的RxJava详解</a>一文</em>)</house></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.run();</div><div class=\"line\">            <span class=\"comment\">//从服务端获取小区列表</span></div><div class=\"line\">            List&lt;Community&gt; communities = getCommunitiesFromServer();</div><div class=\"line\">            <span class=\"keyword\">for</span> (Community community : communities) &#123;</div><div class=\"line\">                List&lt;House&gt; houses = community.houses;</div><div class=\"line\">                <span class=\"keyword\">for</span> (House house : houses) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (house.price &gt;= <span class=\"number\">5000000</span>) &#123;</div><div class=\"line\">                        runOnUiThread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                                <span class=\"comment\">//将房子的信息添加到屏幕上</span></div><div class=\"line\">                                addHouseInformationToScreen(house);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;.start();</div></pre></td></tr></table></figure>\n<p>使用RxJava的写法是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(getCommunitiesFromServer())</div><div class=\"line\">            .flatMap(<span class=\"keyword\">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;House&gt; <span class=\"title\">call</span><span class=\"params\">(Community community)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> Observable.from(community.houses);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;).filter(<span class=\"keyword\">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> house.price&gt;=<span class=\"number\">5000000</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;).subscribeOn(Schedulers.io())</div><div class=\"line\">            .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">            .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"comment\">//将房子的信息添加到屏幕上</span></div><div class=\"line\">                    addHouseInformationToScreen(house);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div></pre></td></tr></table></figure>\n<p>从上面这段代码我们可以看到：虽然代码量看起来变复杂了，但是RxJava的实现是一条链式调用，没有任何的嵌套；整个实现逻辑看起来异常简洁清晰，这对我们的编程实现和后期维护是有巨大帮助的。特别是对于那些回调嵌套的场景。配合Lambda表达式还可以简化成这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(getCommunitiesFromServer())</div><div class=\"line\">        .flatMap(community -&gt; Observable.from(community.houses))</div><div class=\"line\">        .filter(house -&gt; house.price&gt;=<span class=\"number\">5000000</span>).subscribeOn(Schedulers.io())</div><div class=\"line\">        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">        .subscribe(<span class=\"keyword\">this</span>::addHouseInformationToScreen);</div></pre></td></tr></table></figure>\n<p>简洁！有美感！这才是一个有情怀的程序员应该写出来的代码。</p>\n<p>看完这篇文章大家应该能够理解RxJava为什么会越来越火了。它能极大的提高我们的开发效率和代码的可读性！当然了RxJava的学习曲线也是比较陡的，在后面的文章我会对主要的知识点做详细的介绍，敬请关注！</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a> </li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>  </li>\n</ul>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>提升开发效率，降低维护成本一直是开发团队永恒不变的宗旨。近一年来国内的技术圈子中越来越多的开始提及Rx，经过一段时间的学习和探索之后我也深深的感受到了RxJava的魅力。它能帮助我们简化代码逻辑，提升代码可读性。这对于开发效率的提升、后期维护成本的降低帮助都是巨大的。个人预测RxJava一定是2016年的一个大趋势，所以也有打算将它引入到公司现有的项目中来，写这一系列的文章主要也是为了团队内部做技术分享。</p>\n<blockquote>\n<p>由于我本人是个Android程序猿，因此这一系列文章中的场景都是基于Android平台的。如果你是个Java Web工程师或者是其它方向的那也没关系，我会尽量用通俗的语言将问题描述清楚。</p>\n</blockquote>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><p>在介绍RxJava前，我们先聊聊响应式编程。那么什么是响应式编程呢？响应式编程是一种基于异步数据流概念的编程模式。数据流就像一条河：它可以被观测，被过滤，被操作，或者为新的消费者与另外一条流合并为一条新的流。</p>\n<p>响应式编程的一个关键概念是事件。事件可以被等待，可以触发过程，也可以触发其它事件。事件是唯一的以合适的方式将我们的现实世界映射到我们的软件中：如果屋里太热了我们就打开一扇窗户。同样的，当我们的天气app从服务端获取到新的天气数据后，我们需要更新app上展示天气信息的UI；汽车上的车道偏移系统探测到车辆偏移了正常路线就会提醒驾驶者纠正，就是是响应事件。</p>\n<p>今天，响应式编程最通用的一个场景是UI：我们的移动App必须做出对网络调用、用户触摸输入和系统弹框的响应。在这个世界上，软件之所以是事件驱动并响应的是因为现实生活也是如此。</p>\n<blockquote>\n<p>本章节中部分概念摘自《RxJava Essentials》一书</p>\n</blockquote>\n<h2 id=\"RxJava的来历\"><a href=\"#RxJava的来历\" class=\"headerlink\" title=\"RxJava的来历\"></a>RxJava的来历</h2><p>Rx是微软.Net的一个响应式扩展，Rx借助可观测的序列提供一种简单的方式来创建异步的，基于事件驱动的程序。2012年Netflix为了应对不断增长的业务需求开始将.NET Rx迁移到JVM上面。并于13年二月份正式向外展示了RxJava。<br>从语义的角度来看，RxJava就是.NET Rx。从语法的角度来看，Netflix考虑到了对应每个Rx方法,保留了Java代码规范和基本的模式。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/1/RxJava%E6%9D%A5%E5%8E%86.png\" alt=\"RxJava来历\"></p>\n<h2 id=\"什么是RxJava\"><a href=\"#什么是RxJava\" class=\"headerlink\" title=\"什么是RxJava\"></a>什么是RxJava</h2><p>那么到底什么是RxJava呢？我对它的定义是：<strong>RxJava本质上是一个异步操作库，是一个能让你用极其简洁的逻辑去处理繁琐复杂任务的异步事件库。</strong></p>\n<h2 id=\"RxJava好在哪\"><a href=\"#RxJava好在哪\" class=\"headerlink\" title=\"RxJava好在哪\"></a>RxJava好在哪</h2><p>Android平台上为已经开发者提供了AsyncTask,Handler等用来做异步操作的类库，那我们为什么还要选择RxJava呢？答案是简洁！RxJava可以用非常简洁的代码逻辑来解决复杂问题；而且即使业务逻辑的越来越复杂，它依然能够保持简洁！再配合上Lambda用简单的几行代码分分钟就解决你负责的业务问题。简直逼格爆表，拿它装逼那是极好的！</p>\n<p>多说无益，上代码！</p>\n<p>假设我们安居客用户App上有个需求，需要从服务端拉取上海浦东新区塘桥板块的所有小区Community[] communities，每个小区下包含多套房源List<House> houses；我们需要把塘桥板块的所有总价大于500W的房源都展示在App的房源列表页。用于从服务端拉取communities需要发起网络请求，比较耗时，因此需要在后台运行。而这些房源信息需要展示到App的页面上，因此需要在UI线程上执行。(<em>此例子思路来源于扔物线的<a href=\"http://gank.io/post/560e15be2dca930e00da1083\">给Android开发者的RxJava详解</a>一文</em>)</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">new</span> Thread() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">super</span>.run();</div><div class=\"line\">            <span class=\"comment\">//从服务端获取小区列表</span></div><div class=\"line\">            List&lt;Community&gt; communities = getCommunitiesFromServer();</div><div class=\"line\">            <span class=\"keyword\">for</span> (Community community : communities) &#123;</div><div class=\"line\">                List&lt;House&gt; houses = community.houses;</div><div class=\"line\">                <span class=\"keyword\">for</span> (House house : houses) &#123;</div><div class=\"line\">                    <span class=\"keyword\">if</span> (house.price &gt;= <span class=\"number\">5000000</span>) &#123;</div><div class=\"line\">                        runOnUiThread(<span class=\"keyword\">new</span> Runnable() &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                                <span class=\"comment\">//将房子的信息添加到屏幕上</span></div><div class=\"line\">                                addHouseInformationToScreen(house);</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;.start();</div></pre></td></tr></table></figure>\n<p>使用RxJava的写法是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(getCommunitiesFromServer())</div><div class=\"line\">            .flatMap(<span class=\"keyword\">new</span> Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;House&gt; <span class=\"title\">call</span><span class=\"params\">(Community community)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> Observable.from(community.houses);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;).filter(<span class=\"keyword\">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> house.price&gt;=<span class=\"number\">5000000</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;).subscribeOn(Schedulers.io())</div><div class=\"line\">            .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">            .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"comment\">//将房子的信息添加到屏幕上</span></div><div class=\"line\">                    addHouseInformationToScreen(house);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div></pre></td></tr></table></figure>\n<p>从上面这段代码我们可以看到：虽然代码量看起来变复杂了，但是RxJava的实现是一条链式调用，没有任何的嵌套；整个实现逻辑看起来异常简洁清晰，这对我们的编程实现和后期维护是有巨大帮助的。特别是对于那些回调嵌套的场景。配合Lambda表达式还可以简化成这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(getCommunitiesFromServer())</div><div class=\"line\">        .flatMap(community -&gt; Observable.from(community.houses))</div><div class=\"line\">        .filter(house -&gt; house.price&gt;=<span class=\"number\">5000000</span>).subscribeOn(Schedulers.io())</div><div class=\"line\">        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">        .subscribe(<span class=\"keyword\">this</span>::addHouseInformationToScreen);</div></pre></td></tr></table></figure>\n<p>简洁！有美感！这才是一个有情怀的程序员应该写出来的代码。</p>\n<p>看完这篇文章大家应该能够理解RxJava为什么会越来越火了。它能极大的提高我们的开发效率和代码的可读性！当然了RxJava的学习曲线也是比较陡的，在后面的文章我会对主要的知识点做详细的介绍，敬请关注！</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a> </li>\n</ul>\n</blockquote>\n"},{"title":"RxJava系列2(基本概念及使用介绍)","date":"2017-02-05T16:20:04.000Z","_content":"\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)    \n\n***\n## 前言\n上一篇的示例代码中大家一定发现了Observable这个类。从纯Java的观点看，Observable类源自于经典的观察者模式。RxJava的异步实现正是基于观察者模式来实现的，而且是一种扩展的观察者模式。\n\n## 观察者模式\n观察者模式基于Subject这个概念，Subject是一种特殊对象，又叫做**主题**或者**被观察者**。当它改变时那些由它保存的一系列对象将会得到通知，而这一系列对象被称作Observer(**观察者**)。它们会对外暴漏了一个通知方法(比方说update之类的)，当Subject状态发生变化时会调用的这个方法。\n\n观察者模式很适合下面这些场景中的任何一个：\n\n1. 当你的架构有两个实体类，一个依赖另一个，你想让它们互不影响或者是独立复用它们时。\n2. 当一个变化的对象通知那些与它自身变化相关联的未知数量的对象时。\n3. 当一个变化的对象通知那些无需推断具体类型的对象时。\n\n通常一个观察者模式的类图是这样的：\n\n![Observer](http://ocjtywvav.bkt.clouddn.com/rxjava/2/Observer.png)\n\n如果你对观察者模式不是很了解，那么强烈建议你先去学习下。关于观察者模式的详细介绍可以参考我之前的文章：[设计模式之观察者模式](http://www.jianshu.com/p/d55ee6e83d66)\n\n## 扩展的观察者模式\n\n在RxJava中主要有4个角色：\n\n* Observable\n* Subject\n* Observer\n* Subscriber\n\nObservable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。说直白点`Observable`对应于观察者模式中的**被观察者**，而`Observer`和`Subscriber`对应于观察者模式中的**观察者**。`Subscriber`其实是一个实现了`Observer`的抽象类，后面我们分析源码的时候也会介绍到。`Subject`比较复杂，以后再分析。\n\n上一篇文章中我们说到RxJava中有个关键概念：**事件**。观察者`Observer`和被观察者`Observable`通过`subscribe()`方法实现订阅关系。从而`Observable` 可以在需要的时候发出**事件**来通知`Observer`。\n\n## RxJava如何使用\n\n我自己在学习一种新技术的时候通常喜欢先去了解它是怎么用的，掌握了使用方法后再去深挖其原理。那么我们现在就来说说RxJava到底该怎么用。\n\n**第一步：创建观察者Observer**\n\n```java\nObserver<Object> observer = new Observer<Object>() {\n\n    @Override\n    public void onCompleted() {\n\n    }\n\n    @Override\n    public void onError(Throwable e) {\n\n    }\n\n    @Override\n    public void onNext(Object s) {\n\n    }\n };\n ```\n     \n这么简单，一个观察者Observer创建了!\n        \n大兄弟你等等...，你之前那篇[观察者模式](http://www.jianshu.com/p/d55ee6e83d66)中不是说观察者只提供一个update方法的吗？这特么怎么有三个？！！\n\n少年勿急，且听我慢慢道来。在普通的观察者模式中观察者一般只会提供一个update()方法用于被观察者的状态发生变化时，用于提供给被观察者调用。而在RxJava中的观察者Observer提供了:`onNext()`、 `onCompleted()`和`onError()`三个方法。还记得吗？开篇我们讲过RxJava是基于一种扩展的观察这模式实现，这里多出的onCompleted和onError正是对观察者模式的扩展。*ps:onNext就相当于普通观察者模式中的update*\n\nRxJava中添加了普通观察者模式缺失的三个功能：\n\n1. RxJava中规定当不再有新的事件发出时，可以调用onCompleted()方法作为标示；\n2. 当事件处理出现异常时框架自动触发onError()方法；\n3. 同时Observables支持链式调用，从而避免了回调嵌套的问题。\n \n\n**第二步：创建被观察者Observable**\n\n`Observable.create()`方法可以创建一个Observable，使用`crate()`创建Observable需要一个OnSubscribe对象，这个对象继承Action1。当观察者订阅我们的Observable时，它作为一个参数传入并执行`call()`函数。 \n\t\n```java\nObservable<Object> observable = Observable.create(new \n        \tObservable.OnSubscribe<Object>() {\n    @Override\n    public void call(Subscriber<? super Object> subscriber) {\n\n    }\n});\n```\n\n除了create()，just()和from()同样可以创建Observable。看看下面两个例子：\n\n`just(T...)`将传入的参数依次发送\n\n```java\nObservable observable = Observable.just(\"One\", \"Two\", \"Three\");\n//上面这行代码会依次调用\n//onNext(\"One\");\n//onNext(\"Two\");\n//onNext(\"Three\");\n//onCompleted();\n```\n\n`from(T[])/from(Iterable<? extends T>)`将传入的数组或者Iterable拆分成Java对象依次发送\n\n```java\nString[] parameters = {\"One\", \"Two\", \"Three\"};\nObservable observable = Observable.from(parameters);\n//上面这行代码会依次调用\n//onNext(\"One\");\n//onNext(\"Two\");\n//onNext(\"Three\");\n//onCompleted();\n```\n\n**第三步：被观察者Observable订阅观察者Observer**（*ps:你没看错，不同于普通的观察者模式，这里是被观察者订阅观察者*）\n\t\n有了观察者和被观察者，我们就可以通过subscribe()来实现二者的订阅关系了。\n\n```java\t\nobservable.subscribe(observer);\n```\n\t\n![observable.subscribe(observer)](http://ocjtywvav.bkt.clouddn.com/rxjava/2/subscribe1.png)\n\t\n连在一起写就是这样：\n\n```java\nObservable.create(new Observable.OnSubscribe<Integer>() {\n\n    @Override\n    public void call(Subscriber<? super Integer> subscriber) {\n        for (int i = 0; i < 5; i++) {\n            subscriber.onNext(i);\n        }\n        subscriber.onCompleted();\n    }\n\n}).subscribe(new Observer<Integer>() {\n\n    @Override\n    public void onCompleted() {\n        System.out.println(\"onCompleted\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"onError\");\n    }\n\n    @Override\n    public void onNext(Integer item) {\n        System.out.println(\"Item is \" + item);\n    }\n});\n```\n\n至此一个完整的RxJava调用就完成了。\n\n兄台，你叨逼叨叨逼叨的说了一大堆，可是我没搞定你特么到底在干啥啊？！！不急，我现在就来告诉你们到底发生了什么。\n\n首先我们使用Observable.create()创建了一个新的Observable<Integer>，并为`create()`方法传入了一个OnSubscribe，OnSubscribe中包含一个`call()`方法，一旦我们调用`subscribe()`订阅后就会自动触发call()方法。call()方法中的参数Subscriber其实就是subscribe()方法中的观察者Observer。我们在`call()`方法中调用了5次`onNext()`和1次`onCompleted()`方法。一套流程周下来以后输出结果就是下面这样的：\n\n\tItem is 0\n\tItem is 1\n\tItem is 2\n\tItem is 3\n\tItem is 4\n\tonCompleted\n\t\n看到这里可能你又要说了，大兄弟你别唬我啊！OnSubscribe的call()方法中的参数Subscriber怎么就变成了subscribe()方法中的观察者Observer？！！！这俩儿货明明看起来就是两个不同的类啊。\n\n我们先看看Subscriber这个类：\n\n```java\npublic abstract class Subscriber<T> implements Observer<T>, Subscription {\n    \n    ...\n}\n```\n\n从源码中我们可以看到，Subscriber是Observer的一个抽象实现类，所以我首先可以肯定的是Subscriber和Observer类型是一致的。接着往下我们看看subscribe()这个方法：\n\n```java\npublic final Subscription subscribe(final Observer<? super T> observer) {\n\n    //这里的if判断对于我们要分享的问题没有关联，可以先无视\n    if (observer instanceof Subscriber) {\n        return subscribe((Subscriber<? super T>)observer);\n    }\n    return subscribe(new Subscriber<T>() {\n\n        @Override\n        public void onCompleted() {\n            observer.onCompleted();\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            observer.onError(e);\n        }\n\n        @Override\n        public void onNext(T t) {\n            observer.onNext(t);\n        }\n\n    });\n}\n```\n\n我们看到subscribe()方法内部首先将传进来的Observer做了一层代理，将它转换成了Subscriber。我们再看看这个方法内部的subscribe()方法：\n\n```java\npublic final Subscription subscribe(Subscriber<? super T> subscriber) {\n    return Observable.subscribe(subscriber, this);\n}\n```\n\n进一步往下追踪看看return后面这段代码到底做了什么。精简掉其他无关代码后的subscribe(subscriber, this)方法是这样的：\n\n```java\nprivate static <T> Subscription subscribe(Subscriber<? super T> subscriber, Observable<T> observable) {\n\n    subscriber.onStart();\n    try {\n        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);\n        return hook.onSubscribeReturn(subscriber);\n    } catch (Throwable e) {\n        return Subscriptions.unsubscribed();\n    }\n}\n```\n\n我们重点看看hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber),前面这个hook.onSubscribeStart(observable, observable.onSubscribe)返回的是它自己括号内的第二个参数observable.onSubscribe,然后调用了它的call方法。而这个observable.onSubscribe正是create()方法中的Subscriber，这样整个流程就理顺了。看到这里是不是对RxJava的执行流程清晰了一点呢？这里也建议大家在学习新技术的时候多去翻一翻源码，知其然还要能知其所以然不是吗。\n\n> subscribe()的参数除了可以是Observer和Subscriber以外还可以是Action1、Action0；这是一种更简单的回调，只有一个call(T)方法；由于太简单这里就不做详细介绍了！\n\n## 异步\n\n上一篇文章中开篇就讲到RxJava就是来处理异步任务的。但是默认情况下我们在哪个线程调用subscribe()就在哪个线程生产事件，在哪个线程生产事件就在哪个线程消费事件。那怎么做到异步呢？RxJava为我们提供Scheduler用来做线程调度，我们来看看RxJava提供了哪些Scheduler。\n<table class=\"table table-striped\"><tr><th>Schedulers</th><th>作用</th></tr><tr><td>Schedulers.immediate()</td><td>默认的Scheduler，直接在当前线程运行</td></tr><tr><td>Schedulers.newThread()</td><td>总是开启一个新线程</td></tr><tr><td>Schedulers.io()</td><td>用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io()默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</td></tr><tr><td>Schedulers.computation()</td><td>计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU</td></tr><tr><td>Schedulers.from(executor)</td><td>使用指定的Executor作为调度器</td></tr><tr><td>Schedulers.trampoline()</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>RxAndroid中新增的Scheduler，表示在Android的main线程中运行</td></tr></table>\n\n同时RxJava还为我们提供了`subscribeOn()`和`observeOn()`两个方法来指定Observable和Observer运行的线程。\n\n```java\nObservable.from(getCommunitiesFromServer())\n            .flatMap(community -> Observable.from(community.houses))\n            .filter(house -> house.price>=5000000).subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(this::addHouseInformationToScreen);\n```\n\n上面这段代码大家应该有印象吧，没错正是我们上一篇文章中的例子。`subscribeOn(Schedulers.io())`指定了获取小区列表、处理房源信息等一系列事件都是在IO线程中运行，`observeOn(AndroidSchedulers.mainThread())`指定了在屏幕上展示房源的操作在UI线程执行。这就做到了在子线程获取房源，主线程展示房源。\n\n好了，RxJava系列的入门内容我们就聊到这。下一篇我们再继续介绍更多的API以及它们内部的原理。\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)","source":"_posts/2017-02-06-RxJava系列2-基本概念及使用介绍.md","raw":"---\ntitle: RxJava系列2(基本概念及使用介绍)\ndate: 2017-02-06 00:20:04\ncategories: rxjava\ntags: \n- RxJava\n- Android\n---\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)    \n\n***\n## 前言\n上一篇的示例代码中大家一定发现了Observable这个类。从纯Java的观点看，Observable类源自于经典的观察者模式。RxJava的异步实现正是基于观察者模式来实现的，而且是一种扩展的观察者模式。\n\n## 观察者模式\n观察者模式基于Subject这个概念，Subject是一种特殊对象，又叫做**主题**或者**被观察者**。当它改变时那些由它保存的一系列对象将会得到通知，而这一系列对象被称作Observer(**观察者**)。它们会对外暴漏了一个通知方法(比方说update之类的)，当Subject状态发生变化时会调用的这个方法。\n\n观察者模式很适合下面这些场景中的任何一个：\n\n1. 当你的架构有两个实体类，一个依赖另一个，你想让它们互不影响或者是独立复用它们时。\n2. 当一个变化的对象通知那些与它自身变化相关联的未知数量的对象时。\n3. 当一个变化的对象通知那些无需推断具体类型的对象时。\n\n通常一个观察者模式的类图是这样的：\n\n![Observer](http://ocjtywvav.bkt.clouddn.com/rxjava/2/Observer.png)\n\n如果你对观察者模式不是很了解，那么强烈建议你先去学习下。关于观察者模式的详细介绍可以参考我之前的文章：[设计模式之观察者模式](http://www.jianshu.com/p/d55ee6e83d66)\n\n## 扩展的观察者模式\n\n在RxJava中主要有4个角色：\n\n* Observable\n* Subject\n* Observer\n* Subscriber\n\nObservable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。说直白点`Observable`对应于观察者模式中的**被观察者**，而`Observer`和`Subscriber`对应于观察者模式中的**观察者**。`Subscriber`其实是一个实现了`Observer`的抽象类，后面我们分析源码的时候也会介绍到。`Subject`比较复杂，以后再分析。\n\n上一篇文章中我们说到RxJava中有个关键概念：**事件**。观察者`Observer`和被观察者`Observable`通过`subscribe()`方法实现订阅关系。从而`Observable` 可以在需要的时候发出**事件**来通知`Observer`。\n\n## RxJava如何使用\n\n我自己在学习一种新技术的时候通常喜欢先去了解它是怎么用的，掌握了使用方法后再去深挖其原理。那么我们现在就来说说RxJava到底该怎么用。\n\n**第一步：创建观察者Observer**\n\n```java\nObserver<Object> observer = new Observer<Object>() {\n\n    @Override\n    public void onCompleted() {\n\n    }\n\n    @Override\n    public void onError(Throwable e) {\n\n    }\n\n    @Override\n    public void onNext(Object s) {\n\n    }\n };\n ```\n     \n这么简单，一个观察者Observer创建了!\n        \n大兄弟你等等...，你之前那篇[观察者模式](http://www.jianshu.com/p/d55ee6e83d66)中不是说观察者只提供一个update方法的吗？这特么怎么有三个？！！\n\n少年勿急，且听我慢慢道来。在普通的观察者模式中观察者一般只会提供一个update()方法用于被观察者的状态发生变化时，用于提供给被观察者调用。而在RxJava中的观察者Observer提供了:`onNext()`、 `onCompleted()`和`onError()`三个方法。还记得吗？开篇我们讲过RxJava是基于一种扩展的观察这模式实现，这里多出的onCompleted和onError正是对观察者模式的扩展。*ps:onNext就相当于普通观察者模式中的update*\n\nRxJava中添加了普通观察者模式缺失的三个功能：\n\n1. RxJava中规定当不再有新的事件发出时，可以调用onCompleted()方法作为标示；\n2. 当事件处理出现异常时框架自动触发onError()方法；\n3. 同时Observables支持链式调用，从而避免了回调嵌套的问题。\n \n\n**第二步：创建被观察者Observable**\n\n`Observable.create()`方法可以创建一个Observable，使用`crate()`创建Observable需要一个OnSubscribe对象，这个对象继承Action1。当观察者订阅我们的Observable时，它作为一个参数传入并执行`call()`函数。 \n\t\n```java\nObservable<Object> observable = Observable.create(new \n        \tObservable.OnSubscribe<Object>() {\n    @Override\n    public void call(Subscriber<? super Object> subscriber) {\n\n    }\n});\n```\n\n除了create()，just()和from()同样可以创建Observable。看看下面两个例子：\n\n`just(T...)`将传入的参数依次发送\n\n```java\nObservable observable = Observable.just(\"One\", \"Two\", \"Three\");\n//上面这行代码会依次调用\n//onNext(\"One\");\n//onNext(\"Two\");\n//onNext(\"Three\");\n//onCompleted();\n```\n\n`from(T[])/from(Iterable<? extends T>)`将传入的数组或者Iterable拆分成Java对象依次发送\n\n```java\nString[] parameters = {\"One\", \"Two\", \"Three\"};\nObservable observable = Observable.from(parameters);\n//上面这行代码会依次调用\n//onNext(\"One\");\n//onNext(\"Two\");\n//onNext(\"Three\");\n//onCompleted();\n```\n\n**第三步：被观察者Observable订阅观察者Observer**（*ps:你没看错，不同于普通的观察者模式，这里是被观察者订阅观察者*）\n\t\n有了观察者和被观察者，我们就可以通过subscribe()来实现二者的订阅关系了。\n\n```java\t\nobservable.subscribe(observer);\n```\n\t\n![observable.subscribe(observer)](http://ocjtywvav.bkt.clouddn.com/rxjava/2/subscribe1.png)\n\t\n连在一起写就是这样：\n\n```java\nObservable.create(new Observable.OnSubscribe<Integer>() {\n\n    @Override\n    public void call(Subscriber<? super Integer> subscriber) {\n        for (int i = 0; i < 5; i++) {\n            subscriber.onNext(i);\n        }\n        subscriber.onCompleted();\n    }\n\n}).subscribe(new Observer<Integer>() {\n\n    @Override\n    public void onCompleted() {\n        System.out.println(\"onCompleted\");\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"onError\");\n    }\n\n    @Override\n    public void onNext(Integer item) {\n        System.out.println(\"Item is \" + item);\n    }\n});\n```\n\n至此一个完整的RxJava调用就完成了。\n\n兄台，你叨逼叨叨逼叨的说了一大堆，可是我没搞定你特么到底在干啥啊？！！不急，我现在就来告诉你们到底发生了什么。\n\n首先我们使用Observable.create()创建了一个新的Observable<Integer>，并为`create()`方法传入了一个OnSubscribe，OnSubscribe中包含一个`call()`方法，一旦我们调用`subscribe()`订阅后就会自动触发call()方法。call()方法中的参数Subscriber其实就是subscribe()方法中的观察者Observer。我们在`call()`方法中调用了5次`onNext()`和1次`onCompleted()`方法。一套流程周下来以后输出结果就是下面这样的：\n\n\tItem is 0\n\tItem is 1\n\tItem is 2\n\tItem is 3\n\tItem is 4\n\tonCompleted\n\t\n看到这里可能你又要说了，大兄弟你别唬我啊！OnSubscribe的call()方法中的参数Subscriber怎么就变成了subscribe()方法中的观察者Observer？！！！这俩儿货明明看起来就是两个不同的类啊。\n\n我们先看看Subscriber这个类：\n\n```java\npublic abstract class Subscriber<T> implements Observer<T>, Subscription {\n    \n    ...\n}\n```\n\n从源码中我们可以看到，Subscriber是Observer的一个抽象实现类，所以我首先可以肯定的是Subscriber和Observer类型是一致的。接着往下我们看看subscribe()这个方法：\n\n```java\npublic final Subscription subscribe(final Observer<? super T> observer) {\n\n    //这里的if判断对于我们要分享的问题没有关联，可以先无视\n    if (observer instanceof Subscriber) {\n        return subscribe((Subscriber<? super T>)observer);\n    }\n    return subscribe(new Subscriber<T>() {\n\n        @Override\n        public void onCompleted() {\n            observer.onCompleted();\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            observer.onError(e);\n        }\n\n        @Override\n        public void onNext(T t) {\n            observer.onNext(t);\n        }\n\n    });\n}\n```\n\n我们看到subscribe()方法内部首先将传进来的Observer做了一层代理，将它转换成了Subscriber。我们再看看这个方法内部的subscribe()方法：\n\n```java\npublic final Subscription subscribe(Subscriber<? super T> subscriber) {\n    return Observable.subscribe(subscriber, this);\n}\n```\n\n进一步往下追踪看看return后面这段代码到底做了什么。精简掉其他无关代码后的subscribe(subscriber, this)方法是这样的：\n\n```java\nprivate static <T> Subscription subscribe(Subscriber<? super T> subscriber, Observable<T> observable) {\n\n    subscriber.onStart();\n    try {\n        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);\n        return hook.onSubscribeReturn(subscriber);\n    } catch (Throwable e) {\n        return Subscriptions.unsubscribed();\n    }\n}\n```\n\n我们重点看看hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber),前面这个hook.onSubscribeStart(observable, observable.onSubscribe)返回的是它自己括号内的第二个参数observable.onSubscribe,然后调用了它的call方法。而这个observable.onSubscribe正是create()方法中的Subscriber，这样整个流程就理顺了。看到这里是不是对RxJava的执行流程清晰了一点呢？这里也建议大家在学习新技术的时候多去翻一翻源码，知其然还要能知其所以然不是吗。\n\n> subscribe()的参数除了可以是Observer和Subscriber以外还可以是Action1、Action0；这是一种更简单的回调，只有一个call(T)方法；由于太简单这里就不做详细介绍了！\n\n## 异步\n\n上一篇文章中开篇就讲到RxJava就是来处理异步任务的。但是默认情况下我们在哪个线程调用subscribe()就在哪个线程生产事件，在哪个线程生产事件就在哪个线程消费事件。那怎么做到异步呢？RxJava为我们提供Scheduler用来做线程调度，我们来看看RxJava提供了哪些Scheduler。\n<table class=\"table table-striped\"><tr><th>Schedulers</th><th>作用</th></tr><tr><td>Schedulers.immediate()</td><td>默认的Scheduler，直接在当前线程运行</td></tr><tr><td>Schedulers.newThread()</td><td>总是开启一个新线程</td></tr><tr><td>Schedulers.io()</td><td>用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io()默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</td></tr><tr><td>Schedulers.computation()</td><td>计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU</td></tr><tr><td>Schedulers.from(executor)</td><td>使用指定的Executor作为调度器</td></tr><tr><td>Schedulers.trampoline()</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>RxAndroid中新增的Scheduler，表示在Android的main线程中运行</td></tr></table>\n\n同时RxJava还为我们提供了`subscribeOn()`和`observeOn()`两个方法来指定Observable和Observer运行的线程。\n\n```java\nObservable.from(getCommunitiesFromServer())\n            .flatMap(community -> Observable.from(community.houses))\n            .filter(house -> house.price>=5000000).subscribeOn(Schedulers.io())\n            .observeOn(AndroidSchedulers.mainThread())\n            .subscribe(this::addHouseInformationToScreen);\n```\n\n上面这段代码大家应该有印象吧，没错正是我们上一篇文章中的例子。`subscribeOn(Schedulers.io())`指定了获取小区列表、处理房源信息等一系列事件都是在IO线程中运行，`observeOn(AndroidSchedulers.mainThread())`指定了在屏幕上展示房源的操作在UI线程执行。这就做到了在子线程获取房源，主线程展示房源。\n\n好了，RxJava系列的入门内容我们就聊到这。下一篇我们再继续介绍更多的API以及它们内部的原理。\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)","slug":"RxJava系列2-基本概念及使用介绍","published":1,"updated":"2017-02-06T03:39:22.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26eo000d6st639cz443z","content":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>    </li>\n</ul>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇的示例代码中大家一定发现了Observable这个类。从纯Java的观点看，Observable类源自于经典的观察者模式。RxJava的异步实现正是基于观察者模式来实现的，而且是一种扩展的观察者模式。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>观察者模式基于Subject这个概念，Subject是一种特殊对象，又叫做<strong>主题</strong>或者<strong>被观察者</strong>。当它改变时那些由它保存的一系列对象将会得到通知，而这一系列对象被称作Observer(<strong>观察者</strong>)。它们会对外暴漏了一个通知方法(比方说update之类的)，当Subject状态发生变化时会调用的这个方法。</p>\n<p>观察者模式很适合下面这些场景中的任何一个：</p>\n<ol>\n<li>当你的架构有两个实体类，一个依赖另一个，你想让它们互不影响或者是独立复用它们时。</li>\n<li>当一个变化的对象通知那些与它自身变化相关联的未知数量的对象时。</li>\n<li>当一个变化的对象通知那些无需推断具体类型的对象时。</li>\n</ol>\n<p>通常一个观察者模式的类图是这样的：</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/2/Observer.png\" alt=\"Observer\"></p>\n<p>如果你对观察者模式不是很了解，那么强烈建议你先去学习下。关于观察者模式的详细介绍可以参考我之前的文章：<a href=\"http://www.jianshu.com/p/d55ee6e83d66\" target=\"_blank\" rel=\"external\">设计模式之观察者模式</a></p>\n<h2 id=\"扩展的观察者模式\"><a href=\"#扩展的观察者模式\" class=\"headerlink\" title=\"扩展的观察者模式\"></a>扩展的观察者模式</h2><p>在RxJava中主要有4个角色：</p>\n<ul>\n<li>Observable</li>\n<li>Subject</li>\n<li>Observer</li>\n<li>Subscriber</li>\n</ul>\n<p>Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。说直白点<code>Observable</code>对应于观察者模式中的<strong>被观察者</strong>，而<code>Observer</code>和<code>Subscriber</code>对应于观察者模式中的<strong>观察者</strong>。<code>Subscriber</code>其实是一个实现了<code>Observer</code>的抽象类，后面我们分析源码的时候也会介绍到。<code>Subject</code>比较复杂，以后再分析。</p>\n<p>上一篇文章中我们说到RxJava中有个关键概念：<strong>事件</strong>。观察者<code>Observer</code>和被观察者<code>Observable</code>通过<code>subscribe()</code>方法实现订阅关系。从而<code>Observable</code> 可以在需要的时候发出<strong>事件</strong>来通知<code>Observer</code>。</p>\n<h2 id=\"RxJava如何使用\"><a href=\"#RxJava如何使用\" class=\"headerlink\" title=\"RxJava如何使用\"></a>RxJava如何使用</h2><p>我自己在学习一种新技术的时候通常喜欢先去了解它是怎么用的，掌握了使用方法后再去深挖其原理。那么我们现在就来说说RxJava到底该怎么用。</p>\n<p><strong>第一步：创建观察者Observer</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observer&lt;Object&gt; observer = <span class=\"keyword\">new</span> Observer&lt;Object&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Object s)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n<p>这么简单，一个观察者Observer创建了!</p>\n<p>大兄弟你等等…，你之前那篇<a href=\"http://www.jianshu.com/p/d55ee6e83d66\" target=\"_blank\" rel=\"external\">观察者模式</a>中不是说观察者只提供一个update方法的吗？这特么怎么有三个？！！</p>\n<p>少年勿急，且听我慢慢道来。在普通的观察者模式中观察者一般只会提供一个update()方法用于被观察者的状态发生变化时，用于提供给被观察者调用。而在RxJava中的观察者Observer提供了:<code>onNext()</code>、 <code>onCompleted()</code>和<code>onError()</code>三个方法。还记得吗？开篇我们讲过RxJava是基于一种扩展的观察这模式实现，这里多出的onCompleted和onError正是对观察者模式的扩展。<em>ps:onNext就相当于普通观察者模式中的update</em></p>\n<p>RxJava中添加了普通观察者模式缺失的三个功能：</p>\n<ol>\n<li>RxJava中规定当不再有新的事件发出时，可以调用onCompleted()方法作为标示；</li>\n<li>当事件处理出现异常时框架自动触发onError()方法；</li>\n<li>同时Observables支持链式调用，从而避免了回调嵌套的问题。</li>\n</ol>\n<p><strong>第二步：创建被观察者Observable</strong></p>\n<p><code>Observable.create()</code>方法可以创建一个Observable，使用<code>crate()</code>创建Observable需要一个OnSubscribe对象，这个对象继承Action1。当观察者订阅我们的Observable时，它作为一个参数传入并执行<code>call()</code>函数。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Object&gt; observable = Observable.create(<span class=\"keyword\">new</span> </div><div class=\"line\">        \tObservable.OnSubscribe&lt;Object&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Object&gt; subscriber)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>除了create()，just()和from()同样可以创建Observable。看看下面两个例子：</p>\n<p><code>just(T...)</code>将传入的参数依次发送</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable observable = Observable.just(<span class=\"string\">\"One\"</span>, <span class=\"string\">\"Two\"</span>, <span class=\"string\">\"Three\"</span>);</div><div class=\"line\"><span class=\"comment\">//上面这行代码会依次调用</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"One\");</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"Two\");</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"Three\");</span></div><div class=\"line\"><span class=\"comment\">//onCompleted();</span></div></pre></td></tr></table></figure>\n<p><code>from(T[])/from(Iterable&lt;? extends T&gt;)</code>将传入的数组或者Iterable拆分成Java对象依次发送</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">String[] parameters = &#123;<span class=\"string\">\"One\"</span>, <span class=\"string\">\"Two\"</span>, <span class=\"string\">\"Three\"</span>&#125;;</div><div class=\"line\">Observable observable = Observable.from(parameters);</div><div class=\"line\"><span class=\"comment\">//上面这行代码会依次调用</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"One\");</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"Two\");</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"Three\");</span></div><div class=\"line\"><span class=\"comment\">//onCompleted();</span></div></pre></td></tr></table></figure>\n<p><strong>第三步：被观察者Observable订阅观察者Observer</strong>（<em>ps:你没看错，不同于普通的观察者模式，这里是被观察者订阅观察者</em>）</p>\n<p>有了观察者和被观察者，我们就可以通过subscribe()来实现二者的订阅关系了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">observable.subscribe(observer);</div></pre></td></tr></table></figure>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/2/subscribe1.png\" alt=\"observable.subscribe(observer)\"></p>\n<p>连在一起写就是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">            subscriber.onNext(i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;Integer&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"onCompleted\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"onError\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Integer item)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Item is \"</span> + item);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>至此一个完整的RxJava调用就完成了。</p>\n<p>兄台，你叨逼叨叨逼叨的说了一大堆，可是我没搞定你特么到底在干啥啊？！！不急，我现在就来告诉你们到底发生了什么。</p>\n<p>首先我们使用Observable.create()创建了一个新的Observable<integer>，并为<code>create()</code>方法传入了一个OnSubscribe，OnSubscribe中包含一个<code>call()</code>方法，一旦我们调用<code>subscribe()</code>订阅后就会自动触发call()方法。call()方法中的参数Subscriber其实就是subscribe()方法中的观察者Observer。我们在<code>call()</code>方法中调用了5次<code>onNext()</code>和1次<code>onCompleted()</code>方法。一套流程周下来以后输出结果就是下面这样的：</integer></p>\n<pre><code>Item is 0\nItem is 1\nItem is 2\nItem is 3\nItem is 4\nonCompleted\n</code></pre><p>看到这里可能你又要说了，大兄弟你别唬我啊！OnSubscribe的call()方法中的参数Subscriber怎么就变成了subscribe()方法中的观察者Observer？！！！这俩儿货明明看起来就是两个不同的类啊。</p>\n<p>我们先看看Subscriber这个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Subscription</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从源码中我们可以看到，Subscriber是Observer的一个抽象实现类，所以我首先可以肯定的是Subscriber和Observer类型是一致的。接着往下我们看看subscribe()这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(<span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//这里的if判断对于我们要分享的问题没有关联，可以先无视</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (observer <span class=\"keyword\">instanceof</span> Subscriber) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> subscribe((Subscriber&lt;? <span class=\"keyword\">super</span> T&gt;)observer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> subscribe(<span class=\"keyword\">new</span> Subscriber&lt;T&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            observer.onCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            observer.onError(e);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">            observer.onNext(t);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到subscribe()方法内部首先将传进来的Observer做了一层代理，将它转换成了Subscriber。我们再看看这个方法内部的subscribe()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Observable.subscribe(subscriber, <span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进一步往下追踪看看return后面这段代码到底做了什么。精简掉其他无关代码后的subscribe(subscriber, this)方法是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    subscriber.onStart();</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</div><div class=\"line\">        <span class=\"keyword\">return</span> hook.onSubscribeReturn(subscriber);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Subscriptions.unsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们重点看看hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber),前面这个hook.onSubscribeStart(observable, observable.onSubscribe)返回的是它自己括号内的第二个参数observable.onSubscribe,然后调用了它的call方法。而这个observable.onSubscribe正是create()方法中的Subscriber，这样整个流程就理顺了。看到这里是不是对RxJava的执行流程清晰了一点呢？这里也建议大家在学习新技术的时候多去翻一翻源码，知其然还要能知其所以然不是吗。</p>\n<blockquote>\n<p>subscribe()的参数除了可以是Observer和Subscriber以外还可以是Action1、Action0；这是一种更简单的回调，只有一个call(T)方法；由于太简单这里就不做详细介绍了！</p>\n</blockquote>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>上一篇文章中开篇就讲到RxJava就是来处理异步任务的。但是默认情况下我们在哪个线程调用subscribe()就在哪个线程生产事件，在哪个线程生产事件就在哪个线程消费事件。那怎么做到异步呢？RxJava为我们提供Scheduler用来做线程调度，我们来看看RxJava提供了哪些Scheduler。</p>\n<table class=\"table table-striped\"><tr><th>Schedulers</th><th>作用</th></tr><tr><td>Schedulers.immediate()</td><td>默认的Scheduler，直接在当前线程运行</td></tr><tr><td>Schedulers.newThread()</td><td>总是开启一个新线程</td></tr><tr><td>Schedulers.io()</td><td>用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io()默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</td></tr><tr><td>Schedulers.computation()</td><td>计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU</td></tr><tr><td>Schedulers.from(executor)</td><td>使用指定的Executor作为调度器</td></tr><tr><td>Schedulers.trampoline()</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>RxAndroid中新增的Scheduler，表示在Android的main线程中运行</td></tr></table>\n\n<p>同时RxJava还为我们提供了<code>subscribeOn()</code>和<code>observeOn()</code>两个方法来指定Observable和Observer运行的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(getCommunitiesFromServer())</div><div class=\"line\">            .flatMap(community -&gt; Observable.from(community.houses))</div><div class=\"line\">            .filter(house -&gt; house.price&gt;=<span class=\"number\">5000000</span>).subscribeOn(Schedulers.io())</div><div class=\"line\">            .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">            .subscribe(<span class=\"keyword\">this</span>::addHouseInformationToScreen);</div></pre></td></tr></table></figure>\n<p>上面这段代码大家应该有印象吧，没错正是我们上一篇文章中的例子。<code>subscribeOn(Schedulers.io())</code>指定了获取小区列表、处理房源信息等一系列事件都是在IO线程中运行，<code>observeOn(AndroidSchedulers.mainThread())</code>指定了在屏幕上展示房源的操作在UI线程执行。这就做到了在子线程获取房源，主线程展示房源。</p>\n<p>好了，RxJava系列的入门内容我们就聊到这。下一篇我们再继续介绍更多的API以及它们内部的原理。</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>    </li>\n</ul>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>上一篇的示例代码中大家一定发现了Observable这个类。从纯Java的观点看，Observable类源自于经典的观察者模式。RxJava的异步实现正是基于观察者模式来实现的，而且是一种扩展的观察者模式。</p>\n<h2 id=\"观察者模式\"><a href=\"#观察者模式\" class=\"headerlink\" title=\"观察者模式\"></a>观察者模式</h2><p>观察者模式基于Subject这个概念，Subject是一种特殊对象，又叫做<strong>主题</strong>或者<strong>被观察者</strong>。当它改变时那些由它保存的一系列对象将会得到通知，而这一系列对象被称作Observer(<strong>观察者</strong>)。它们会对外暴漏了一个通知方法(比方说update之类的)，当Subject状态发生变化时会调用的这个方法。</p>\n<p>观察者模式很适合下面这些场景中的任何一个：</p>\n<ol>\n<li>当你的架构有两个实体类，一个依赖另一个，你想让它们互不影响或者是独立复用它们时。</li>\n<li>当一个变化的对象通知那些与它自身变化相关联的未知数量的对象时。</li>\n<li>当一个变化的对象通知那些无需推断具体类型的对象时。</li>\n</ol>\n<p>通常一个观察者模式的类图是这样的：</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/2/Observer.png\" alt=\"Observer\"></p>\n<p>如果你对观察者模式不是很了解，那么强烈建议你先去学习下。关于观察者模式的详细介绍可以参考我之前的文章：<a href=\"http://www.jianshu.com/p/d55ee6e83d66\">设计模式之观察者模式</a></p>\n<h2 id=\"扩展的观察者模式\"><a href=\"#扩展的观察者模式\" class=\"headerlink\" title=\"扩展的观察者模式\"></a>扩展的观察者模式</h2><p>在RxJava中主要有4个角色：</p>\n<ul>\n<li>Observable</li>\n<li>Subject</li>\n<li>Observer</li>\n<li>Subscriber</li>\n</ul>\n<p>Observable和Subject是两个“生产”实体，Observer和Subscriber是两个“消费”实体。说直白点<code>Observable</code>对应于观察者模式中的<strong>被观察者</strong>，而<code>Observer</code>和<code>Subscriber</code>对应于观察者模式中的<strong>观察者</strong>。<code>Subscriber</code>其实是一个实现了<code>Observer</code>的抽象类，后面我们分析源码的时候也会介绍到。<code>Subject</code>比较复杂，以后再分析。</p>\n<p>上一篇文章中我们说到RxJava中有个关键概念：<strong>事件</strong>。观察者<code>Observer</code>和被观察者<code>Observable</code>通过<code>subscribe()</code>方法实现订阅关系。从而<code>Observable</code> 可以在需要的时候发出<strong>事件</strong>来通知<code>Observer</code>。</p>\n<h2 id=\"RxJava如何使用\"><a href=\"#RxJava如何使用\" class=\"headerlink\" title=\"RxJava如何使用\"></a>RxJava如何使用</h2><p>我自己在学习一种新技术的时候通常喜欢先去了解它是怎么用的，掌握了使用方法后再去深挖其原理。那么我们现在就来说说RxJava到底该怎么用。</p>\n<p><strong>第一步：创建观察者Observer</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observer&lt;Object&gt; observer = <span class=\"keyword\">new</span> Observer&lt;Object&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Object s)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\"> &#125;;</div></pre></td></tr></table></figure>\n<p>这么简单，一个观察者Observer创建了!</p>\n<p>大兄弟你等等…，你之前那篇<a href=\"http://www.jianshu.com/p/d55ee6e83d66\">观察者模式</a>中不是说观察者只提供一个update方法的吗？这特么怎么有三个？！！</p>\n<p>少年勿急，且听我慢慢道来。在普通的观察者模式中观察者一般只会提供一个update()方法用于被观察者的状态发生变化时，用于提供给被观察者调用。而在RxJava中的观察者Observer提供了:<code>onNext()</code>、 <code>onCompleted()</code>和<code>onError()</code>三个方法。还记得吗？开篇我们讲过RxJava是基于一种扩展的观察这模式实现，这里多出的onCompleted和onError正是对观察者模式的扩展。<em>ps:onNext就相当于普通观察者模式中的update</em></p>\n<p>RxJava中添加了普通观察者模式缺失的三个功能：</p>\n<ol>\n<li>RxJava中规定当不再有新的事件发出时，可以调用onCompleted()方法作为标示；</li>\n<li>当事件处理出现异常时框架自动触发onError()方法；</li>\n<li>同时Observables支持链式调用，从而避免了回调嵌套的问题。</li>\n</ol>\n<p><strong>第二步：创建被观察者Observable</strong></p>\n<p><code>Observable.create()</code>方法可以创建一个Observable，使用<code>crate()</code>创建Observable需要一个OnSubscribe对象，这个对象继承Action1。当观察者订阅我们的Observable时，它作为一个参数传入并执行<code>call()</code>函数。 </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Object&gt; observable = Observable.create(<span class=\"keyword\">new</span> </div><div class=\"line\">        \tObservable.OnSubscribe&lt;Object&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Object&gt; subscriber)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>除了create()，just()和from()同样可以创建Observable。看看下面两个例子：</p>\n<p><code>just(T...)</code>将传入的参数依次发送</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable observable = Observable.just(<span class=\"string\">\"One\"</span>, <span class=\"string\">\"Two\"</span>, <span class=\"string\">\"Three\"</span>);</div><div class=\"line\"><span class=\"comment\">//上面这行代码会依次调用</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"One\");</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"Two\");</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"Three\");</span></div><div class=\"line\"><span class=\"comment\">//onCompleted();</span></div></pre></td></tr></table></figure>\n<p><code>from(T[])/from(Iterable&lt;? extends T&gt;)</code>将传入的数组或者Iterable拆分成Java对象依次发送</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">String[] parameters = &#123;<span class=\"string\">\"One\"</span>, <span class=\"string\">\"Two\"</span>, <span class=\"string\">\"Three\"</span>&#125;;</div><div class=\"line\">Observable observable = Observable.from(parameters);</div><div class=\"line\"><span class=\"comment\">//上面这行代码会依次调用</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"One\");</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"Two\");</span></div><div class=\"line\"><span class=\"comment\">//onNext(\"Three\");</span></div><div class=\"line\"><span class=\"comment\">//onCompleted();</span></div></pre></td></tr></table></figure>\n<p><strong>第三步：被观察者Observable订阅观察者Observer</strong>（<em>ps:你没看错，不同于普通的观察者模式，这里是被观察者订阅观察者</em>）</p>\n<p>有了观察者和被观察者，我们就可以通过subscribe()来实现二者的订阅关系了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div></pre></td><td class=\"code\"><pre><div class=\"line\">observable.subscribe(observer);</div></pre></td></tr></table></figure>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/2/subscribe1.png\" alt=\"observable.subscribe(observer)\"></p>\n<p>连在一起写就是这样：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; <span class=\"number\">5</span>; i++) &#123;</div><div class=\"line\">            subscriber.onNext(i);</div><div class=\"line\">        &#125;</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;Integer&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"onCompleted\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"onError\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Integer item)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Item is \"</span> + item);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>至此一个完整的RxJava调用就完成了。</p>\n<p>兄台，你叨逼叨叨逼叨的说了一大堆，可是我没搞定你特么到底在干啥啊？！！不急，我现在就来告诉你们到底发生了什么。</p>\n<p>首先我们使用Observable.create()创建了一个新的Observable<Integer>，并为<code>create()</code>方法传入了一个OnSubscribe，OnSubscribe中包含一个<code>call()</code>方法，一旦我们调用<code>subscribe()</code>订阅后就会自动触发call()方法。call()方法中的参数Subscriber其实就是subscribe()方法中的观察者Observer。我们在<code>call()</code>方法中调用了5次<code>onNext()</code>和1次<code>onCompleted()</code>方法。一套流程周下来以后输出结果就是下面这样的：</p>\n<pre><code>Item is 0\nItem is 1\nItem is 2\nItem is 3\nItem is 4\nonCompleted\n</code></pre><p>看到这里可能你又要说了，大兄弟你别唬我啊！OnSubscribe的call()方法中的参数Subscriber怎么就变成了subscribe()方法中的观察者Observer？！！！这俩儿货明明看起来就是两个不同的类啊。</p>\n<p>我们先看看Subscriber这个类：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Subscription</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>从源码中我们可以看到，Subscriber是Observer的一个抽象实现类，所以我首先可以肯定的是Subscriber和Observer类型是一致的。接着往下我们看看subscribe()这个方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(<span class=\"keyword\">final</span> Observer&lt;? <span class=\"keyword\">super</span> T&gt; observer)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//这里的if判断对于我们要分享的问题没有关联，可以先无视</span></div><div class=\"line\">    <span class=\"keyword\">if</span> (observer <span class=\"keyword\">instanceof</span> Subscriber) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> subscribe((Subscriber&lt;? <span class=\"keyword\">super</span> T&gt;)observer);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> subscribe(<span class=\"keyword\">new</span> Subscriber&lt;T&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            observer.onCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            observer.onError(e);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">            observer.onNext(t);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">    &#125;);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到subscribe()方法内部首先将传进来的Observer做了一层代理，将它转换成了Subscriber。我们再看看这个方法内部的subscribe()方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Observable.subscribe(subscriber, <span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>进一步往下追踪看看return后面这段代码到底做了什么。精简掉其他无关代码后的subscribe(subscriber, this)方法是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    subscriber.onStart();</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber);</div><div class=\"line\">        <span class=\"keyword\">return</span> hook.onSubscribeReturn(subscriber);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> Subscriptions.unsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们重点看看hook.onSubscribeStart(observable, observable.onSubscribe).call(subscriber),前面这个hook.onSubscribeStart(observable, observable.onSubscribe)返回的是它自己括号内的第二个参数observable.onSubscribe,然后调用了它的call方法。而这个observable.onSubscribe正是create()方法中的Subscriber，这样整个流程就理顺了。看到这里是不是对RxJava的执行流程清晰了一点呢？这里也建议大家在学习新技术的时候多去翻一翻源码，知其然还要能知其所以然不是吗。</p>\n<blockquote>\n<p>subscribe()的参数除了可以是Observer和Subscriber以外还可以是Action1、Action0；这是一种更简单的回调，只有一个call(T)方法；由于太简单这里就不做详细介绍了！</p>\n</blockquote>\n<h2 id=\"异步\"><a href=\"#异步\" class=\"headerlink\" title=\"异步\"></a>异步</h2><p>上一篇文章中开篇就讲到RxJava就是来处理异步任务的。但是默认情况下我们在哪个线程调用subscribe()就在哪个线程生产事件，在哪个线程生产事件就在哪个线程消费事件。那怎么做到异步呢？RxJava为我们提供Scheduler用来做线程调度，我们来看看RxJava提供了哪些Scheduler。</p>\n<table class=\"table table-striped\"><tr><th>Schedulers</th><th>作用</th></tr><tr><td>Schedulers.immediate()</td><td>默认的Scheduler，直接在当前线程运行</td></tr><tr><td>Schedulers.newThread()</td><td>总是开启一个新线程</td></tr><tr><td>Schedulers.io()</td><td>用于IO密集型任务，如异步阻塞IO操作，这个调度器的线程池会根据需要增长；对于普通的计算任务，请使用Schedulers.computation()；Schedulers.io()默认是一个CachedThreadScheduler，很像一个有线程缓存的新线程调度器</td></tr><tr><td>Schedulers.computation()</td><td>计算所使用的 Scheduler。这个计算指的是 CPU 密集型计算，即不会被 I/O 等操作限制性能的操作，例如图形的计算。这个 Scheduler 使用的固定的线程池，大小为 CPU 核数。不要把 I/O 操作放在 computation() 中，否则 I/O 操作的等待时间会浪费 CPU</td></tr><tr><td>Schedulers.from(executor)</td><td>使用指定的Executor作为调度器</td></tr><tr><td>Schedulers.trampoline()</td><td>当其它排队的任务完成后，在当前线程排队开始执行</td></tr><tr><td>AndroidSchedulers.mainThread()</td><td>RxAndroid中新增的Scheduler，表示在Android的main线程中运行</td></tr></table>\n\n<p>同时RxJava还为我们提供了<code>subscribeOn()</code>和<code>observeOn()</code>两个方法来指定Observable和Observer运行的线程。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(getCommunitiesFromServer())</div><div class=\"line\">            .flatMap(community -&gt; Observable.from(community.houses))</div><div class=\"line\">            .filter(house -&gt; house.price&gt;=<span class=\"number\">5000000</span>).subscribeOn(Schedulers.io())</div><div class=\"line\">            .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">            .subscribe(<span class=\"keyword\">this</span>::addHouseInformationToScreen);</div></pre></td></tr></table></figure>\n<p>上面这段代码大家应该有印象吧，没错正是我们上一篇文章中的例子。<code>subscribeOn(Schedulers.io())</code>指定了获取小区列表、处理房源信息等一系列事件都是在IO线程中运行，<code>observeOn(AndroidSchedulers.mainThread())</code>指定了在屏幕上展示房源的操作在UI线程执行。这就做到了在子线程获取房源，主线程展示房源。</p>\n<p>好了，RxJava系列的入门内容我们就聊到这。下一篇我们再继续介绍更多的API以及它们内部的原理。</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"RxJava系列3(转换操作符)","date":"2017-02-05T16:20:19.000Z","_content":"\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)   \n\n\n***\n前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：\n\n1. **转换类操作符**\n2. **过滤类操作符**\n3. **组合类操作符**\n\n这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。\n\n### Map\n\n**`map(Func1)`**函数接受一个Func1类型的参数(就像这样`map(Func1<? super T, ? extends R> func)`),然后吧这个Func1应用到每一个由Observable发射的值上，将发射的只转换为我们期望的值。这种狗屁定义我相信你也听不懂，我们来看一下官方给出的原理图：\n\n![map(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/MapOperator.png)\n\n假设我们需要将一组数字装换成字符串，我们可以通过map这样实现：\n\n```java\nObservable.just(1, 2, 3, 4, 5)\n        .map(new Func1<Integer, String>() {\n\n            @Override\n            public String call(Integer i) {\n                return \"This is \" + i;\n            }\n        }).subscribe(new Action1<String>() {\n            @Override\n            public void call(String s) {\n                System.out.println(s);\n            }\n        });\n ```\n           \n > Func1构造函数中的两个参数分别是Observable发射值当前的类型和map转换后的类型，上面这个例子中发射值当前的类型是Integer,转换后的类型是String。\n\n### FlatMap\n**`flatMap(Func1)`**函数同样也是做转换的，但是作用却不一样。flatMap不太好理解，我们直接看例子（*我们公司是个房产平台，那我就拿房子举例*）：假设我们有一组小区数据`Community[] communites`,现在我们要输出每个小区的名字；我们可以这样实现:\n\n```java\nObservable.from(communities)\n        .map(new Func1<Community, String>() {\n\n            @Override\n            public String call(Community community) {\n                return community.name;\n            }\n        })\n        .subscribe(new Action1<String>() {\n            @Override\n            public void call(String name) {\n                System.out.println(\"Community name : \" + name);\n            }\n        });\n```\n\n现在我们需求有变化，需要打印出每个小区下面每一套房子的价格。于是我可以这样实现：\n\n```java\nCommunity[] communities = {};\nObservable.from(communities)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                for (House house : community.houses) {\n                    System.out.println(\"House price : \" + house.price);\n                }\n            }\n        });\n```            \n            \n如果我不想在Subscriber中使用for循环，而是希望Subscriber中直接传入单个的House对象呢？用map()显然是不行的，因为map()是一对一的转化，而我现在的要求是一对多的转化。那么我们可以使用flatMap()把一个Community转化成多个House。\n            \n```java\nObservable.from(communities)\n        .flatMap(new Func1<Community, Observable<House>>() {\n            @Override\n            public Observable<House> call(Community community) {\n                return Observable.from(community.houses);\n            }\n        })\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"House price : \" + house.price);\n            }\n        });\n```            \n            \n从前面的例子中我们发现，flatMap()和map()都是把传入的参数转化之后返回另一个对象。但和map()不同的是，flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到 Subscriber的回调方法中。\n\nflatMap(Func1)的原理是这样的：\n\n1. 将传入的事件对象装换成一个Observable对象；\n2. 这是不会直接发送这个Observable, 而是将这个Observable激活让它自己开始发送事件；\n3. 每一个创建出来的Observable发送的事件，都被汇入同一个Observable，这个Observable负责将这些事件统一交给Subscriber的回调方法。\n\n这三个步骤，把事件拆成了两级，通过一组新创建的Observable将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是flatMap()所谓的flat。\n\n最后我们来看看flatMap的原理图：\n![flatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapOperator.png)\n\n### ConcatMap\n**`concatMap(Func1)`**解决了`flatMap()`的交叉问题，它能够把发射的值连续在一起，就像这样：\n![concatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ConcatMapOperator.png)\n\n### flatMapIterable\n**`flatMapIterable(Func1)`**和`flatMap()`几乎是一样的，不同的是`flatMapIterable()`它转化的多个Observable是使用Iterable作为源数据的。\n![flatMapIterable(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapIterableOperator.png)\n\n```java\nObservable.from(communities)\n        .flatMapIterable(new Func1<Community, Iterable<House>>() {\n            @Override\n            public Iterable<House> call(Community community) {\n                return community.houses;\n            }\n        })\n        .subscribe(new Action1<House>() {\n\n            @Override\n            public void call(House house) {\n\n            }\n        });\n```\n\n### SwitchMap\n**`switchMap(Func1)`**和`flatMap(Func1)`很像，除了一点：每当源`Observable`发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的`Observable`，并开始监视当前发射的这一个。\n![switchMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/SwitchMapOperator.png)\n\n### Scan\n**`scan(Func2)`**对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用合格函数时的第一个参数使用。\n![scan(Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ScanOperator.png)\n\n我们来看个简单的例子：\n\n```java\nObservable.just(1, 2, 3, 4, 5)\n        .scan(new Func2<Integer, Integer, Integer>() {\n            @Override\n            public Integer call(Integer integer, Integer integer2) {\n                return integer + integer2;\n            }\n        }).subscribe(new Action1<Integer>() {\n    @Override\n    public void call(Integer integer) {\n        System.out.print(integer+“ ”);\n    }\n});\n```\n\n输出结果为：\n\n\t1 3 6 10 15  \n\n### GroupBy\n**`groupBy(Func1)`**将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小Observable分别发射其所包含的的数据，和SQL中的groupBy类似。实际使用中，我们需要提供一个生成key的规则（也就是Func1中的call方法），所有key相同的数据会包含在同一个小的Observable中。另外我们还可以提供一个函数来对这些数据进行转化，有点类似于集成了flatMap。\n![groupBy(Func1)](GroupByOperator.png)\n\n单纯的文字描述和图片解释可能难以理解，我们来看个例子：假设我现在有一组房源`List<House> houses`,每套房子都属于某一个小区，现在我们需要根据小区名来对房源进行分类，然后依次将房源信息输出。\n\n```java\nList<House> houses = new ArrayList<>();\nhouses.add(new House(\"中粮·海景壹号\", \"中粮海景壹号新出大平层！总价4500W起\"));\nhouses.add(new House(\"竹园新村\", \"满五唯一，黄金地段\"));\nhouses.add(new House(\"中粮·海景壹号\", \"毗邻汤臣一品\"));\nhouses.add(new House(\"竹园新村\", \"顶层户型，两室一厅\"));\nhouses.add(new House(\"中粮·海景壹号\", \"南北通透，豪华五房\"));\nObservable<GroupedObservable<String, House>> groupByCommunityNameObservable = Observable.from(houses)\n        .groupBy(new Func1<House, String>() {\n\n            @Override\n            public String call(House house) {\n                return house.communityName;\n            }\n        });\n```\n            \n通过上面的代码我们创建了一个新的Observable:`groupByCommunityNameObservable`，它将会发送一个带有`GroupedObservable`的序列（也就是指发送的数据项的类型为GroupedObservable）。`GroupedObservable`是一个特殊的`Observable`，它基于一个分组的key，在这个例子中的key就是小区名。现在我们需要将分类后的房源依次输出：\n\n```java\nObservable.concat(groupByCommunityNameObservable)\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\"+house.communityName+\"; 房源描述:\"+house.desc);\n            }\n        });\n```\n\n执行结果：\n\n\t小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n\t小区:中粮·海景壹号; 房源描述:毗邻汤臣一品\n\t小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n\t小区:竹园新村; 房源描述:满五唯一，黄金地段\n\t小区:竹园新村; 房源描述:顶层户型，两室一厅\n\t\n转换类的操作符就先介绍到这，后续还会继续介绍组合、过滤类的操作符及源码分析，敬请期待！\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","source":"_posts/2017-02-06-RxJava系列3-转换操作符.md","raw":"---\ntitle: RxJava系列3(转换操作符)\ndate: 2017-02-06 00:20:19\ncategories: rxjava\ntags: \n- RxJava\n- Android\n---\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)   \n\n\n***\n前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：\n\n1. **转换类操作符**\n2. **过滤类操作符**\n3. **组合类操作符**\n\n这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。\n\n### Map\n\n**`map(Func1)`**函数接受一个Func1类型的参数(就像这样`map(Func1<? super T, ? extends R> func)`),然后吧这个Func1应用到每一个由Observable发射的值上，将发射的只转换为我们期望的值。这种狗屁定义我相信你也听不懂，我们来看一下官方给出的原理图：\n\n![map(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/MapOperator.png)\n\n假设我们需要将一组数字装换成字符串，我们可以通过map这样实现：\n\n```java\nObservable.just(1, 2, 3, 4, 5)\n        .map(new Func1<Integer, String>() {\n\n            @Override\n            public String call(Integer i) {\n                return \"This is \" + i;\n            }\n        }).subscribe(new Action1<String>() {\n            @Override\n            public void call(String s) {\n                System.out.println(s);\n            }\n        });\n ```\n           \n > Func1构造函数中的两个参数分别是Observable发射值当前的类型和map转换后的类型，上面这个例子中发射值当前的类型是Integer,转换后的类型是String。\n\n### FlatMap\n**`flatMap(Func1)`**函数同样也是做转换的，但是作用却不一样。flatMap不太好理解，我们直接看例子（*我们公司是个房产平台，那我就拿房子举例*）：假设我们有一组小区数据`Community[] communites`,现在我们要输出每个小区的名字；我们可以这样实现:\n\n```java\nObservable.from(communities)\n        .map(new Func1<Community, String>() {\n\n            @Override\n            public String call(Community community) {\n                return community.name;\n            }\n        })\n        .subscribe(new Action1<String>() {\n            @Override\n            public void call(String name) {\n                System.out.println(\"Community name : \" + name);\n            }\n        });\n```\n\n现在我们需求有变化，需要打印出每个小区下面每一套房子的价格。于是我可以这样实现：\n\n```java\nCommunity[] communities = {};\nObservable.from(communities)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                for (House house : community.houses) {\n                    System.out.println(\"House price : \" + house.price);\n                }\n            }\n        });\n```            \n            \n如果我不想在Subscriber中使用for循环，而是希望Subscriber中直接传入单个的House对象呢？用map()显然是不行的，因为map()是一对一的转化，而我现在的要求是一对多的转化。那么我们可以使用flatMap()把一个Community转化成多个House。\n            \n```java\nObservable.from(communities)\n        .flatMap(new Func1<Community, Observable<House>>() {\n            @Override\n            public Observable<House> call(Community community) {\n                return Observable.from(community.houses);\n            }\n        })\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"House price : \" + house.price);\n            }\n        });\n```            \n            \n从前面的例子中我们发现，flatMap()和map()都是把传入的参数转化之后返回另一个对象。但和map()不同的是，flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到 Subscriber的回调方法中。\n\nflatMap(Func1)的原理是这样的：\n\n1. 将传入的事件对象装换成一个Observable对象；\n2. 这是不会直接发送这个Observable, 而是将这个Observable激活让它自己开始发送事件；\n3. 每一个创建出来的Observable发送的事件，都被汇入同一个Observable，这个Observable负责将这些事件统一交给Subscriber的回调方法。\n\n这三个步骤，把事件拆成了两级，通过一组新创建的Observable将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是flatMap()所谓的flat。\n\n最后我们来看看flatMap的原理图：\n![flatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapOperator.png)\n\n### ConcatMap\n**`concatMap(Func1)`**解决了`flatMap()`的交叉问题，它能够把发射的值连续在一起，就像这样：\n![concatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ConcatMapOperator.png)\n\n### flatMapIterable\n**`flatMapIterable(Func1)`**和`flatMap()`几乎是一样的，不同的是`flatMapIterable()`它转化的多个Observable是使用Iterable作为源数据的。\n![flatMapIterable(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapIterableOperator.png)\n\n```java\nObservable.from(communities)\n        .flatMapIterable(new Func1<Community, Iterable<House>>() {\n            @Override\n            public Iterable<House> call(Community community) {\n                return community.houses;\n            }\n        })\n        .subscribe(new Action1<House>() {\n\n            @Override\n            public void call(House house) {\n\n            }\n        });\n```\n\n### SwitchMap\n**`switchMap(Func1)`**和`flatMap(Func1)`很像，除了一点：每当源`Observable`发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的`Observable`，并开始监视当前发射的这一个。\n![switchMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/SwitchMapOperator.png)\n\n### Scan\n**`scan(Func2)`**对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用合格函数时的第一个参数使用。\n![scan(Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ScanOperator.png)\n\n我们来看个简单的例子：\n\n```java\nObservable.just(1, 2, 3, 4, 5)\n        .scan(new Func2<Integer, Integer, Integer>() {\n            @Override\n            public Integer call(Integer integer, Integer integer2) {\n                return integer + integer2;\n            }\n        }).subscribe(new Action1<Integer>() {\n    @Override\n    public void call(Integer integer) {\n        System.out.print(integer+“ ”);\n    }\n});\n```\n\n输出结果为：\n\n\t1 3 6 10 15  \n\n### GroupBy\n**`groupBy(Func1)`**将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小Observable分别发射其所包含的的数据，和SQL中的groupBy类似。实际使用中，我们需要提供一个生成key的规则（也就是Func1中的call方法），所有key相同的数据会包含在同一个小的Observable中。另外我们还可以提供一个函数来对这些数据进行转化，有点类似于集成了flatMap。\n![groupBy(Func1)](GroupByOperator.png)\n\n单纯的文字描述和图片解释可能难以理解，我们来看个例子：假设我现在有一组房源`List<House> houses`,每套房子都属于某一个小区，现在我们需要根据小区名来对房源进行分类，然后依次将房源信息输出。\n\n```java\nList<House> houses = new ArrayList<>();\nhouses.add(new House(\"中粮·海景壹号\", \"中粮海景壹号新出大平层！总价4500W起\"));\nhouses.add(new House(\"竹园新村\", \"满五唯一，黄金地段\"));\nhouses.add(new House(\"中粮·海景壹号\", \"毗邻汤臣一品\"));\nhouses.add(new House(\"竹园新村\", \"顶层户型，两室一厅\"));\nhouses.add(new House(\"中粮·海景壹号\", \"南北通透，豪华五房\"));\nObservable<GroupedObservable<String, House>> groupByCommunityNameObservable = Observable.from(houses)\n        .groupBy(new Func1<House, String>() {\n\n            @Override\n            public String call(House house) {\n                return house.communityName;\n            }\n        });\n```\n            \n通过上面的代码我们创建了一个新的Observable:`groupByCommunityNameObservable`，它将会发送一个带有`GroupedObservable`的序列（也就是指发送的数据项的类型为GroupedObservable）。`GroupedObservable`是一个特殊的`Observable`，它基于一个分组的key，在这个例子中的key就是小区名。现在我们需要将分类后的房源依次输出：\n\n```java\nObservable.concat(groupByCommunityNameObservable)\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\"+house.communityName+\"; 房源描述:\"+house.desc);\n            }\n        });\n```\n\n执行结果：\n\n\t小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n\t小区:中粮·海景壹号; 房源描述:毗邻汤臣一品\n\t小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n\t小区:竹园新村; 房源描述:满五唯一，黄金地段\n\t小区:竹园新村; 房源描述:顶层户型，两室一厅\n\t\n转换类的操作符就先介绍到这，后续还会继续介绍组合、过滤类的操作符及源码分析，敬请期待！\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","slug":"RxJava系列3-转换操作符","published":1,"updated":"2017-02-05T17:58:43.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26er000i6st6n19yui71","content":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>   </li>\n</ul>\n<hr>\n<p>前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：</p>\n<ol>\n<li><strong>转换类操作符</strong></li>\n<li><strong>过滤类操作符</strong></li>\n<li><strong>组合类操作符</strong></li>\n</ol>\n<p>这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p><strong><code>map(Func1)</code></strong>函数接受一个Func1类型的参数(就像这样<code>map(Func1&lt;? super T, ? extends R&gt; func)</code>),然后吧这个Func1应用到每一个由Observable发射的值上，将发射的只转换为我们期望的值。这种狗屁定义我相信你也听不懂，我们来看一下官方给出的原理图：</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/MapOperator.png\" alt=\"map(Func1)\"></p>\n<p>假设我们需要将一组数字装换成字符串，我们可以通过map这样实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Integer i)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"This is \"</span> + i;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">                System.out.println(s);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Func1构造函数中的两个参数分别是Observable发射值当前的类型和map转换后的类型，上面这个例子中发射值当前的类型是Integer,转换后的类型是String。</p>\n</blockquote>\n<h3 id=\"FlatMap\"><a href=\"#FlatMap\" class=\"headerlink\" title=\"FlatMap\"></a>FlatMap</h3><p><strong><code>flatMap(Func1)</code></strong>函数同样也是做转换的，但是作用却不一样。flatMap不太好理解，我们直接看例子（<em>我们公司是个房产平台，那我就拿房子举例</em>）：假设我们有一组小区数据<code>Community[] communites</code>,现在我们要输出每个小区的名字；我们可以这样实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Community, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Community community)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> community.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"Community name : \"</span> + name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>现在我们需求有变化，需要打印出每个小区下面每一套房子的价格。于是我可以这样实现：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">Community[] communities = &#123;&#125;;</div><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Community community) &#123;</div><div class=\"line\">                for (House house : community.houses) &#123;</div><div class=\"line\">                    System.out.println(\"House price : \" + house.price);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">```            </div><div class=\"line\">            </div><div class=\"line\">如果我不想在Subscriber中使用for循环，而是希望Subscriber中直接传入单个的House对象呢？用map()显然是不行的，因为map()是一对一的转化，而我现在的要求是一对多的转化。那么我们可以使用flatMap()把一个Community转化成多个House。</div><div class=\"line\">            </div><div class=\"line\">```java</div><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public Observable&lt;House&gt; call(Community community) &#123;</div><div class=\"line\">                return Observable.from(community.houses);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(House house) &#123;</div><div class=\"line\">                System.out.println(\"House price : \" + house.price);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">```            </div><div class=\"line\">            </div><div class=\"line\">从前面的例子中我们发现，flatMap()和map()都是把传入的参数转化之后返回另一个对象。但和map()不同的是，flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到 Subscriber的回调方法中。</div><div class=\"line\"></div><div class=\"line\">flatMap(Func1)的原理是这样的：</div><div class=\"line\"></div><div class=\"line\">1. 将传入的事件对象装换成一个Observable对象；</div><div class=\"line\">2. 这是不会直接发送这个Observable, 而是将这个Observable激活让它自己开始发送事件；</div><div class=\"line\">3. 每一个创建出来的Observable发送的事件，都被汇入同一个Observable，这个Observable负责将这些事件统一交给Subscriber的回调方法。</div><div class=\"line\"></div><div class=\"line\">这三个步骤，把事件拆成了两级，通过一组新创建的Observable将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是flatMap()所谓的flat。</div><div class=\"line\"></div><div class=\"line\">最后我们来看看flatMap的原理图：</div><div class=\"line\">![flatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapOperator.png)</div><div class=\"line\"></div><div class=\"line\">### ConcatMap</div><div class=\"line\">**`concatMap(Func1)`**解决了`flatMap()`的交叉问题，它能够把发射的值连续在一起，就像这样：</div><div class=\"line\">![concatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ConcatMapOperator.png)</div><div class=\"line\"></div><div class=\"line\">### flatMapIterable</div><div class=\"line\">**`flatMapIterable(Func1)`**和`flatMap()`几乎是一样的，不同的是`flatMapIterable()`它转化的多个Observable是使用Iterable作为源数据的。</div><div class=\"line\">![flatMapIterable(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapIterableOperator.png)</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .flatMapIterable(new Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public Iterable&lt;House&gt; call(Community community) &#123;</div><div class=\"line\">                return community.houses;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(House house) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"SwitchMap\"><a href=\"#SwitchMap\" class=\"headerlink\" title=\"SwitchMap\"></a>SwitchMap</h3><p><strong><code>switchMap(Func1)</code></strong>和<code>flatMap(Func1)</code>很像，除了一点：每当源<code>Observable</code>发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的<code>Observable</code>，并开始监视当前发射的这一个。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/SwitchMapOperator.png\" alt=\"switchMap(Func1)\"></p>\n<h3 id=\"Scan\"><a href=\"#Scan\" class=\"headerlink\" title=\"Scan\"></a>Scan</h3><p><strong><code>scan(Func2)</code></strong>对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用合格函数时的第一个参数使用。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ScanOperator.png\" alt=\"scan(Func2)\"></p>\n<p>我们来看个简单的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\">        .scan(<span class=\"keyword\">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">call</span><span class=\"params\">(Integer integer, Integer integer2)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> integer + integer2;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;Integer&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">        System.out.print(integer+“ ”);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<pre><code>1 3 6 10 15  \n</code></pre><h3 id=\"GroupBy\"><a href=\"#GroupBy\" class=\"headerlink\" title=\"GroupBy\"></a>GroupBy</h3><p><strong><code>groupBy(Func1)</code></strong>将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小Observable分别发射其所包含的的数据，和SQL中的groupBy类似。实际使用中，我们需要提供一个生成key的规则（也就是Func1中的call方法），所有key相同的数据会包含在同一个小的Observable中。另外我们还可以提供一个函数来对这些数据进行转化，有点类似于集成了flatMap。<br><img src=\"GroupByOperator.png\" alt=\"groupBy(Func1)\"></p>\n<p>单纯的文字描述和图片解释可能难以理解，我们来看个例子：假设我现在有一组房源<code>List&lt;House&gt; houses</code>,每套房子都属于某一个小区，现在我们需要根据小区名来对房源进行分类，然后依次将房源信息输出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;House&gt; houses = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"中粮海景壹号新出大平层！总价4500W起\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"满五唯一，黄金地段\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"毗邻汤臣一品\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"顶层户型，两室一厅\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"南北通透，豪华五房\"</span>));</div><div class=\"line\">Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable.from(houses)</div><div class=\"line\">        .groupBy(<span class=\"keyword\">new</span> Func1&lt;House, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> house.communityName;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>通过上面的代码我们创建了一个新的Observable:<code>groupByCommunityNameObservable</code>，它将会发送一个带有<code>GroupedObservable</code>的序列（也就是指发送的数据项的类型为GroupedObservable）。<code>GroupedObservable</code>是一个特殊的<code>Observable</code>，它基于一个分组的key，在这个例子中的key就是小区名。现在我们需要将分类后的房源依次输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.concat(groupByCommunityNameObservable)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span>+house.communityName+<span class=\"string\">\"; 房源描述:\"</span>+house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n小区:中粮·海景壹号; 房源描述:毗邻汤臣一品\n小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n小区:竹园新村; 房源描述:满五唯一，黄金地段\n小区:竹园新村; 房源描述:顶层户型，两室一厅\n</code></pre><p>转换类的操作符就先介绍到这，后续还会继续介绍组合、过滤类的操作符及源码分析，敬请期待！</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>   </li>\n</ul>\n<hr>\n<p>前面两篇文章中我们介绍了RxJava的一些基本概念和RxJava最简单的用法。从这一章开始，我们开始聊聊RxJava中的操作符Operators，后面我将用三章的篇幅来分别介绍：</p>\n<ol>\n<li><strong>转换类操作符</strong></li>\n<li><strong>过滤类操作符</strong></li>\n<li><strong>组合类操作符</strong></li>\n</ol>\n<p>这一章我们主要讲讲转换类操作符。所有这些Operators都作用于一个可观测序列，然后变换它发射的值，最后用一种新的形式返回它们。概念实在是不好理解，下面我们结合实际的例子一一介绍。</p>\n<h3 id=\"Map\"><a href=\"#Map\" class=\"headerlink\" title=\"Map\"></a>Map</h3><p><strong><code>map(Func1)</code></strong>函数接受一个Func1类型的参数(就像这样<code>map(Func1&lt;? super T, ? extends R&gt; func)</code>),然后吧这个Func1应用到每一个由Observable发射的值上，将发射的只转换为我们期望的值。这种狗屁定义我相信你也听不懂，我们来看一下官方给出的原理图：</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/MapOperator.png\" alt=\"map(Func1)\"></p>\n<p>假设我们需要将一组数字装换成字符串，我们可以通过map这样实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Integer i)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"This is \"</span> + i;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">                System.out.println(s);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<blockquote>\n<p>Func1构造函数中的两个参数分别是Observable发射值当前的类型和map转换后的类型，上面这个例子中发射值当前的类型是Integer,转换后的类型是String。</p>\n</blockquote>\n<h3 id=\"FlatMap\"><a href=\"#FlatMap\" class=\"headerlink\" title=\"FlatMap\"></a>FlatMap</h3><p><strong><code>flatMap(Func1)</code></strong>函数同样也是做转换的，但是作用却不一样。flatMap不太好理解，我们直接看例子（<em>我们公司是个房产平台，那我就拿房子举例</em>）：假设我们有一组小区数据<code>Community[] communites</code>,现在我们要输出每个小区的名字；我们可以这样实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Community, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Community community)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> community.name;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(String name)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"Community name : \"</span> + name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>现在我们需求有变化，需要打印出每个小区下面每一套房子的价格。于是我可以这样实现：</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div></pre></td><td class=\"code\"><pre><div class=\"line\">Community[] communities = &#123;&#125;;</div><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Community community) &#123;</div><div class=\"line\">                for (House house : community.houses) &#123;</div><div class=\"line\">                    System.out.println(\"House price : \" + house.price);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">```            </div><div class=\"line\">            </div><div class=\"line\">如果我不想在Subscriber中使用for循环，而是希望Subscriber中直接传入单个的House对象呢？用map()显然是不行的，因为map()是一对一的转化，而我现在的要求是一对多的转化。那么我们可以使用flatMap()把一个Community转化成多个House。</div><div class=\"line\">            </div><div class=\"line\">```java</div><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .flatMap(new Func1&lt;Community, Observable&lt;House&gt;&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public Observable&lt;House&gt; call(Community community) &#123;</div><div class=\"line\">                return Observable.from(community.houses);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(House house) &#123;</div><div class=\"line\">                System.out.println(\"House price : \" + house.price);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">```            </div><div class=\"line\">            </div><div class=\"line\">从前面的例子中我们发现，flatMap()和map()都是把传入的参数转化之后返回另一个对象。但和map()不同的是，flatMap()中返回的是Observable对象，并且这个Observable对象并不是被直接发送到 Subscriber的回调方法中。</div><div class=\"line\"></div><div class=\"line\">flatMap(Func1)的原理是这样的：</div><div class=\"line\"></div><div class=\"line\">1. 将传入的事件对象装换成一个Observable对象；</div><div class=\"line\">2. 这是不会直接发送这个Observable, 而是将这个Observable激活让它自己开始发送事件；</div><div class=\"line\">3. 每一个创建出来的Observable发送的事件，都被汇入同一个Observable，这个Observable负责将这些事件统一交给Subscriber的回调方法。</div><div class=\"line\"></div><div class=\"line\">这三个步骤，把事件拆成了两级，通过一组新创建的Observable将初始的对象『铺平』之后通过统一路径分发了下去。而这个『铺平』就是flatMap()所谓的flat。</div><div class=\"line\"></div><div class=\"line\">最后我们来看看flatMap的原理图：</div><div class=\"line\">![flatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapOperator.png)</div><div class=\"line\"></div><div class=\"line\">### ConcatMap</div><div class=\"line\">**`concatMap(Func1)`**解决了`flatMap()`的交叉问题，它能够把发射的值连续在一起，就像这样：</div><div class=\"line\">![concatMap(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ConcatMapOperator.png)</div><div class=\"line\"></div><div class=\"line\">### flatMapIterable</div><div class=\"line\">**`flatMapIterable(Func1)`**和`flatMap()`几乎是一样的，不同的是`flatMapIterable()`它转化的多个Observable是使用Iterable作为源数据的。</div><div class=\"line\">![flatMapIterable(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/FlatMapIterableOperator.png)</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .flatMapIterable(new Func1&lt;Community, Iterable&lt;House&gt;&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public Iterable&lt;House&gt; call(Community community) &#123;</div><div class=\"line\">                return community.houses;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(new Action1&lt;House&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(House house) &#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"SwitchMap\"><a href=\"#SwitchMap\" class=\"headerlink\" title=\"SwitchMap\"></a>SwitchMap</h3><p><strong><code>switchMap(Func1)</code></strong>和<code>flatMap(Func1)</code>很像，除了一点：每当源<code>Observable</code>发射一个新的数据项（Observable）时，它将取消订阅并停止监视之前那个数据项产生的<code>Observable</code>，并开始监视当前发射的这一个。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/SwitchMapOperator.png\" alt=\"switchMap(Func1)\"></p>\n<h3 id=\"Scan\"><a href=\"#Scan\" class=\"headerlink\" title=\"Scan\"></a>Scan</h3><p><strong><code>scan(Func2)</code></strong>对一个序列的数据应用一个函数，并将这个函数的结果发射出去作为下个数据应用合格函数时的第一个参数使用。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/map/ScanOperator.png\" alt=\"scan(Func2)\"></p>\n<p>我们来看个简单的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>)</div><div class=\"line\">        .scan(<span class=\"keyword\">new</span> Func2&lt;Integer, Integer, Integer&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Integer <span class=\"title\">call</span><span class=\"params\">(Integer integer, Integer integer2)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> integer + integer2;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;Integer&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">        System.out.print(integer+“ ”);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>输出结果为：</p>\n<pre><code>1 3 6 10 15  \n</code></pre><h3 id=\"GroupBy\"><a href=\"#GroupBy\" class=\"headerlink\" title=\"GroupBy\"></a>GroupBy</h3><p><strong><code>groupBy(Func1)</code></strong>将原始Observable发射的数据按照key来拆分成一些小的Observable，然后这些小Observable分别发射其所包含的的数据，和SQL中的groupBy类似。实际使用中，我们需要提供一个生成key的规则（也就是Func1中的call方法），所有key相同的数据会包含在同一个小的Observable中。另外我们还可以提供一个函数来对这些数据进行转化，有点类似于集成了flatMap。<br><img src=\"GroupByOperator.png\" alt=\"groupBy(Func1)\"></p>\n<p>单纯的文字描述和图片解释可能难以理解，我们来看个例子：假设我现在有一组房源<code>List&lt;House&gt; houses</code>,每套房子都属于某一个小区，现在我们需要根据小区名来对房源进行分类，然后依次将房源信息输出。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;House&gt; houses = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"中粮海景壹号新出大平层！总价4500W起\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"满五唯一，黄金地段\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"毗邻汤臣一品\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"顶层户型，两室一厅\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"南北通透，豪华五房\"</span>));</div><div class=\"line\">Observable&lt;GroupedObservable&lt;String, House&gt;&gt; groupByCommunityNameObservable = Observable.from(houses)</div><div class=\"line\">        .groupBy(<span class=\"keyword\">new</span> Func1&lt;House, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> house.communityName;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>通过上面的代码我们创建了一个新的Observable:<code>groupByCommunityNameObservable</code>，它将会发送一个带有<code>GroupedObservable</code>的序列（也就是指发送的数据项的类型为GroupedObservable）。<code>GroupedObservable</code>是一个特殊的<code>Observable</code>，它基于一个分组的key，在这个例子中的key就是小区名。现在我们需要将分类后的房源依次输出：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.concat(groupByCommunityNameObservable)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span>+house.communityName+<span class=\"string\">\"; 房源描述:\"</span>+house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>执行结果：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n小区:中粮·海景壹号; 房源描述:毗邻汤臣一品\n小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n小区:竹园新村; 房源描述:满五唯一，黄金地段\n小区:竹园新村; 房源描述:顶层户型，两室一厅\n</code></pre><p>转换类的操作符就先介绍到这，后续还会继续介绍组合、过滤类的操作符及源码分析，敬请期待！</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"RxJava系列4(过滤操作符)","date":"2017-02-05T16:20:33.000Z","_content":"\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)  \n\n***\n前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： **`Filter`** **`Take`** **`TakeLast`** **`TakeUntil`** **`Skip`** **`SkipLast`** **`ElementAt`** **`Debounce`** **`Distinct`** **`DistinctUntilChanged`** **`First`** **`Last`**等等。\n\n### Filter\n**`filter(Func1)`**用来过滤观测序列中我们不想要的值，只返回满足条件的值，我们看下原理图：\n![filter(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FilterOperator.png)\n\n还是拿前面文章中的小区`Community[] communities`来举例，假设我需要赛选出所有房源数大于10个的小区，我们可以这样实现：\n\n```java\nObservable.from(communities)\n        .filter(new Func1<Community, Boolean>() {\n            @Override\n            public Boolean call(Community community) {\n                return community.houses.size()>10;\n            }\n        }).subscribe(new Action1<Community>() {\n    @Override\n    public void call(Community community) {\n        System.out.println(community.name);\n    }\n}); \n```\n\n### Take\n**`take(int)`**用一个整数n作为一个参数，从原始的序列中发射前n个元素.\n![take(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeOperator.png)\n\n现在我们需要取小区列表`communities`中的前10个小区\n\n```java\nObservable.from(communities)\n        .take(10)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                System.out.println(community.name);\n            }\n        });\n```     \n\n### TakeLast\n**`takeLast(int)`**同样用一个整数n作为参数，只不过它发射的是观测序列中后n个元素。\n![takeLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeLastNOperator.png)\n\n获取小区列表`communities`中的后3个小区\n\n```java\nObservable.from(communities)\n        .takeLast(3)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                System.out.println(community.name);\n            }\n        });\n```\n\n### TakeUntil\n**`takeUntil(Observable)`**订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，`takeUntil()`返回的Observable会停止发射原始Observable并终止。\n![takeUntil(Observable)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilOperator.png)\n\n```java\nObservable<Long> observableA = Observable.interval(300, TimeUnit.MILLISECONDS);\nObservable<Long> observableB = Observable.interval(800, TimeUnit.MILLISECONDS);\n\nobservableA.takeUntil(observableB)\n        .subscribe(new Subscriber<Long>() {\n            @Override\n            public void onCompleted() {\n                System.exit(0);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Long aLong) {\n                System.out.println(aLong);\n            }\n        });\n\ntry {\n    Thread.sleep(Integer.MAX_VALUE);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n程序输出：\n\n\t0\n\t1\n\n\n**`takeUntil(Func1)`**通过Func1中的call方法来判断是否需要终止发射数据。\n![takeUntil(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilPOperator.png)\n\n```java\nObservable.just(1, 2, 3, 4, 5, 6, 7)\n                .takeUntil(new Func1<Integer, Boolean>() {\n                    @Override\n                    public Boolean call(Integer integer) {\n                        return integer >= 5;\n                    }\n                }).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer integer) {\n                System.out.println(integer);\n            }\n        });\n```\n\n程序输出：\n\n\t1\n\t2\n\t3\n\t4\n\t5\n\n\n###Skip\n**`skip(int)`**让我们可以忽略Observable发射的前n项数据。\n![skip(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipOperator.png)\n\n过滤掉小区列表`communities`中的前5个小区\n\n```java\nObservable.from(communities)\n        .skip(5)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                System.out.println(community.name);\n            }\n        });\n```        \n\n### SkipLast\n**`skipLast(int)`**忽略Observable发射的后n项数据。\n![skipLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipLastOperator.png)\n\n### ElementAt\n**`elementAt(int)`**用来获取元素Observable发射的事件序列中的第n项数据，并当做唯一的数据发射出去。\n![elementAt(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/ElementAtOperator.png)\n\n### Debounce\n**`debounce(long, TimeUnit)`**过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBing(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。\n![debounce(long, TimeUnit)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceOperator.png)\n\n**`debounce(Func1)`**可以根据Func1的call方法中的函数来过滤，Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。\n![debounce(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceFOperator.png)\n\n### Distinct\n**`distinct()`**的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。\n![distinct()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctOperator.png)\n\n过滤掉一段数字中的重复项：\n\n```java\nObservable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)\n        .distinct()\n        .subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer i) {\n                System.out.print(i + \" \");\n            }\n        });\n```\n            \n程序输出：\n\t\n\t2 1 3 4 5 \n\n**`distinct(Func1)`**参数中的Func1中的call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是不是相同；如果判定为重复则会和`distinct()`一样过滤掉重复的数据项。\n![distinct(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctKeyOperator.png)\n\n假设我们要过滤掉一堆房源中小区名重复的小区：\n\n```java\nList<House> houses = new ArrayList<>();\n//House构造函数中的第一个参数为该房源所属小区名，第二个参数为房源描述\nList<House> houses = new ArrayList<>();\nhouses.add(new House(\"中粮·海景壹号\", \"中粮海景壹号新出大平层！总价4500W起\"));\nhouses.add(new House(\"竹园新村\", \"满五唯一，黄金地段\"));\nhouses.add(new House(\"竹园新村\", \"一楼自带小花园\"));\nhouses.add(new House(\"中粮·海景壹号\", \"毗邻汤臣一品\"));\nhouses.add(new House(\"中粮·海景壹号\", \"顶级住宅，给您总统般尊贵体验\"));\nhouses.add(new House(\"竹园新村\", \"顶层户型，两室一厅\"));\nhouses.add(new House(\"中粮·海景壹号\", \"南北通透，豪华五房\"));\nObservable.from(houses)\n        .distinct(new Func1<House, String>() {\n\n            @Override\n            public String call(House house) {\n                return house.communityName;\n            }\n        }).subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }\n        });            \n```\n           \n程序输出：\n\n\t小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n\t小区:竹园新村; 房源描述:满五唯一，黄金地段\n\n### DistinctUntilChanged\n**`distinctUntilChanged()`**和`distinct()`类似，只不过它判定的是Observable发射的当前数据项和前一个数据项是否相同。\n![distinctUntilChanged()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedOperator.png)\n\n同样还是上面过滤数字的例子：\n\n```\nObservable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)\n        .distinctUntilChanged()\n        .subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer i) {\n                System.out.print(i + \" \");\n            }\n        });\n```\n      \n程序输出：\n\t\n\t2 1 2 3 4 3 4 5 \n\n**`distinctUntilChanged(Func1)`**和`distinct(Func1)`一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。\n![distinctUntilChanged(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedKeyOperator.png)\n\n我们还是拿前面的过滤房源的例子：\n\n```java\nObservable.from(houses)\n        .distinctUntilChanged(new Func1<House, String>() {\n\n            @Override\n            public String call(House house) {\n                return house.communityName;\n            }\n        }).subscribe(new Action1<House>() {\n    @Override\n    public void call(House house) {\n        System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n    }\n});\n```\n    \n程序输出：\n\n\t小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n\t小区:竹园新村; 房源描述:满五唯一，黄金地段\n\t小区:中粮·海景壹号; 房源描述:毗邻汤臣一品\n\t小区:竹园新村; 房源描述:顶层户型，两室一厅\n\t小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n\n\n### First\n**`first()`**顾名思义，它是的Observable只发送观测序列中的第一个数据项。\n![first()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstOperator.png)\n\n获取房源列表`houses`中的第一套房源：\n\n```java\nObservable.from(houses)\n        .first()\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }                \n        });\n```\n\n程序输出：\n\n\t小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n\n**`first(Func1)`**只发送符合条件的第一个数据项。\n![first(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstNOperator.png)\n\n现在我们要获取房源列表`houses`中小区名为*竹园新村*的第一套房源。\n\n```java\nObservable.from(houses)\n        .first(new Func1<House, Boolean>() {\n            @Override\n            public Boolean call(House house) {\n                return \"竹园新村\".equals(house.communityName);\n            }\n        })\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }\n        });\n```\n            \n程序输出：\n\n\t小区:竹园新村; 房源描述:满五唯一，黄金地段\n\n### Last\n**`last()`**只发射观测序列中的最后一个数据项。\n![last()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastOperator.png)\n\n获取房源列表中的最后一套房源：\n\n```java\nObservable.from(houses)\n        .last()\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }\n        });\n```\n           \n程序输出：\n\n\t小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n\n**`last(Func1)`**只发射观测序列中符合条件的最后一个数据项。\n![last(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastPOperator.png)\n\n获取房源列表`houses`中小区名为*竹园新村*的最后一套房源：\n\n```java\nObservable.from(houses)\n        .last(new Func1<House, Boolean>() {\n            @Override\n            public Boolean call(House house) {\n                return \"竹园新村\".equals(house.communityName);\n            }\n        })\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }\n        });\n```\n        \n程序输出：\n\n\t小区:竹园新村; 房源描述:顶层户型，两室一厅\n\n这一章我们就先聊到这，更多的过滤类操作符的介绍大家可以去查阅官方文档和源码；在下一章我们将继续介绍组合类操作符。\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","source":"_posts/2017-02-06-RxJava系列4-过滤操作符.md","raw":"---\ntitle: RxJava系列4(过滤操作符)\ndate: 2017-02-06 00:20:33\ncategories: rxjava\ntags: \n- RxJava\n- Android\n---\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)  \n\n***\n前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： **`Filter`** **`Take`** **`TakeLast`** **`TakeUntil`** **`Skip`** **`SkipLast`** **`ElementAt`** **`Debounce`** **`Distinct`** **`DistinctUntilChanged`** **`First`** **`Last`**等等。\n\n### Filter\n**`filter(Func1)`**用来过滤观测序列中我们不想要的值，只返回满足条件的值，我们看下原理图：\n![filter(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FilterOperator.png)\n\n还是拿前面文章中的小区`Community[] communities`来举例，假设我需要赛选出所有房源数大于10个的小区，我们可以这样实现：\n\n```java\nObservable.from(communities)\n        .filter(new Func1<Community, Boolean>() {\n            @Override\n            public Boolean call(Community community) {\n                return community.houses.size()>10;\n            }\n        }).subscribe(new Action1<Community>() {\n    @Override\n    public void call(Community community) {\n        System.out.println(community.name);\n    }\n}); \n```\n\n### Take\n**`take(int)`**用一个整数n作为一个参数，从原始的序列中发射前n个元素.\n![take(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeOperator.png)\n\n现在我们需要取小区列表`communities`中的前10个小区\n\n```java\nObservable.from(communities)\n        .take(10)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                System.out.println(community.name);\n            }\n        });\n```     \n\n### TakeLast\n**`takeLast(int)`**同样用一个整数n作为参数，只不过它发射的是观测序列中后n个元素。\n![takeLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeLastNOperator.png)\n\n获取小区列表`communities`中的后3个小区\n\n```java\nObservable.from(communities)\n        .takeLast(3)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                System.out.println(community.name);\n            }\n        });\n```\n\n### TakeUntil\n**`takeUntil(Observable)`**订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，`takeUntil()`返回的Observable会停止发射原始Observable并终止。\n![takeUntil(Observable)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilOperator.png)\n\n```java\nObservable<Long> observableA = Observable.interval(300, TimeUnit.MILLISECONDS);\nObservable<Long> observableB = Observable.interval(800, TimeUnit.MILLISECONDS);\n\nobservableA.takeUntil(observableB)\n        .subscribe(new Subscriber<Long>() {\n            @Override\n            public void onCompleted() {\n                System.exit(0);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n\n            }\n\n            @Override\n            public void onNext(Long aLong) {\n                System.out.println(aLong);\n            }\n        });\n\ntry {\n    Thread.sleep(Integer.MAX_VALUE);\n} catch (InterruptedException e) {\n    e.printStackTrace();\n}\n```\n\n程序输出：\n\n\t0\n\t1\n\n\n**`takeUntil(Func1)`**通过Func1中的call方法来判断是否需要终止发射数据。\n![takeUntil(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilPOperator.png)\n\n```java\nObservable.just(1, 2, 3, 4, 5, 6, 7)\n                .takeUntil(new Func1<Integer, Boolean>() {\n                    @Override\n                    public Boolean call(Integer integer) {\n                        return integer >= 5;\n                    }\n                }).subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer integer) {\n                System.out.println(integer);\n            }\n        });\n```\n\n程序输出：\n\n\t1\n\t2\n\t3\n\t4\n\t5\n\n\n###Skip\n**`skip(int)`**让我们可以忽略Observable发射的前n项数据。\n![skip(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipOperator.png)\n\n过滤掉小区列表`communities`中的前5个小区\n\n```java\nObservable.from(communities)\n        .skip(5)\n        .subscribe(new Action1<Community>() {\n            @Override\n            public void call(Community community) {\n                System.out.println(community.name);\n            }\n        });\n```        \n\n### SkipLast\n**`skipLast(int)`**忽略Observable发射的后n项数据。\n![skipLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipLastOperator.png)\n\n### ElementAt\n**`elementAt(int)`**用来获取元素Observable发射的事件序列中的第n项数据，并当做唯一的数据发射出去。\n![elementAt(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/ElementAtOperator.png)\n\n### Debounce\n**`debounce(long, TimeUnit)`**过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBing(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。\n![debounce(long, TimeUnit)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceOperator.png)\n\n**`debounce(Func1)`**可以根据Func1的call方法中的函数来过滤，Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。\n![debounce(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceFOperator.png)\n\n### Distinct\n**`distinct()`**的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。\n![distinct()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctOperator.png)\n\n过滤掉一段数字中的重复项：\n\n```java\nObservable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)\n        .distinct()\n        .subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer i) {\n                System.out.print(i + \" \");\n            }\n        });\n```\n            \n程序输出：\n\t\n\t2 1 3 4 5 \n\n**`distinct(Func1)`**参数中的Func1中的call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是不是相同；如果判定为重复则会和`distinct()`一样过滤掉重复的数据项。\n![distinct(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctKeyOperator.png)\n\n假设我们要过滤掉一堆房源中小区名重复的小区：\n\n```java\nList<House> houses = new ArrayList<>();\n//House构造函数中的第一个参数为该房源所属小区名，第二个参数为房源描述\nList<House> houses = new ArrayList<>();\nhouses.add(new House(\"中粮·海景壹号\", \"中粮海景壹号新出大平层！总价4500W起\"));\nhouses.add(new House(\"竹园新村\", \"满五唯一，黄金地段\"));\nhouses.add(new House(\"竹园新村\", \"一楼自带小花园\"));\nhouses.add(new House(\"中粮·海景壹号\", \"毗邻汤臣一品\"));\nhouses.add(new House(\"中粮·海景壹号\", \"顶级住宅，给您总统般尊贵体验\"));\nhouses.add(new House(\"竹园新村\", \"顶层户型，两室一厅\"));\nhouses.add(new House(\"中粮·海景壹号\", \"南北通透，豪华五房\"));\nObservable.from(houses)\n        .distinct(new Func1<House, String>() {\n\n            @Override\n            public String call(House house) {\n                return house.communityName;\n            }\n        }).subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }\n        });            \n```\n           \n程序输出：\n\n\t小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n\t小区:竹园新村; 房源描述:满五唯一，黄金地段\n\n### DistinctUntilChanged\n**`distinctUntilChanged()`**和`distinct()`类似，只不过它判定的是Observable发射的当前数据项和前一个数据项是否相同。\n![distinctUntilChanged()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedOperator.png)\n\n同样还是上面过滤数字的例子：\n\n```\nObservable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)\n        .distinctUntilChanged()\n        .subscribe(new Action1<Integer>() {\n            @Override\n            public void call(Integer i) {\n                System.out.print(i + \" \");\n            }\n        });\n```\n      \n程序输出：\n\t\n\t2 1 2 3 4 3 4 5 \n\n**`distinctUntilChanged(Func1)`**和`distinct(Func1)`一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。\n![distinctUntilChanged(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedKeyOperator.png)\n\n我们还是拿前面的过滤房源的例子：\n\n```java\nObservable.from(houses)\n        .distinctUntilChanged(new Func1<House, String>() {\n\n            @Override\n            public String call(House house) {\n                return house.communityName;\n            }\n        }).subscribe(new Action1<House>() {\n    @Override\n    public void call(House house) {\n        System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n    }\n});\n```\n    \n程序输出：\n\n\t小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n\t小区:竹园新村; 房源描述:满五唯一，黄金地段\n\t小区:中粮·海景壹号; 房源描述:毗邻汤臣一品\n\t小区:竹园新村; 房源描述:顶层户型，两室一厅\n\t小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n\n\n### First\n**`first()`**顾名思义，它是的Observable只发送观测序列中的第一个数据项。\n![first()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstOperator.png)\n\n获取房源列表`houses`中的第一套房源：\n\n```java\nObservable.from(houses)\n        .first()\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }                \n        });\n```\n\n程序输出：\n\n\t小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n\n**`first(Func1)`**只发送符合条件的第一个数据项。\n![first(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstNOperator.png)\n\n现在我们要获取房源列表`houses`中小区名为*竹园新村*的第一套房源。\n\n```java\nObservable.from(houses)\n        .first(new Func1<House, Boolean>() {\n            @Override\n            public Boolean call(House house) {\n                return \"竹园新村\".equals(house.communityName);\n            }\n        })\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }\n        });\n```\n            \n程序输出：\n\n\t小区:竹园新村; 房源描述:满五唯一，黄金地段\n\n### Last\n**`last()`**只发射观测序列中的最后一个数据项。\n![last()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastOperator.png)\n\n获取房源列表中的最后一套房源：\n\n```java\nObservable.from(houses)\n        .last()\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }\n        });\n```\n           \n程序输出：\n\n\t小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n\n**`last(Func1)`**只发射观测序列中符合条件的最后一个数据项。\n![last(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastPOperator.png)\n\n获取房源列表`houses`中小区名为*竹园新村*的最后一套房源：\n\n```java\nObservable.from(houses)\n        .last(new Func1<House, Boolean>() {\n            @Override\n            public Boolean call(House house) {\n                return \"竹园新村\".equals(house.communityName);\n            }\n        })\n        .subscribe(new Action1<House>() {\n            @Override\n            public void call(House house) {\n                System.out.println(\"小区:\" + house.communityName + \"; 房源描述:\" + house.desc);\n            }\n        });\n```\n        \n程序输出：\n\n\t小区:竹园新村; 房源描述:顶层户型，两室一厅\n\n这一章我们就先聊到这，更多的过滤类操作符的介绍大家可以去查阅官方文档和源码；在下一章我们将继续介绍组合类操作符。\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","slug":"RxJava系列4-过滤操作符","published":1,"updated":"2017-02-05T17:58:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26et000k6st6xq04puwy","content":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>  </li>\n</ul>\n<hr>\n<p>前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： <strong><code>Filter</code></strong> <strong><code>Take</code></strong> <strong><code>TakeLast</code></strong> <strong><code>TakeUntil</code></strong> <strong><code>Skip</code></strong> <strong><code>SkipLast</code></strong> <strong><code>ElementAt</code></strong> <strong><code>Debounce</code></strong> <strong><code>Distinct</code></strong> <strong><code>DistinctUntilChanged</code></strong> <strong><code>First</code></strong> <strong><code>Last</code></strong>等等。</p>\n<h3 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h3><p><strong><code>filter(Func1)</code></strong>用来过滤观测序列中我们不想要的值，只返回满足条件的值，我们看下原理图：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FilterOperator.png\" alt=\"filter(Func1)\"></p>\n<p>还是拿前面文章中的小区<code>Community[] communities</code>来举例，假设我需要赛选出所有房源数大于10个的小区，我们可以这样实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .filter(<span class=\"keyword\">new</span> Func1&lt;Community, Boolean&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Community community)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> community.houses.size()&gt;<span class=\"number\">10</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;Community&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Community community)</span> </span>&#123;</div><div class=\"line\">        System.out.println(community.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"Take\"><a href=\"#Take\" class=\"headerlink\" title=\"Take\"></a>Take</h3><p><strong><code>take(int)</code></strong>用一个整数n作为一个参数，从原始的序列中发射前n个元素.<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeOperator.png\" alt=\"take(int)\"></p>\n<p>现在我们需要取小区列表<code>communities</code>中的前10个小区</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .take(10)</div><div class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Community community) &#123;</div><div class=\"line\">                System.out.println(community.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">```     </div><div class=\"line\"></div><div class=\"line\">### TakeLast</div><div class=\"line\">**`takeLast(int)`**同样用一个整数n作为参数，只不过它发射的是观测序列中后n个元素。</div><div class=\"line\">![takeLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeLastNOperator.png)</div><div class=\"line\"></div><div class=\"line\">获取小区列表`communities`中的后3个小区</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .takeLast(3)</div><div class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Community community) &#123;</div><div class=\"line\">                System.out.println(community.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"TakeUntil\"><a href=\"#TakeUntil\" class=\"headerlink\" title=\"TakeUntil\"></a>TakeUntil</h3><p><strong><code>takeUntil(Observable)</code></strong>订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，<code>takeUntil()</code>返回的Observable会停止发射原始Observable并终止。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilOperator.png\" alt=\"takeUntil(Observable)\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Long&gt; observableA = Observable.interval(<span class=\"number\">300</span>, TimeUnit.MILLISECONDS);</div><div class=\"line\">Observable&lt;Long&gt; observableB = Observable.interval(<span class=\"number\">800</span>, TimeUnit.MILLISECONDS);</div><div class=\"line\"></div><div class=\"line\">observableA.takeUntil(observableB)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;Long&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Long aLong)</span> </span>&#123;</div><div class=\"line\">                System.out.println(aLong);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    Thread.sleep(Integer.MAX_VALUE);</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">    e.printStackTrace();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>0\n1\n</code></pre><p><strong><code>takeUntil(Func1)</code></strong>通过Func1中的call方法来判断是否需要终止发射数据。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilPOperator.png\" alt=\"takeUntil(Func1)\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">                .takeUntil(<span class=\"keyword\">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> integer &gt;= <span class=\"number\">5</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;Integer&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">                System.out.println(integer);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>1\n2\n3\n4\n5\n</code></pre><p>###Skip<br><strong><code>skip(int)</code></strong>让我们可以忽略Observable发射的前n项数据。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipOperator.png\" alt=\"skip(int)\"></p>\n<p>过滤掉小区列表<code>communities</code>中的前5个小区</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .skip(5)</div><div class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Community community) &#123;</div><div class=\"line\">                System.out.println(community.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">### SkipLast</div><div class=\"line\">**`skipLast(int)`**忽略Observable发射的后n项数据。</div><div class=\"line\">![skipLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipLastOperator.png)</div><div class=\"line\"></div><div class=\"line\">### ElementAt</div><div class=\"line\">**`elementAt(int)`**用来获取元素Observable发射的事件序列中的第n项数据，并当做唯一的数据发射出去。</div><div class=\"line\">![elementAt(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/ElementAtOperator.png)</div><div class=\"line\"></div><div class=\"line\">### Debounce</div><div class=\"line\">**`debounce(long, TimeUnit)`**过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBing(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</div><div class=\"line\">![debounce(long, TimeUnit)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceOperator.png)</div><div class=\"line\"></div><div class=\"line\">**`debounce(Func1)`**可以根据Func1的call方法中的函数来过滤，Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。</div><div class=\"line\">![debounce(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceFOperator.png)</div><div class=\"line\"></div><div class=\"line\">### Distinct</div><div class=\"line\">**`distinct()`**的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。</div><div class=\"line\">![distinct()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctOperator.png)</div><div class=\"line\"></div><div class=\"line\">过滤掉一段数字中的重复项：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class=\"line\">        .distinct()</div><div class=\"line\">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Integer i) &#123;</div><div class=\"line\">                System.out.print(i + \" \");</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>2 1 3 4 5 \n</code></pre><p><strong><code>distinct(Func1)</code></strong>参数中的Func1中的call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是不是相同；如果判定为重复则会和<code>distinct()</code>一样过滤掉重复的数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctKeyOperator.png\" alt=\"distinct(Func1)\"></p>\n<p>假设我们要过滤掉一堆房源中小区名重复的小区：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;House&gt; houses = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"><span class=\"comment\">//House构造函数中的第一个参数为该房源所属小区名，第二个参数为房源描述</span></div><div class=\"line\">List&lt;House&gt; houses = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"中粮海景壹号新出大平层！总价4500W起\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"满五唯一，黄金地段\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"一楼自带小花园\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"毗邻汤臣一品\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"顶级住宅，给您总统般尊贵体验\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"顶层户型，两室一厅\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"南北通透，豪华五房\"</span>));</div><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .distinct(<span class=\"keyword\">new</span> Func1&lt;House, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> house.communityName;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n小区:竹园新村; 房源描述:满五唯一，黄金地段\n</code></pre><h3 id=\"DistinctUntilChanged\"><a href=\"#DistinctUntilChanged\" class=\"headerlink\" title=\"DistinctUntilChanged\"></a>DistinctUntilChanged</h3><p><strong><code>distinctUntilChanged()</code></strong>和<code>distinct()</code>类似，只不过它判定的是Observable发射的当前数据项和前一个数据项是否相同。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedOperator.png\" alt=\"distinctUntilChanged()\"></p>\n<p>同样还是上面过滤数字的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class=\"line\">        .distinctUntilChanged()</div><div class=\"line\">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Integer i) &#123;</div><div class=\"line\">                System.out.print(i + &quot; &quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>2 1 2 3 4 3 4 5 \n</code></pre><p><strong><code>distinctUntilChanged(Func1)</code></strong>和<code>distinct(Func1)</code>一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedKeyOperator.png\" alt=\"distinctUntilChanged(Func1)\"></p>\n<p>我们还是拿前面的过滤房源的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .distinctUntilChanged(<span class=\"keyword\">new</span> Func1&lt;House, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> house.communityName;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n小区:竹园新村; 房源描述:满五唯一，黄金地段\n小区:中粮·海景壹号; 房源描述:毗邻汤臣一品\n小区:竹园新村; 房源描述:顶层户型，两室一厅\n小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n</code></pre><h3 id=\"First\"><a href=\"#First\" class=\"headerlink\" title=\"First\"></a>First</h3><p><strong><code>first()</code></strong>顾名思义，它是的Observable只发送观测序列中的第一个数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstOperator.png\" alt=\"first()\"></p>\n<p>获取房源列表<code>houses</code>中的第一套房源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .first()</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;                </div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n</code></pre><p><strong><code>first(Func1)</code></strong>只发送符合条件的第一个数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstNOperator.png\" alt=\"first(Func1)\"></p>\n<p>现在我们要获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的第一套房源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .first(<span class=\"keyword\">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"竹园新村\"</span>.equals(house.communityName);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:竹园新村; 房源描述:满五唯一，黄金地段\n</code></pre><h3 id=\"Last\"><a href=\"#Last\" class=\"headerlink\" title=\"Last\"></a>Last</h3><p><strong><code>last()</code></strong>只发射观测序列中的最后一个数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastOperator.png\" alt=\"last()\"></p>\n<p>获取房源列表中的最后一套房源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .last()</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n</code></pre><p><strong><code>last(Func1)</code></strong>只发射观测序列中符合条件的最后一个数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastPOperator.png\" alt=\"last(Func1)\"></p>\n<p>获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的最后一套房源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .last(<span class=\"keyword\">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"竹园新村\"</span>.equals(house.communityName);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:竹园新村; 房源描述:顶层户型，两室一厅\n</code></pre><p>这一章我们就先聊到这，更多的过滤类操作符的介绍大家可以去查阅官方文档和源码；在下一章我们将继续介绍组合类操作符。</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>  </li>\n</ul>\n<hr>\n<p>前面一篇文章中我们介绍了转换类操作符，那么这一章我们就来介绍下过滤类的操作符。顾名思义，这类operators主要用于对事件数据的筛选过滤，只返回满足我们条件的数据。过滤类操作符主要包含： <strong><code>Filter</code></strong> <strong><code>Take</code></strong> <strong><code>TakeLast</code></strong> <strong><code>TakeUntil</code></strong> <strong><code>Skip</code></strong> <strong><code>SkipLast</code></strong> <strong><code>ElementAt</code></strong> <strong><code>Debounce</code></strong> <strong><code>Distinct</code></strong> <strong><code>DistinctUntilChanged</code></strong> <strong><code>First</code></strong> <strong><code>Last</code></strong>等等。</p>\n<h3 id=\"Filter\"><a href=\"#Filter\" class=\"headerlink\" title=\"Filter\"></a>Filter</h3><p><strong><code>filter(Func1)</code></strong>用来过滤观测序列中我们不想要的值，只返回满足条件的值，我们看下原理图：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FilterOperator.png\" alt=\"filter(Func1)\"></p>\n<p>还是拿前面文章中的小区<code>Community[] communities</code>来举例，假设我需要赛选出所有房源数大于10个的小区，我们可以这样实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .filter(<span class=\"keyword\">new</span> Func1&lt;Community, Boolean&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Community community)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> community.houses.size()&gt;<span class=\"number\">10</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;Community&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Community community)</span> </span>&#123;</div><div class=\"line\">        System.out.println(community.name);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"Take\"><a href=\"#Take\" class=\"headerlink\" title=\"Take\"></a>Take</h3><p><strong><code>take(int)</code></strong>用一个整数n作为一个参数，从原始的序列中发射前n个元素.<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeOperator.png\" alt=\"take(int)\"></p>\n<p>现在我们需要取小区列表<code>communities</code>中的前10个小区</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .take(10)</div><div class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Community community) &#123;</div><div class=\"line\">                System.out.println(community.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">```     </div><div class=\"line\"></div><div class=\"line\">### TakeLast</div><div class=\"line\">**`takeLast(int)`**同样用一个整数n作为参数，只不过它发射的是观测序列中后n个元素。</div><div class=\"line\">![takeLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeLastNOperator.png)</div><div class=\"line\"></div><div class=\"line\">获取小区列表`communities`中的后3个小区</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .takeLast(3)</div><div class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Community community) &#123;</div><div class=\"line\">                System.out.println(community.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"TakeUntil\"><a href=\"#TakeUntil\" class=\"headerlink\" title=\"TakeUntil\"></a>TakeUntil</h3><p><strong><code>takeUntil(Observable)</code></strong>订阅并开始发射原始Observable，同时监视我们提供的第二个Observable。如果第二个Observable发射了一项数据或者发射了一个终止通知，<code>takeUntil()</code>返回的Observable会停止发射原始Observable并终止。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilOperator.png\" alt=\"takeUntil(Observable)\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Long&gt; observableA = Observable.interval(<span class=\"number\">300</span>, TimeUnit.MILLISECONDS);</div><div class=\"line\">Observable&lt;Long&gt; observableB = Observable.interval(<span class=\"number\">800</span>, TimeUnit.MILLISECONDS);</div><div class=\"line\"></div><div class=\"line\">observableA.takeUntil(observableB)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;Long&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Long aLong)</span> </span>&#123;</div><div class=\"line\">                System.out.println(aLong);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">try</span> &#123;</div><div class=\"line\">    Thread.sleep(Integer.MAX_VALUE);</div><div class=\"line\">&#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</div><div class=\"line\">    e.printStackTrace();</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>0\n1\n</code></pre><p><strong><code>takeUntil(Func1)</code></strong>通过Func1中的call方法来判断是否需要终止发射数据。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/TakeUntilPOperator.png\" alt=\"takeUntil(Func1)\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(<span class=\"number\">1</span>, <span class=\"number\">2</span>, <span class=\"number\">3</span>, <span class=\"number\">4</span>, <span class=\"number\">5</span>, <span class=\"number\">6</span>, <span class=\"number\">7</span>)</div><div class=\"line\">                .takeUntil(<span class=\"keyword\">new</span> Func1&lt;Integer, Boolean&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> integer &gt;= <span class=\"number\">5</span>;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;Integer&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">                System.out.println(integer);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>1\n2\n3\n4\n5\n</code></pre><p>###Skip<br><strong><code>skip(int)</code></strong>让我们可以忽略Observable发射的前n项数据。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipOperator.png\" alt=\"skip(int)\"></p>\n<p>过滤掉小区列表<code>communities</code>中的前5个小区</p>\n<figure class=\"highlight\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(communities)</div><div class=\"line\">        .skip(5)</div><div class=\"line\">        .subscribe(new Action1&lt;Community&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Community community) &#123;</div><div class=\"line\">                System.out.println(community.name);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">```        </div><div class=\"line\"></div><div class=\"line\">### SkipLast</div><div class=\"line\">**`skipLast(int)`**忽略Observable发射的后n项数据。</div><div class=\"line\">![skipLast(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/SkipLastOperator.png)</div><div class=\"line\"></div><div class=\"line\">### ElementAt</div><div class=\"line\">**`elementAt(int)`**用来获取元素Observable发射的事件序列中的第n项数据，并当做唯一的数据发射出去。</div><div class=\"line\">![elementAt(int)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/ElementAtOperator.png)</div><div class=\"line\"></div><div class=\"line\">### Debounce</div><div class=\"line\">**`debounce(long, TimeUnit)`**过滤掉了由Observable发射的速率过快的数据；如果在一个指定的时间间隔过去了仍旧没有发射一个，那么它将发射最后的那个。通常我们用来结合RxBing(Jake Wharton大神使用RxJava封装的Android UI组件)使用，防止button重复点击。</div><div class=\"line\">![debounce(long, TimeUnit)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceOperator.png)</div><div class=\"line\"></div><div class=\"line\">**`debounce(Func1)`**可以根据Func1的call方法中的函数来过滤，Func1中的中的call方法返回了一个临时的Observable，如果原始的Observable在发射一个新的数据时，上一个数据根据Func1的call方法生成的临时Observable还没结束，那么上一个数据就会被过滤掉。</div><div class=\"line\">![debounce(Func1)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DebounceFOperator.png)</div><div class=\"line\"></div><div class=\"line\">### Distinct</div><div class=\"line\">**`distinct()`**的过滤规则是只允许还没有发射过的数据通过，所有重复的数据项都只会发射一次。</div><div class=\"line\">![distinct()](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctOperator.png)</div><div class=\"line\"></div><div class=\"line\">过滤掉一段数字中的重复项：</div><div class=\"line\"></div><div class=\"line\">```java</div><div class=\"line\">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class=\"line\">        .distinct()</div><div class=\"line\">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Integer i) &#123;</div><div class=\"line\">                System.out.print(i + \" \");</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>2 1 3 4 5 \n</code></pre><p><strong><code>distinct(Func1)</code></strong>参数中的Func1中的call方法会根据Observable发射的值生成一个Key，然后比较这个key来判断两个数据是不是相同；如果判定为重复则会和<code>distinct()</code>一样过滤掉重复的数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctKeyOperator.png\" alt=\"distinct(Func1)\"></p>\n<p>假设我们要过滤掉一堆房源中小区名重复的小区：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;House&gt; houses = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\"><span class=\"comment\">//House构造函数中的第一个参数为该房源所属小区名，第二个参数为房源描述</span></div><div class=\"line\">List&lt;House&gt; houses = <span class=\"keyword\">new</span> ArrayList&lt;&gt;();</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"中粮海景壹号新出大平层！总价4500W起\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"满五唯一，黄金地段\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"一楼自带小花园\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"毗邻汤臣一品\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"顶级住宅，给您总统般尊贵体验\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"竹园新村\"</span>, <span class=\"string\">\"顶层户型，两室一厅\"</span>));</div><div class=\"line\">houses.add(<span class=\"keyword\">new</span> House(<span class=\"string\">\"中粮·海景壹号\"</span>, <span class=\"string\">\"南北通透，豪华五房\"</span>));</div><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .distinct(<span class=\"keyword\">new</span> Func1&lt;House, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> house.communityName;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n小区:竹园新村; 房源描述:满五唯一，黄金地段\n</code></pre><h3 id=\"DistinctUntilChanged\"><a href=\"#DistinctUntilChanged\" class=\"headerlink\" title=\"DistinctUntilChanged\"></a>DistinctUntilChanged</h3><p><strong><code>distinctUntilChanged()</code></strong>和<code>distinct()</code>类似，只不过它判定的是Observable发射的当前数据项和前一个数据项是否相同。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedOperator.png\" alt=\"distinctUntilChanged()\"></p>\n<p>同样还是上面过滤数字的例子：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.just(2, 1, 2, 2, 3, 4, 3, 4, 5, 5)</div><div class=\"line\">        .distinctUntilChanged()</div><div class=\"line\">        .subscribe(new Action1&lt;Integer&gt;() &#123;</div><div class=\"line\">            @Override</div><div class=\"line\">            public void call(Integer i) &#123;</div><div class=\"line\">                System.out.print(i + &quot; &quot;);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>2 1 2 3 4 3 4 5 \n</code></pre><p><strong><code>distinctUntilChanged(Func1)</code></strong>和<code>distinct(Func1)</code>一样，根据Func1中call方法产生一个Key来判断两个相邻的数据项是否相同。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/DistinctUntilChangedKeyOperator.png\" alt=\"distinctUntilChanged(Func1)\"></p>\n<p>我们还是拿前面的过滤房源的例子：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .distinctUntilChanged(<span class=\"keyword\">new</span> Func1&lt;House, String&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> house.communityName;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n小区:竹园新村; 房源描述:满五唯一，黄金地段\n小区:中粮·海景壹号; 房源描述:毗邻汤臣一品\n小区:竹园新村; 房源描述:顶层户型，两室一厅\n小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n</code></pre><h3 id=\"First\"><a href=\"#First\" class=\"headerlink\" title=\"First\"></a>First</h3><p><strong><code>first()</code></strong>顾名思义，它是的Observable只发送观测序列中的第一个数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstOperator.png\" alt=\"first()\"></p>\n<p>获取房源列表<code>houses</code>中的第一套房源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .first()</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;                </div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:中粮海景壹号新出大平层！总价4500W起\n</code></pre><p><strong><code>first(Func1)</code></strong>只发送符合条件的第一个数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/FirstNOperator.png\" alt=\"first(Func1)\"></p>\n<p>现在我们要获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的第一套房源。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .first(<span class=\"keyword\">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"竹园新村\"</span>.equals(house.communityName);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:竹园新村; 房源描述:满五唯一，黄金地段\n</code></pre><h3 id=\"Last\"><a href=\"#Last\" class=\"headerlink\" title=\"Last\"></a>Last</h3><p><strong><code>last()</code></strong>只发射观测序列中的最后一个数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastOperator.png\" alt=\"last()\"></p>\n<p>获取房源列表中的最后一套房源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .last()</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:中粮·海景壹号; 房源描述:南北通透，豪华五房\n</code></pre><p><strong><code>last(Func1)</code></strong>只发射观测序列中符合条件的最后一个数据项。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/filter/LastPOperator.png\" alt=\"last(Func1)\"></p>\n<p>获取房源列表<code>houses</code>中小区名为<em>竹园新村</em>的最后一套房源：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.from(houses)</div><div class=\"line\">        .last(<span class=\"keyword\">new</span> Func1&lt;House, Boolean&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"竹园新村\"</span>.equals(house.communityName);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;House&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"小区:\"</span> + house.communityName + <span class=\"string\">\"; 房源描述:\"</span> + house.desc);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区:竹园新村; 房源描述:顶层户型，两室一厅\n</code></pre><p>这一章我们就先聊到这，更多的过滤类操作符的介绍大家可以去查阅官方文档和源码；在下一章我们将继续介绍组合类操作符。</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"RxJava系列7(最佳实践)","date":"2017-02-05T16:22:03.000Z","_content":"\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)  \n\n***\n\n## 前言\n\n有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。\n\n> 按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。\n\n## 示例一、获取手机上已安装的App\n\n第一个例子我们需要在Android设备上展示已安装的第三方app列表，关于环境搭建、依赖配置、RecyclerView的使用等这些基础内容我就不做陈述了。需要了解的同学可以去GitHub上把项目clone下来看看。这里我主要讲讲如何通过RxJava实现核心功能。\n\n首选我们需要调用系统api来获取所有已安装的app，所以在`OnSubscribe`的`call`方法中调用`getApplicationInfoList()`。但是`getApplicationInfoList()`获取的数据并不能完全满足我们的业务需求：\n\n1. 由于我们只需要展示手机上已安装的第三方App，因此需要通过`filter`操作符来过滤掉系统app；\n2. `ApplicationInfo`并不是我们所需要的类型，因此需要通过`map`操作符将其转换为`AppInfo`；\n3. 由于获取`ApplicationInfo`、过滤数据、转换数据相对比较耗时，因此需要通过`subscribeOn`操作符将这一系列操作放到子线程中来处理；\n4. 而要将信息展示在页面上涉及到UI操作，因此需要通过`observeOn`操作符将`onNext`、`onCompleted`、`onError`调度到主线程，接着我们在这些方法中更新UI。\n\n下面是核心代码：\n\n```java\nfinal PackageManager pm = MainActivity.this.getPackageManager();\nObservable.create(new Observable.OnSubscribe<ApplicationInfo>() {\n        @Override\n        public void call(Subscriber<? super ApplicationInfo> subscriber) {\n            List<ApplicationInfo> infoList = getApplicationInfoList(pm);\n            for (ApplicationInfo info : infoList) {\n                subscriber.onNext(info);\n            }\n            subscriber.onCompleted();\n        }\n    }).filter(new Func1<ApplicationInfo, Boolean>() {\n        @Override\n        public Boolean call(ApplicationInfo applicationInfo) {\n            return (applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) <= 0;\n        }\n    }).map(new Func1<ApplicationInfo, AppInfo>() {\n\n        @Override\n        public AppInfo call(ApplicationInfo applicationInfo) {\n            AppInfo info = new AppInfo();\n            info.setAppIcon(applicationInfo.loadIcon(pm));\n            info.setAppName(applicationInfo.loadLabel(pm).toString());\n            return info;\n        }\n    }).subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Subscriber<AppInfo>() {\n        @Override\n        public void onCompleted() {\n            mAppListAdapter.notifyDataSetChanged();\n            mPullDownSRL.setRefreshing(false);\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            mPullDownSRL.setRefreshing(false);\n        }\n\n        @Override\n        public void onNext(AppInfo appInfo) {\n            mAppInfoList.add(appInfo);\n        }\n    });\n```\n程序执行效果图：\n<div align=\"left\"><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/7/pic1.png\" width = \"38%\" alt=\"图片名称\" align=center /></div>\n\n完整的代码我放到了GitHub上，有兴趣大家可以去clone下来自己运行看看。\n\n源码地址：[https://github.com/BaronZ88/HelloRxAndroid](https://github.com/BaronZ88/HelloRxAndroid)\n\n## 示例二、RxJava+Retrofit2实现获取天气数据\n\nRxJava + Retrofit2几乎是Android应用开发的标配了，这个例子中我们就来聊聊这二者是如何配合起来帮助我们快速开发的。\n\nRetrofit2中一个标准的接口定义是这样的：\n\n```java\n@GET(\"weather\")\nObservable<Weather> getWeather(@Query(\"cityId\") String cityId);\n```\n\n现在有了RxJava，一个基本的网络请求我们便可以这样实现：\n\n```java\nApiClient.weatherService.getWeather(cityId)\n             \t.subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Action1<Weather>() {\n                    @Override\n                    public void call(Weather weather) {\n                        weatherView.displayWeatherInformation(weather);\n                    }\n                });\n```\n\n但有时候可能一开始我们并不知道cityId，我们只知道cityName。所以就需要我们先访问服务器，拿到对应城市名的cityId，然后通过这个cityId再去获取天气数据。\n\n同样的，我们需要定义一个获取cityId的接口：\n\n```java\n@GET(\"city\")\nObservable<String> getCityIdByName(@Query(\"cityName\") String cityName);\n```\n\n紧接着我们便可以使用无所不能的RxJava来实现需求了。\n\n```java\nApiClient.weatherService.getCityIdByName(\"上海\")\n\t\t\t .flatMap(new Func1<String, Observable<Weather>>() {\n\t\t\t     @Override\n\t\t\t     public Observable<Weather> call(String cityId) {\n\t\t\t         return ApiClient.weatherService.getWeather(cityId);\n\t\t\t     }\n\t\t\t }).subscribeOn(Schedulers.io())\n\t\t\t .observeOn(AndroidSchedulers.mainThread())\n\t\t\t .subscribe(new Action1<Weather>() {\n\t\t\t     @Override\n\t\t\t     public void call(Weather weather) {\n\t\t\t         weatherView.displayWeatherInformation(weather);\n\t\t\t     }\n\t\t\t });\n```\n\n哇哦！~ so easy！！！妈妈再也不用担心....\n\n源码地址：[https://github.com/BaronZ88/WeatherStyle](https://github.com/BaronZ88/WeatherStyle)\n\n> [WeatherStyle]((https://github.com/BaronZ88/WeatherStyle))这个项目还在开发中，这个项目不只包含了RxJava和Retrofit的使用，同时还包含MVP、ORMLite、RetroLambda、ButterKnife等等开源库的使用\n\n\nRxJava1.X的系列文章就到此结束了，由于本人对RxJava的理解有限，这一系列文章中如有错误还请大家指正。在使用RxJava过程中有任何疑问也欢迎大家和我交流。共同学习！共同进步！\n\n好啦，我们RxJava2见！~\n***\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n\n","source":"_posts/2017-02-06-RxJava系列7-最佳实践.md","raw":"---\ntitle: RxJava系列7(最佳实践)\ndate: 2017-02-06 00:22:03\ncategories: rxjava\ntags: \n- RxJava\n- Android\n---\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)  \n\n***\n\n## 前言\n\n有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。\n\n> 按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。\n\n## 示例一、获取手机上已安装的App\n\n第一个例子我们需要在Android设备上展示已安装的第三方app列表，关于环境搭建、依赖配置、RecyclerView的使用等这些基础内容我就不做陈述了。需要了解的同学可以去GitHub上把项目clone下来看看。这里我主要讲讲如何通过RxJava实现核心功能。\n\n首选我们需要调用系统api来获取所有已安装的app，所以在`OnSubscribe`的`call`方法中调用`getApplicationInfoList()`。但是`getApplicationInfoList()`获取的数据并不能完全满足我们的业务需求：\n\n1. 由于我们只需要展示手机上已安装的第三方App，因此需要通过`filter`操作符来过滤掉系统app；\n2. `ApplicationInfo`并不是我们所需要的类型，因此需要通过`map`操作符将其转换为`AppInfo`；\n3. 由于获取`ApplicationInfo`、过滤数据、转换数据相对比较耗时，因此需要通过`subscribeOn`操作符将这一系列操作放到子线程中来处理；\n4. 而要将信息展示在页面上涉及到UI操作，因此需要通过`observeOn`操作符将`onNext`、`onCompleted`、`onError`调度到主线程，接着我们在这些方法中更新UI。\n\n下面是核心代码：\n\n```java\nfinal PackageManager pm = MainActivity.this.getPackageManager();\nObservable.create(new Observable.OnSubscribe<ApplicationInfo>() {\n        @Override\n        public void call(Subscriber<? super ApplicationInfo> subscriber) {\n            List<ApplicationInfo> infoList = getApplicationInfoList(pm);\n            for (ApplicationInfo info : infoList) {\n                subscriber.onNext(info);\n            }\n            subscriber.onCompleted();\n        }\n    }).filter(new Func1<ApplicationInfo, Boolean>() {\n        @Override\n        public Boolean call(ApplicationInfo applicationInfo) {\n            return (applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) <= 0;\n        }\n    }).map(new Func1<ApplicationInfo, AppInfo>() {\n\n        @Override\n        public AppInfo call(ApplicationInfo applicationInfo) {\n            AppInfo info = new AppInfo();\n            info.setAppIcon(applicationInfo.loadIcon(pm));\n            info.setAppName(applicationInfo.loadLabel(pm).toString());\n            return info;\n        }\n    }).subscribeOn(Schedulers.io())\n    .observeOn(AndroidSchedulers.mainThread())\n    .subscribe(new Subscriber<AppInfo>() {\n        @Override\n        public void onCompleted() {\n            mAppListAdapter.notifyDataSetChanged();\n            mPullDownSRL.setRefreshing(false);\n        }\n\n        @Override\n        public void onError(Throwable e) {\n            mPullDownSRL.setRefreshing(false);\n        }\n\n        @Override\n        public void onNext(AppInfo appInfo) {\n            mAppInfoList.add(appInfo);\n        }\n    });\n```\n程序执行效果图：\n<div align=\"left\"><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/7/pic1.png\" width = \"38%\" alt=\"图片名称\" align=center /></div>\n\n完整的代码我放到了GitHub上，有兴趣大家可以去clone下来自己运行看看。\n\n源码地址：[https://github.com/BaronZ88/HelloRxAndroid](https://github.com/BaronZ88/HelloRxAndroid)\n\n## 示例二、RxJava+Retrofit2实现获取天气数据\n\nRxJava + Retrofit2几乎是Android应用开发的标配了，这个例子中我们就来聊聊这二者是如何配合起来帮助我们快速开发的。\n\nRetrofit2中一个标准的接口定义是这样的：\n\n```java\n@GET(\"weather\")\nObservable<Weather> getWeather(@Query(\"cityId\") String cityId);\n```\n\n现在有了RxJava，一个基本的网络请求我们便可以这样实现：\n\n```java\nApiClient.weatherService.getWeather(cityId)\n             \t.subscribeOn(Schedulers.io())\n                .observeOn(AndroidSchedulers.mainThread())\n                .subscribe(new Action1<Weather>() {\n                    @Override\n                    public void call(Weather weather) {\n                        weatherView.displayWeatherInformation(weather);\n                    }\n                });\n```\n\n但有时候可能一开始我们并不知道cityId，我们只知道cityName。所以就需要我们先访问服务器，拿到对应城市名的cityId，然后通过这个cityId再去获取天气数据。\n\n同样的，我们需要定义一个获取cityId的接口：\n\n```java\n@GET(\"city\")\nObservable<String> getCityIdByName(@Query(\"cityName\") String cityName);\n```\n\n紧接着我们便可以使用无所不能的RxJava来实现需求了。\n\n```java\nApiClient.weatherService.getCityIdByName(\"上海\")\n\t\t\t .flatMap(new Func1<String, Observable<Weather>>() {\n\t\t\t     @Override\n\t\t\t     public Observable<Weather> call(String cityId) {\n\t\t\t         return ApiClient.weatherService.getWeather(cityId);\n\t\t\t     }\n\t\t\t }).subscribeOn(Schedulers.io())\n\t\t\t .observeOn(AndroidSchedulers.mainThread())\n\t\t\t .subscribe(new Action1<Weather>() {\n\t\t\t     @Override\n\t\t\t     public void call(Weather weather) {\n\t\t\t         weatherView.displayWeatherInformation(weather);\n\t\t\t     }\n\t\t\t });\n```\n\n哇哦！~ so easy！！！妈妈再也不用担心....\n\n源码地址：[https://github.com/BaronZ88/WeatherStyle](https://github.com/BaronZ88/WeatherStyle)\n\n> [WeatherStyle]((https://github.com/BaronZ88/WeatherStyle))这个项目还在开发中，这个项目不只包含了RxJava和Retrofit的使用，同时还包含MVP、ORMLite、RetroLambda、ButterKnife等等开源库的使用\n\n\nRxJava1.X的系列文章就到此结束了，由于本人对RxJava的理解有限，这一系列文章中如有错误还请大家指正。在使用RxJava过程中有任何疑问也欢迎大家和我交流。共同学习！共同进步！\n\n好啦，我们RxJava2见！~\n***\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n\n","slug":"RxJava系列7-最佳实践","published":1,"updated":"2017-02-06T03:44:51.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26ex000n6st6g30u32fe","content":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>  </li>\n</ul>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。</p>\n<blockquote>\n<p>按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。</p>\n</blockquote>\n<h2 id=\"示例一、获取手机上已安装的App\"><a href=\"#示例一、获取手机上已安装的App\" class=\"headerlink\" title=\"示例一、获取手机上已安装的App\"></a>示例一、获取手机上已安装的App</h2><p>第一个例子我们需要在Android设备上展示已安装的第三方app列表，关于环境搭建、依赖配置、RecyclerView的使用等这些基础内容我就不做陈述了。需要了解的同学可以去GitHub上把项目clone下来看看。这里我主要讲讲如何通过RxJava实现核心功能。</p>\n<p>首选我们需要调用系统api来获取所有已安装的app，所以在<code>OnSubscribe</code>的<code>call</code>方法中调用<code>getApplicationInfoList()</code>。但是<code>getApplicationInfoList()</code>获取的数据并不能完全满足我们的业务需求：</p>\n<ol>\n<li>由于我们只需要展示手机上已安装的第三方App，因此需要通过<code>filter</code>操作符来过滤掉系统app；</li>\n<li><code>ApplicationInfo</code>并不是我们所需要的类型，因此需要通过<code>map</code>操作符将其转换为<code>AppInfo</code>；</li>\n<li>由于获取<code>ApplicationInfo</code>、过滤数据、转换数据相对比较耗时，因此需要通过<code>subscribeOn</code>操作符将这一系列操作放到子线程中来处理；</li>\n<li>而要将信息展示在页面上涉及到UI操作，因此需要通过<code>observeOn</code>操作符将<code>onNext</code>、<code>onCompleted</code>、<code>onError</code>调度到主线程，接着我们在这些方法中更新UI。</li>\n</ol>\n<p>下面是核心代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> PackageManager pm = MainActivity.<span class=\"keyword\">this</span>.getPackageManager();</div><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;ApplicationInfo&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> ApplicationInfo&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">            List&lt;ApplicationInfo&gt; infoList = getApplicationInfoList(pm);</div><div class=\"line\">            <span class=\"keyword\">for</span> (ApplicationInfo info : infoList) &#123;</div><div class=\"line\">                subscriber.onNext(info);</div><div class=\"line\">            &#125;</div><div class=\"line\">            subscriber.onCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).filter(<span class=\"keyword\">new</span> Func1&lt;ApplicationInfo, Boolean&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).map(<span class=\"keyword\">new</span> Func1&lt;ApplicationInfo, AppInfo&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> AppInfo <span class=\"title\">call</span><span class=\"params\">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class=\"line\">            AppInfo info = <span class=\"keyword\">new</span> AppInfo();</div><div class=\"line\">            info.setAppIcon(applicationInfo.loadIcon(pm));</div><div class=\"line\">            info.setAppName(applicationInfo.loadLabel(pm).toString());</div><div class=\"line\">            <span class=\"keyword\">return</span> info;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;AppInfo&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            mAppListAdapter.notifyDataSetChanged();</div><div class=\"line\">            mPullDownSRL.setRefreshing(<span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            mPullDownSRL.setRefreshing(<span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(AppInfo appInfo)</span> </span>&#123;</div><div class=\"line\">            mAppInfoList.add(appInfo);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>程序执行效果图：</p>\n<div align=\"left\"><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/7/pic1.png\" width=\"38%\" alt=\"图片名称\" align=\"center\"></div>\n\n<p>完整的代码我放到了GitHub上，有兴趣大家可以去clone下来自己运行看看。</p>\n<p>源码地址：<a href=\"https://github.com/BaronZ88/HelloRxAndroid\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88/HelloRxAndroid</a></p>\n<h2 id=\"示例二、RxJava-Retrofit2实现获取天气数据\"><a href=\"#示例二、RxJava-Retrofit2实现获取天气数据\" class=\"headerlink\" title=\"示例二、RxJava+Retrofit2实现获取天气数据\"></a>示例二、RxJava+Retrofit2实现获取天气数据</h2><p>RxJava + Retrofit2几乎是Android应用开发的标配了，这个例子中我们就来聊聊这二者是如何配合起来帮助我们快速开发的。</p>\n<p>Retrofit2中一个标准的接口定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span>(<span class=\"string\">\"weather\"</span>)</div><div class=\"line\"><span class=\"function\">Observable&lt;Weather&gt; <span class=\"title\">getWeather</span><span class=\"params\">(@Query(<span class=\"string\">\"cityId\"</span>)</span> String cityId)</span>;</div></pre></td></tr></table></figure>\n<p>现在有了RxJava，一个基本的网络请求我们便可以这样实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApiClient.weatherService.getWeather(cityId)</div><div class=\"line\">             \t.subscribeOn(Schedulers.io())</div><div class=\"line\">                .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">                .subscribe(<span class=\"keyword\">new</span> Action1&lt;Weather&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                        weatherView.displayWeatherInformation(weather);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div></pre></td></tr></table></figure>\n<p>但有时候可能一开始我们并不知道cityId，我们只知道cityName。所以就需要我们先访问服务器，拿到对应城市名的cityId，然后通过这个cityId再去获取天气数据。</p>\n<p>同样的，我们需要定义一个获取cityId的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span>(<span class=\"string\">\"city\"</span>)</div><div class=\"line\"><span class=\"function\">Observable&lt;String&gt; <span class=\"title\">getCityIdByName</span><span class=\"params\">(@Query(<span class=\"string\">\"cityName\"</span>)</span> String cityName)</span>;</div></pre></td></tr></table></figure>\n<p>紧接着我们便可以使用无所不能的RxJava来实现需求了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApiClient.weatherService.getCityIdByName(<span class=\"string\">\"上海\"</span>)</div><div class=\"line\">\t\t\t .flatMap(<span class=\"keyword\">new</span> Func1&lt;String, Observable&lt;Weather&gt;&gt;() &#123;</div><div class=\"line\">\t\t\t     <span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t     <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Weather&gt; <span class=\"title\">call</span><span class=\"params\">(String cityId)</span> </span>&#123;</div><div class=\"line\">\t\t\t         <span class=\"keyword\">return</span> ApiClient.weatherService.getWeather(cityId);</div><div class=\"line\">\t\t\t     &#125;</div><div class=\"line\">\t\t\t &#125;).subscribeOn(Schedulers.io())</div><div class=\"line\">\t\t\t .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">\t\t\t .subscribe(<span class=\"keyword\">new</span> Action1&lt;Weather&gt;() &#123;</div><div class=\"line\">\t\t\t     <span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">\t\t\t         weatherView.displayWeatherInformation(weather);</div><div class=\"line\">\t\t\t     &#125;</div><div class=\"line\">\t\t\t &#125;);</div></pre></td></tr></table></figure>\n<p>哇哦！~ so easy！！！妈妈再也不用担心….</p>\n<p>源码地址：<a href=\"https://github.com/BaronZ88/WeatherStyle\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88/WeatherStyle</a></p>\n<blockquote>\n<p><a href=\"(https://github.com/BaronZ88/WeatherStyle\">WeatherStyle</a>)这个项目还在开发中，这个项目不只包含了RxJava和Retrofit的使用，同时还包含MVP、ORMLite、RetroLambda、ButterKnife等等开源库的使用</p>\n</blockquote>\n<p>RxJava1.X的系列文章就到此结束了，由于本人对RxJava的理解有限，这一系列文章中如有错误还请大家指正。在使用RxJava过程中有任何疑问也欢迎大家和我交流。共同学习！共同进步！</p>\n<p>好啦，我们RxJava2见！~</p>\n<hr>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>  </li>\n</ul>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>有点标题党了，其实谈不上什么最佳实践。前段时间公司实行996，所以也没什么时间和精力来更新博客（好吧~我承认是我懒~）。因此这篇文章只是简单的通过两个例子介绍了RxJava在生产环境中的使用。不过本篇中的每个例子我都配上了完整的代码。</p>\n<blockquote>\n<p>按照计划这一期是要介绍RxJava框架结构和设计思想的，但是考虑到Netflix将在十月底发布RxJava2.0正式版；因此决定将RxJava框架结构和设计思想分析放到2.0正式版发布后再做。后续我也会有一系列的文章来介绍RxJava1.x和2.x的区别。</p>\n</blockquote>\n<h2 id=\"示例一、获取手机上已安装的App\"><a href=\"#示例一、获取手机上已安装的App\" class=\"headerlink\" title=\"示例一、获取手机上已安装的App\"></a>示例一、获取手机上已安装的App</h2><p>第一个例子我们需要在Android设备上展示已安装的第三方app列表，关于环境搭建、依赖配置、RecyclerView的使用等这些基础内容我就不做陈述了。需要了解的同学可以去GitHub上把项目clone下来看看。这里我主要讲讲如何通过RxJava实现核心功能。</p>\n<p>首选我们需要调用系统api来获取所有已安装的app，所以在<code>OnSubscribe</code>的<code>call</code>方法中调用<code>getApplicationInfoList()</code>。但是<code>getApplicationInfoList()</code>获取的数据并不能完全满足我们的业务需求：</p>\n<ol>\n<li>由于我们只需要展示手机上已安装的第三方App，因此需要通过<code>filter</code>操作符来过滤掉系统app；</li>\n<li><code>ApplicationInfo</code>并不是我们所需要的类型，因此需要通过<code>map</code>操作符将其转换为<code>AppInfo</code>；</li>\n<li>由于获取<code>ApplicationInfo</code>、过滤数据、转换数据相对比较耗时，因此需要通过<code>subscribeOn</code>操作符将这一系列操作放到子线程中来处理；</li>\n<li>而要将信息展示在页面上涉及到UI操作，因此需要通过<code>observeOn</code>操作符将<code>onNext</code>、<code>onCompleted</code>、<code>onError</code>调度到主线程，接着我们在这些方法中更新UI。</li>\n</ol>\n<p>下面是核心代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> PackageManager pm = MainActivity.<span class=\"keyword\">this</span>.getPackageManager();</div><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;ApplicationInfo&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> ApplicationInfo&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">            List&lt;ApplicationInfo&gt; infoList = getApplicationInfoList(pm);</div><div class=\"line\">            <span class=\"keyword\">for</span> (ApplicationInfo info : infoList) &#123;</div><div class=\"line\">                subscriber.onNext(info);</div><div class=\"line\">            &#125;</div><div class=\"line\">            subscriber.onCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).filter(<span class=\"keyword\">new</span> Func1&lt;ApplicationInfo, Boolean&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">return</span> (applicationInfo.flags &amp; ApplicationInfo.FLAG_SYSTEM) &lt;= <span class=\"number\">0</span>;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).map(<span class=\"keyword\">new</span> Func1&lt;ApplicationInfo, AppInfo&gt;() &#123;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> AppInfo <span class=\"title\">call</span><span class=\"params\">(ApplicationInfo applicationInfo)</span> </span>&#123;</div><div class=\"line\">            AppInfo info = <span class=\"keyword\">new</span> AppInfo();</div><div class=\"line\">            info.setAppIcon(applicationInfo.loadIcon(pm));</div><div class=\"line\">            info.setAppName(applicationInfo.loadLabel(pm).toString());</div><div class=\"line\">            <span class=\"keyword\">return</span> info;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;).subscribeOn(Schedulers.io())</div><div class=\"line\">    .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">    .subscribe(<span class=\"keyword\">new</span> Subscriber&lt;AppInfo&gt;() &#123;</div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            mAppListAdapter.notifyDataSetChanged();</div><div class=\"line\">            mPullDownSRL.setRefreshing(<span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            mPullDownSRL.setRefreshing(<span class=\"keyword\">false</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(AppInfo appInfo)</span> </span>&#123;</div><div class=\"line\">            mAppInfoList.add(appInfo);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;);</div></pre></td></tr></table></figure>\n<p>程序执行效果图：</p>\n<div align=\"left\"><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/7/pic1.png\" width = \"38%\" alt=\"图片名称\" align=center /></div>\n\n<p>完整的代码我放到了GitHub上，有兴趣大家可以去clone下来自己运行看看。</p>\n<p>源码地址：<a href=\"https://github.com/BaronZ88/HelloRxAndroid\">https://github.com/BaronZ88/HelloRxAndroid</a></p>\n<h2 id=\"示例二、RxJava-Retrofit2实现获取天气数据\"><a href=\"#示例二、RxJava-Retrofit2实现获取天气数据\" class=\"headerlink\" title=\"示例二、RxJava+Retrofit2实现获取天气数据\"></a>示例二、RxJava+Retrofit2实现获取天气数据</h2><p>RxJava + Retrofit2几乎是Android应用开发的标配了，这个例子中我们就来聊聊这二者是如何配合起来帮助我们快速开发的。</p>\n<p>Retrofit2中一个标准的接口定义是这样的：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span>(<span class=\"string\">\"weather\"</span>)</div><div class=\"line\"><span class=\"function\">Observable&lt;Weather&gt; <span class=\"title\">getWeather</span><span class=\"params\">(@Query(<span class=\"string\">\"cityId\"</span>)</span> String cityId)</span>;</div></pre></td></tr></table></figure>\n<p>现在有了RxJava，一个基本的网络请求我们便可以这样实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApiClient.weatherService.getWeather(cityId)</div><div class=\"line\">             \t.subscribeOn(Schedulers.io())</div><div class=\"line\">                .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">                .subscribe(<span class=\"keyword\">new</span> Action1&lt;Weather&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                        weatherView.displayWeatherInformation(weather);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;);</div></pre></td></tr></table></figure>\n<p>但有时候可能一开始我们并不知道cityId，我们只知道cityName。所以就需要我们先访问服务器，拿到对应城市名的cityId，然后通过这个cityId再去获取天气数据。</p>\n<p>同样的，我们需要定义一个获取cityId的接口：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@GET</span>(<span class=\"string\">\"city\"</span>)</div><div class=\"line\"><span class=\"function\">Observable&lt;String&gt; <span class=\"title\">getCityIdByName</span><span class=\"params\">(@Query(<span class=\"string\">\"cityName\"</span>)</span> String cityName)</span>;</div></pre></td></tr></table></figure>\n<p>紧接着我们便可以使用无所不能的RxJava来实现需求了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div></pre></td><td class=\"code\"><pre><div class=\"line\">ApiClient.weatherService.getCityIdByName(<span class=\"string\">\"上海\"</span>)</div><div class=\"line\">\t\t\t .flatMap(<span class=\"keyword\">new</span> Func1&lt;String, Observable&lt;Weather&gt;&gt;() &#123;</div><div class=\"line\">\t\t\t     <span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t     <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Weather&gt; <span class=\"title\">call</span><span class=\"params\">(String cityId)</span> </span>&#123;</div><div class=\"line\">\t\t\t         <span class=\"keyword\">return</span> ApiClient.weatherService.getWeather(cityId);</div><div class=\"line\">\t\t\t     &#125;</div><div class=\"line\">\t\t\t &#125;).subscribeOn(Schedulers.io())</div><div class=\"line\">\t\t\t .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">\t\t\t .subscribe(<span class=\"keyword\">new</span> Action1&lt;Weather&gt;() &#123;</div><div class=\"line\">\t\t\t     <span class=\"meta\">@Override</span></div><div class=\"line\">\t\t\t     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">\t\t\t         weatherView.displayWeatherInformation(weather);</div><div class=\"line\">\t\t\t     &#125;</div><div class=\"line\">\t\t\t &#125;);</div></pre></td></tr></table></figure>\n<p>哇哦！~ so easy！！！妈妈再也不用担心….</p>\n<p>源码地址：<a href=\"https://github.com/BaronZ88/WeatherStyle\">https://github.com/BaronZ88/WeatherStyle</a></p>\n<blockquote>\n<p><a href=\"(https://github.com/BaronZ88/WeatherStyle\">WeatherStyle</a>)这个项目还在开发中，这个项目不只包含了RxJava和Retrofit的使用，同时还包含MVP、ORMLite、RetroLambda、ButterKnife等等开源库的使用</p>\n</blockquote>\n<p>RxJava1.X的系列文章就到此结束了，由于本人对RxJava的理解有限，这一系列文章中如有错误还请大家指正。在使用RxJava过程中有任何疑问也欢迎大家和我交流。共同学习！共同进步！</p>\n<p>好啦，我们RxJava2见！~</p>\n<hr>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"RxJava系列5(组合操作符)","date":"2017-02-05T16:20:46.000Z","_content":"\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)   \n\n***\n这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： **`Merge`** **`StartWith`** **`Concat`** **`Zip`** **`CombineLatest`**  **`SwitchOnNext`** **`Join`**等等。\n\n### Merge\n**`merge(Observable, Observable)`**将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。\n\n![merge(Observable, Observable)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeOperator.png)\n\n我们看下面的例子，一共有两个Observable：一个用来发送字母，另一个用来发送数字；现在我们需要两连个Observable发射的数据合并。\n\n```Java\nString[] letters = new String[]{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"};\nObservable<String> letterSequence = Observable.interval(300, TimeUnit.MILLISECONDS)\n        .map(new Func1<Long, String>() {\n            @Override\n            public String call(Long position) {\n                return letters[position.intValue()];\n            }\n        }).take(letters.length);\n\nObservable<Long> numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS).take(5);\n\nObservable.merge(letterSequence, numberSequence)\n        .subscribe(new Observer<Serializable>() {\n            @Override\n            public void onCompleted() {\n                System.exit(0);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"Error:\" + e.getMessage());\n            }\n\n            @Override\n            public void onNext(Serializable serializable) {\n                System.out.print(serializable.toString()+\" \");\n            }\n        });   \n```\n            \n程序输出：\n\n\tA 0 B C 1 D E 2 F 3 G H 4 \n\n**`merge(Observable[])`**将多个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。\n\n![merge(Observable[])](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeIOOperator.png)\n\n### StartWith\n**`startWith(T)`**用于在源Observable发射的数据前插入数据。使用**`startWith(Iterable<T>)`**我们还可以在源Observable发射的数据前插入Iterable。官方示意图：\n![startWith(T) startWith(Iterable<T>)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOperator.png)\n\n**`startWith(Observable<T>)`**用于在源Observable发射的数据前插入另一个Observable发射的数据（这些数据会被插入到\n源Observable发射数据的前面）。官方示意图：\n![startWith(Observable<T>)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOOperator.png)\n\n### Concat\n**`concat(Observable<? extends T>, Observable<? extends T>)`** **`concat(Observable<？ extends Observable<T>>`)**用于将多个obserbavle发射的的数据进行合并发射，concat严格按照顺序发射数据，前一个Observable没发射玩是不会发射后一个Observable的数据的。它和merge、startWitch和相似，不同之处在于：\n\n1. merge:合并后发射的数据是无序的；\n2. startWitch:只能在源Observable发射的数据前插入数据。\n\n![concat(Observable<? extends T>, Observable<? extends T>)、concat(Observable<？ extends Observable<T>>)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ConcatOperator.png)\n\n这里我们将前面Merge操作符的例子拿过来，并将操作符换成`Concat`，然后我们看看执行结果：\n\n```java\nString[] letters = new String[]{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"};\nObservable<String> letterSequence = Observable.interval(300, TimeUnit.MILLISECONDS)\n        .map(new Func1<Long, String>() {\n            @Override\n            public String call(Long position) {\n                return letters[position.intValue()];\n            }\n        }).take(letters.length);\n\nObservable<Long> numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS).take(5);\n\nObservable.concat(letterSequence, numberSequence)\n        .subscribe(new Observer<Serializable>() {\n            @Override\n            public void onCompleted() {\n                System.exit(0);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"Error:\" + e.getMessage());\n            }\n\n            @Override\n            public void onNext(Serializable serializable) {\n                System.out.print(serializable.toString() + \" \");\n            }\n        });\n```\n          \n程序输出：\n\n\tA B C D E F G H 0 1 2 3 4 \n\n### Zip\n**`zip(Observable, Observable, Func2)`**用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。\n![zip(Observable, Observable, Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ZipOperator.png)\n\n和前面的例子一样，我们将操作符换成了`zip`:\n\n```java\nString[] letters = new String[]{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"};\nObservable<String> letterSequence = Observable.interval(120, TimeUnit.MILLISECONDS)\n        .map(new Func1<Long, String>() {\n            @Override\n            public String call(Long position) {\n                return letters[position.intValue()];\n            }\n        }).take(letters.length);\n\nObservable<Long> numberSequence = Observable.interval(200, TimeUnit.MILLISECONDS).take(5);\n\nObservable.zip(letterSequence, numberSequence, new Func2<String, Long, String>() {\n    @Override\n    public String call(String letter, Long number) {\n        return letter + number;\n    }\n}).subscribe(new Observer<String>() {\n    @Override\n    public void onCompleted() {\n        System.exit(0);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"Error:\" + e.getMessage());\n    }\n\n    @Override\n    public void onNext(String result) {\n        System.out.print(result + \" \");\n    }\n});\n```\n    \n程序输出：\n\n\tA0 B1 C2 D3 E4\n\n### CombineLatest\n**`comnineLatest(Observable, Observable, Func2)`**用于将两个Observale最近发射的数据已经Func2函数的规则进展组合。下面是官方提供的原理图：\n![comnineLatest(Observable, Observable, Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatestOperator.png)\n\n下面这张图应该更容易理解：\n![comnineLatest(Observable, Observable, Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatest.png)\n\n```java\nList<String> communityNames = DataSimulator.getCommunityNames();\nList<Location> locations = DataSimulator.getLocations();\n\nObservable<String> communityNameSequence = Observable.interval(1, TimeUnit.SECONDS)\n        .map(new Func1<Long, String>() {\n            @Override\n            public String call(Long position) {\n                return communityNames.get(position.intValue());\n            }\n        }).take(communityNames.size());\nObservable<Location> locationSequence = Observable.interval(1, TimeUnit.SECONDS)\n        .map(new Func1<Long, Location>() {\n            @Override\n            public Location call(Long position) {\n                return locations.get(position.intValue());\n            }\n        }).take(locations.size());\n\nObservable.combineLatest(\n        communityNameSequence,\n        locationSequence,\n        new Func2<String, Location, String>() {\n            @Override\n            public String call(String communityName, Location location) {\n                return \"小区名:\" + communityName + \", 经纬度:\" + location.toString();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onCompleted() {\n                System.exit(0);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"Error:\" + e.getMessage());\n            }\n\n            @Override\n            public void onNext(String s) {\n                System.out.println(s);\n            }\n        });\n```\n          \n程序输出：\n\n\t小区名:竹园新村, 经纬度:(21.827, 23.323)\n\t小区名:康桥半岛, 经纬度:(21.827, 23.323)\n\t小区名:康桥半岛, 经纬度:(11.923, 16.309)\n\t小区名:中粮·海景壹号, 经纬度:(11.923, 16.309)\n\t小区名:中粮·海景壹号, 经纬度:(22.273, 53.623)\n\t小区名:浦江名苑, 经纬度:(22.273, 53.623)\n\t小区名:南辉小区, 经纬度:(22.273, 53.623)\n\n\n### SwitchOnNext\n**`switchOnNext(Observable<? extends Observable<? extends T>>`**用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新\n的小Observable所发射的数据。\n\n结合下面的原理图大家应该很容易理解，我们可以看到下图中的黄色圆圈就被丢弃了。\n![switchOnNext(Observable<? extends Observable<? extends T>>)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/SwitchOnNextOperator.png)\n\n### Join\n**`join(Observable, Func1, Func1, Func2)`**我们先介绍下join操作符的4个参数：\n\n* Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；\n* Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；\n* Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；\n* Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。\n\n所以Join操作符的语法结构大致是这样的：**`onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)`**\n\njoin操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： `[0, B]` `[1, B]` `[2, B]` `[3, B]`\n\n再看看下面的图是不是好理解了呢？！\n![join(Observable, Func1, Func1, Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/JoinOperator.png)\n\n读懂了上面的文字，我们再来写段代码加深理解。\n\n```java\nfinal List<House> houses = DataSimulator.getHouses();//模拟的房源数据，用于测试\n\n//用来每秒从houses总取出一套房源并发射出去\nObservable<House> houseSequence =\n        Observable.interval(1, TimeUnit.SECONDS)\n                .map(new Func1<Long, House>() {\n                    @Override\n                    public House call(Long position) {\n                        return houses.get(position.intValue());\n                    }\n                }).take(houses.size());//这里的take是为了防止houses.get(position.intValue())数组越界\n\n//用来实现每秒发送一个新的Long型数据\nObservable<Long> tictoc = Observable.interval(1, TimeUnit.SECONDS);\n\nhouseSequence.join(tictoc,\n        new Func1<House, Observable<Long>>() {\n            @Override\n            public Observable<Long> call(House house) {\n                return Observable.timer(2, TimeUnit.SECONDS);\n            }\n        },\n        new Func1<Long, Observable<Long>>() {\n            @Override\n            public Observable<Long> call(Long aLong) {\n                return Observable.timer(0, TimeUnit.SECONDS);\n            }\n        },\n        new Func2<House, Long, String>() {\n            @Override\n            public String call(House house, Long aLong) {\n                return aLong + \"-->\" + house.getDesc();\n            }\n        }\n).subscribe(new Observer<String>() {\n    @Override\n    public void onCompleted() {\n        System.exit(0);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"Error:\"+e.getMessage());\n    }\n\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n});\n```\n\n程序输出：\n\n\t0-->中粮海景壹号新出大平层！总价4500W起\n\t1-->中粮海景壹号新出大平层！总价4500W起\n\t1-->满五唯一，黄金地段\n\t2-->中粮海景壹号新出大平层！总价4500W起\n\t2-->满五唯一，黄金地段\n\t2-->一楼自带小花园\n\t3-->一楼自带小花园\n\t3-->毗邻汤臣一品\n\t4-->毗邻汤臣一品\n\t4-->顶级住宅，给您总统般尊贵体验\n\t5-->顶级住宅，给您总统般尊贵体验\n\t5-->顶层户型，两室一厅\n\t6-->顶层户型，两室一厅\n\t6-->南北通透，豪华五房\n\t7-->南北通透，豪华五房\n\t\n通过[转换操作符](http://www.jianshu.com/p/5970280703b9)、[过滤操作符](http://www.jianshu.com/p/3a188b995daa)、[组合操作符](http://www.jianshu.com/p/546fe44a6e22)三个篇幅将RxJava主要的操作符也介绍的七七八八了。更多操作符的介绍建议大家去查阅官方文档，并自己动手实践一下。这一系列的文章也会持续更新，欢迎大家保持关注！:)\n\nDemo源码地址：[https://github.com/BaronZ88/HelloRxJava](https://github.com/BaronZ88/HelloRxJava)\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","source":"_posts/2017-02-06-RxJava系列5-组合操作符.md","raw":"---\ntitle: RxJava系列5(组合操作符)\ndate: 2017-02-06 00:20:46\ncategories: rxjava\ntags: \n- RxJava\n- Android\n---\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)   \n\n***\n这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： **`Merge`** **`StartWith`** **`Concat`** **`Zip`** **`CombineLatest`**  **`SwitchOnNext`** **`Join`**等等。\n\n### Merge\n**`merge(Observable, Observable)`**将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。\n\n![merge(Observable, Observable)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeOperator.png)\n\n我们看下面的例子，一共有两个Observable：一个用来发送字母，另一个用来发送数字；现在我们需要两连个Observable发射的数据合并。\n\n```Java\nString[] letters = new String[]{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"};\nObservable<String> letterSequence = Observable.interval(300, TimeUnit.MILLISECONDS)\n        .map(new Func1<Long, String>() {\n            @Override\n            public String call(Long position) {\n                return letters[position.intValue()];\n            }\n        }).take(letters.length);\n\nObservable<Long> numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS).take(5);\n\nObservable.merge(letterSequence, numberSequence)\n        .subscribe(new Observer<Serializable>() {\n            @Override\n            public void onCompleted() {\n                System.exit(0);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"Error:\" + e.getMessage());\n            }\n\n            @Override\n            public void onNext(Serializable serializable) {\n                System.out.print(serializable.toString()+\" \");\n            }\n        });   \n```\n            \n程序输出：\n\n\tA 0 B C 1 D E 2 F 3 G H 4 \n\n**`merge(Observable[])`**将多个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。\n\n![merge(Observable[])](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeIOOperator.png)\n\n### StartWith\n**`startWith(T)`**用于在源Observable发射的数据前插入数据。使用**`startWith(Iterable<T>)`**我们还可以在源Observable发射的数据前插入Iterable。官方示意图：\n![startWith(T) startWith(Iterable<T>)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOperator.png)\n\n**`startWith(Observable<T>)`**用于在源Observable发射的数据前插入另一个Observable发射的数据（这些数据会被插入到\n源Observable发射数据的前面）。官方示意图：\n![startWith(Observable<T>)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOOperator.png)\n\n### Concat\n**`concat(Observable<? extends T>, Observable<? extends T>)`** **`concat(Observable<？ extends Observable<T>>`)**用于将多个obserbavle发射的的数据进行合并发射，concat严格按照顺序发射数据，前一个Observable没发射玩是不会发射后一个Observable的数据的。它和merge、startWitch和相似，不同之处在于：\n\n1. merge:合并后发射的数据是无序的；\n2. startWitch:只能在源Observable发射的数据前插入数据。\n\n![concat(Observable<? extends T>, Observable<? extends T>)、concat(Observable<？ extends Observable<T>>)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ConcatOperator.png)\n\n这里我们将前面Merge操作符的例子拿过来，并将操作符换成`Concat`，然后我们看看执行结果：\n\n```java\nString[] letters = new String[]{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"};\nObservable<String> letterSequence = Observable.interval(300, TimeUnit.MILLISECONDS)\n        .map(new Func1<Long, String>() {\n            @Override\n            public String call(Long position) {\n                return letters[position.intValue()];\n            }\n        }).take(letters.length);\n\nObservable<Long> numberSequence = Observable.interval(500, TimeUnit.MILLISECONDS).take(5);\n\nObservable.concat(letterSequence, numberSequence)\n        .subscribe(new Observer<Serializable>() {\n            @Override\n            public void onCompleted() {\n                System.exit(0);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"Error:\" + e.getMessage());\n            }\n\n            @Override\n            public void onNext(Serializable serializable) {\n                System.out.print(serializable.toString() + \" \");\n            }\n        });\n```\n          \n程序输出：\n\n\tA B C D E F G H 0 1 2 3 4 \n\n### Zip\n**`zip(Observable, Observable, Func2)`**用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。\n![zip(Observable, Observable, Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ZipOperator.png)\n\n和前面的例子一样，我们将操作符换成了`zip`:\n\n```java\nString[] letters = new String[]{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\", \"H\"};\nObservable<String> letterSequence = Observable.interval(120, TimeUnit.MILLISECONDS)\n        .map(new Func1<Long, String>() {\n            @Override\n            public String call(Long position) {\n                return letters[position.intValue()];\n            }\n        }).take(letters.length);\n\nObservable<Long> numberSequence = Observable.interval(200, TimeUnit.MILLISECONDS).take(5);\n\nObservable.zip(letterSequence, numberSequence, new Func2<String, Long, String>() {\n    @Override\n    public String call(String letter, Long number) {\n        return letter + number;\n    }\n}).subscribe(new Observer<String>() {\n    @Override\n    public void onCompleted() {\n        System.exit(0);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"Error:\" + e.getMessage());\n    }\n\n    @Override\n    public void onNext(String result) {\n        System.out.print(result + \" \");\n    }\n});\n```\n    \n程序输出：\n\n\tA0 B1 C2 D3 E4\n\n### CombineLatest\n**`comnineLatest(Observable, Observable, Func2)`**用于将两个Observale最近发射的数据已经Func2函数的规则进展组合。下面是官方提供的原理图：\n![comnineLatest(Observable, Observable, Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatestOperator.png)\n\n下面这张图应该更容易理解：\n![comnineLatest(Observable, Observable, Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatest.png)\n\n```java\nList<String> communityNames = DataSimulator.getCommunityNames();\nList<Location> locations = DataSimulator.getLocations();\n\nObservable<String> communityNameSequence = Observable.interval(1, TimeUnit.SECONDS)\n        .map(new Func1<Long, String>() {\n            @Override\n            public String call(Long position) {\n                return communityNames.get(position.intValue());\n            }\n        }).take(communityNames.size());\nObservable<Location> locationSequence = Observable.interval(1, TimeUnit.SECONDS)\n        .map(new Func1<Long, Location>() {\n            @Override\n            public Location call(Long position) {\n                return locations.get(position.intValue());\n            }\n        }).take(locations.size());\n\nObservable.combineLatest(\n        communityNameSequence,\n        locationSequence,\n        new Func2<String, Location, String>() {\n            @Override\n            public String call(String communityName, Location location) {\n                return \"小区名:\" + communityName + \", 经纬度:\" + location.toString();\n            }\n        }).subscribe(new Observer<String>() {\n            @Override\n            public void onCompleted() {\n                System.exit(0);\n            }\n\n            @Override\n            public void onError(Throwable e) {\n                System.out.println(\"Error:\" + e.getMessage());\n            }\n\n            @Override\n            public void onNext(String s) {\n                System.out.println(s);\n            }\n        });\n```\n          \n程序输出：\n\n\t小区名:竹园新村, 经纬度:(21.827, 23.323)\n\t小区名:康桥半岛, 经纬度:(21.827, 23.323)\n\t小区名:康桥半岛, 经纬度:(11.923, 16.309)\n\t小区名:中粮·海景壹号, 经纬度:(11.923, 16.309)\n\t小区名:中粮·海景壹号, 经纬度:(22.273, 53.623)\n\t小区名:浦江名苑, 经纬度:(22.273, 53.623)\n\t小区名:南辉小区, 经纬度:(22.273, 53.623)\n\n\n### SwitchOnNext\n**`switchOnNext(Observable<? extends Observable<? extends T>>`**用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新\n的小Observable所发射的数据。\n\n结合下面的原理图大家应该很容易理解，我们可以看到下图中的黄色圆圈就被丢弃了。\n![switchOnNext(Observable<? extends Observable<? extends T>>)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/SwitchOnNextOperator.png)\n\n### Join\n**`join(Observable, Func1, Func1, Func2)`**我们先介绍下join操作符的4个参数：\n\n* Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；\n* Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；\n* Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；\n* Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。\n\n所以Join操作符的语法结构大致是这样的：**`onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)`**\n\njoin操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： `[0, B]` `[1, B]` `[2, B]` `[3, B]`\n\n再看看下面的图是不是好理解了呢？！\n![join(Observable, Func1, Func1, Func2)](http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/JoinOperator.png)\n\n读懂了上面的文字，我们再来写段代码加深理解。\n\n```java\nfinal List<House> houses = DataSimulator.getHouses();//模拟的房源数据，用于测试\n\n//用来每秒从houses总取出一套房源并发射出去\nObservable<House> houseSequence =\n        Observable.interval(1, TimeUnit.SECONDS)\n                .map(new Func1<Long, House>() {\n                    @Override\n                    public House call(Long position) {\n                        return houses.get(position.intValue());\n                    }\n                }).take(houses.size());//这里的take是为了防止houses.get(position.intValue())数组越界\n\n//用来实现每秒发送一个新的Long型数据\nObservable<Long> tictoc = Observable.interval(1, TimeUnit.SECONDS);\n\nhouseSequence.join(tictoc,\n        new Func1<House, Observable<Long>>() {\n            @Override\n            public Observable<Long> call(House house) {\n                return Observable.timer(2, TimeUnit.SECONDS);\n            }\n        },\n        new Func1<Long, Observable<Long>>() {\n            @Override\n            public Observable<Long> call(Long aLong) {\n                return Observable.timer(0, TimeUnit.SECONDS);\n            }\n        },\n        new Func2<House, Long, String>() {\n            @Override\n            public String call(House house, Long aLong) {\n                return aLong + \"-->\" + house.getDesc();\n            }\n        }\n).subscribe(new Observer<String>() {\n    @Override\n    public void onCompleted() {\n        System.exit(0);\n    }\n\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(\"Error:\"+e.getMessage());\n    }\n\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n});\n```\n\n程序输出：\n\n\t0-->中粮海景壹号新出大平层！总价4500W起\n\t1-->中粮海景壹号新出大平层！总价4500W起\n\t1-->满五唯一，黄金地段\n\t2-->中粮海景壹号新出大平层！总价4500W起\n\t2-->满五唯一，黄金地段\n\t2-->一楼自带小花园\n\t3-->一楼自带小花园\n\t3-->毗邻汤臣一品\n\t4-->毗邻汤臣一品\n\t4-->顶级住宅，给您总统般尊贵体验\n\t5-->顶级住宅，给您总统般尊贵体验\n\t5-->顶层户型，两室一厅\n\t6-->顶层户型，两室一厅\n\t6-->南北通透，豪华五房\n\t7-->南北通透，豪华五房\n\t\n通过[转换操作符](http://www.jianshu.com/p/5970280703b9)、[过滤操作符](http://www.jianshu.com/p/3a188b995daa)、[组合操作符](http://www.jianshu.com/p/546fe44a6e22)三个篇幅将RxJava主要的操作符也介绍的七七八八了。更多操作符的介绍建议大家去查阅官方文档，并自己动手实践一下。这一系列的文章也会持续更新，欢迎大家保持关注！:)\n\nDemo源码地址：[https://github.com/BaronZ88/HelloRxJava](https://github.com/BaronZ88/HelloRxJava)\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","slug":"RxJava系列5-组合操作符","published":1,"updated":"2017-02-05T17:58:53.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26f1000p6st6e2nme8ve","content":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>   </li>\n</ul>\n<hr>\n<p>这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： <strong><code>Merge</code></strong> <strong><code>StartWith</code></strong> <strong><code>Concat</code></strong> <strong><code>Zip</code></strong> <strong><code>CombineLatest</code></strong>  <strong><code>SwitchOnNext</code></strong> <strong><code>Join</code></strong>等等。</p>\n<h3 id=\"Merge\"><a href=\"#Merge\" class=\"headerlink\" title=\"Merge\"></a>Merge</h3><p><strong><code>merge(Observable, Observable)</code></strong>将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeOperator.png\" alt=\"merge(Observable, Observable)\"></p>\n<p>我们看下面的例子，一共有两个Observable：一个用来发送字母，另一个用来发送数字；现在我们需要两连个Observable发射的数据合并。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">String[] letters = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"F\"</span>, <span class=\"string\">\"G\"</span>, <span class=\"string\">\"H\"</span>&#125;;</div><div class=\"line\">Observable&lt;String&gt; letterSequence = Observable.interval(<span class=\"number\">300</span>, TimeUnit.MILLISECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> letters[position.intValue()];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(letters.length);</div><div class=\"line\"></div><div class=\"line\">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class=\"number\">500</span>, TimeUnit.MILLISECONDS).take(<span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">Observable.merge(letterSequence, numberSequence)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"Error:\"</span> + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Serializable serializable)</span> </span>&#123;</div><div class=\"line\">                System.out.print(serializable.toString()+<span class=\"string\">\" \"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>A 0 B C 1 D E 2 F 3 G H 4 \n</code></pre><p><strong><code>merge(Observable[])</code></strong>将多个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeIOOperator.png\" alt=\"merge(Observable[])\"></p>\n<h3 id=\"StartWith\"><a href=\"#StartWith\" class=\"headerlink\" title=\"StartWith\"></a>StartWith</h3><p><strong><code>startWith(T)</code></strong>用于在源Observable发射的数据前插入数据。使用<strong><code>startWith(Iterable&lt;T&gt;)</code></strong>我们还可以在源Observable发射的数据前插入Iterable。官方示意图：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOperator.png\" alt=\"startWith(T) startWith(Iterable&lt;T&gt;)\"></p>\n<p><strong><code>startWith(Observable&lt;T&gt;)</code></strong>用于在源Observable发射的数据前插入另一个Observable发射的数据（这些数据会被插入到<br>源Observable发射数据的前面）。官方示意图：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOOperator.png\" alt=\"startWith(Observable&lt;T&gt;)\"></p>\n<h3 id=\"Concat\"><a href=\"#Concat\" class=\"headerlink\" title=\"Concat\"></a>Concat</h3><p><strong><code>concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)</code></strong> <strong><code>concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;</code>)</strong>用于将多个obserbavle发射的的数据进行合并发射，concat严格按照顺序发射数据，前一个Observable没发射玩是不会发射后一个Observable的数据的。它和merge、startWitch和相似，不同之处在于：</p>\n<ol>\n<li>merge:合并后发射的数据是无序的；</li>\n<li>startWitch:只能在源Observable发射的数据前插入数据。</li>\n</ol>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ConcatOperator.png\" alt=\"concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)、concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;)\"></p>\n<p>这里我们将前面Merge操作符的例子拿过来，并将操作符换成<code>Concat</code>，然后我们看看执行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">String[] letters = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"F\"</span>, <span class=\"string\">\"G\"</span>, <span class=\"string\">\"H\"</span>&#125;;</div><div class=\"line\">Observable&lt;String&gt; letterSequence = Observable.interval(<span class=\"number\">300</span>, TimeUnit.MILLISECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> letters[position.intValue()];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(letters.length);</div><div class=\"line\"></div><div class=\"line\">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class=\"number\">500</span>, TimeUnit.MILLISECONDS).take(<span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">Observable.concat(letterSequence, numberSequence)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"Error:\"</span> + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Serializable serializable)</span> </span>&#123;</div><div class=\"line\">                System.out.print(serializable.toString() + <span class=\"string\">\" \"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>A B C D E F G H 0 1 2 3 4 \n</code></pre><h3 id=\"Zip\"><a href=\"#Zip\" class=\"headerlink\" title=\"Zip\"></a>Zip</h3><p><strong><code>zip(Observable, Observable, Func2)</code></strong>用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ZipOperator.png\" alt=\"zip(Observable, Observable, Func2)\"></p>\n<p>和前面的例子一样，我们将操作符换成了<code>zip</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">String[] letters = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"F\"</span>, <span class=\"string\">\"G\"</span>, <span class=\"string\">\"H\"</span>&#125;;</div><div class=\"line\">Observable&lt;String&gt; letterSequence = Observable.interval(<span class=\"number\">120</span>, TimeUnit.MILLISECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> letters[position.intValue()];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(letters.length);</div><div class=\"line\"></div><div class=\"line\">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class=\"number\">200</span>, TimeUnit.MILLISECONDS).take(<span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">Observable.zip(letterSequence, numberSequence, <span class=\"keyword\">new</span> Func2&lt;String, Long, String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(String letter, Long number)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> letter + number;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Error:\"</span> + e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String result)</span> </span>&#123;</div><div class=\"line\">        System.out.print(result + <span class=\"string\">\" \"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>A0 B1 C2 D3 E4\n</code></pre><h3 id=\"CombineLatest\"><a href=\"#CombineLatest\" class=\"headerlink\" title=\"CombineLatest\"></a>CombineLatest</h3><p><strong><code>comnineLatest(Observable, Observable, Func2)</code></strong>用于将两个Observale最近发射的数据已经Func2函数的规则进展组合。下面是官方提供的原理图：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatestOperator.png\" alt=\"comnineLatest(Observable, Observable, Func2)\"></p>\n<p>下面这张图应该更容易理解：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatest.png\" alt=\"comnineLatest(Observable, Observable, Func2)\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; communityNames = DataSimulator.getCommunityNames();</div><div class=\"line\">List&lt;Location&gt; locations = DataSimulator.getLocations();</div><div class=\"line\"></div><div class=\"line\">Observable&lt;String&gt; communityNameSequence = Observable.interval(<span class=\"number\">1</span>, TimeUnit.SECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> communityNames.get(position.intValue());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(communityNames.size());</div><div class=\"line\">Observable&lt;Location&gt; locationSequence = Observable.interval(<span class=\"number\">1</span>, TimeUnit.SECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, Location&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Location <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> locations.get(position.intValue());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(locations.size());</div><div class=\"line\"></div><div class=\"line\">Observable.combineLatest(</div><div class=\"line\">        communityNameSequence,</div><div class=\"line\">        locationSequence,</div><div class=\"line\">        <span class=\"keyword\">new</span> Func2&lt;String, Location, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(String communityName, Location location)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"小区名:\"</span> + communityName + <span class=\"string\">\", 经纬度:\"</span> + location.toString();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"Error:\"</span> + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">                System.out.println(s);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区名:竹园新村, 经纬度:(21.827, 23.323)\n小区名:康桥半岛, 经纬度:(21.827, 23.323)\n小区名:康桥半岛, 经纬度:(11.923, 16.309)\n小区名:中粮·海景壹号, 经纬度:(11.923, 16.309)\n小区名:中粮·海景壹号, 经纬度:(22.273, 53.623)\n小区名:浦江名苑, 经纬度:(22.273, 53.623)\n小区名:南辉小区, 经纬度:(22.273, 53.623)\n</code></pre><h3 id=\"SwitchOnNext\"><a href=\"#SwitchOnNext\" class=\"headerlink\" title=\"SwitchOnNext\"></a>SwitchOnNext</h3><p><strong><code>switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;</code></strong>用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新<br>的小Observable所发射的数据。</p>\n<p>结合下面的原理图大家应该很容易理解，我们可以看到下图中的黄色圆圈就被丢弃了。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/SwitchOnNextOperator.png\" alt=\"switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;)\"></p>\n<h3 id=\"Join\"><a href=\"#Join\" class=\"headerlink\" title=\"Join\"></a>Join</h3><p><strong><code>join(Observable, Func1, Func1, Func2)</code></strong>我们先介绍下join操作符的4个参数：</p>\n<ul>\n<li>Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；</li>\n<li>Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；</li>\n<li>Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；</li>\n<li>Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。</li>\n</ul>\n<p>所以Join操作符的语法结构大致是这样的：<strong><code>onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)</code></strong></p>\n<p>join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： <code>[0, B]</code> <code>[1, B]</code> <code>[2, B]</code> <code>[3, B]</code></p>\n<p>再看看下面的图是不是好理解了呢？！<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/JoinOperator.png\" alt=\"join(Observable, Func1, Func1, Func2)\"></p>\n<p>读懂了上面的文字，我们再来写段代码加深理解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> List&lt;House&gt; houses = DataSimulator.getHouses();<span class=\"comment\">//模拟的房源数据，用于测试</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用来每秒从houses总取出一套房源并发射出去</span></div><div class=\"line\">Observable&lt;House&gt; houseSequence =</div><div class=\"line\">        Observable.interval(<span class=\"number\">1</span>, TimeUnit.SECONDS)</div><div class=\"line\">                .map(<span class=\"keyword\">new</span> Func1&lt;Long, House&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> House <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> houses.get(position.intValue());</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;).take(houses.size());<span class=\"comment\">//这里的take是为了防止houses.get(position.intValue())数组越界</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用来实现每秒发送一个新的Long型数据</span></div><div class=\"line\">Observable&lt;Long&gt; tictoc = Observable.interval(<span class=\"number\">1</span>, TimeUnit.SECONDS);</div><div class=\"line\"></div><div class=\"line\">houseSequence.join(tictoc,</div><div class=\"line\">        <span class=\"keyword\">new</span> Func1&lt;House, Observable&lt;Long&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Long&gt; <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> Observable.timer(<span class=\"number\">2</span>, TimeUnit.SECONDS);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"keyword\">new</span> Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Long&gt; <span class=\"title\">call</span><span class=\"params\">(Long aLong)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> Observable.timer(<span class=\"number\">0</span>, TimeUnit.SECONDS);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"keyword\">new</span> Func2&lt;House, Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(House house, Long aLong)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> aLong + <span class=\"string\">\"--&gt;\"</span> + house.getDesc();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">).subscribe(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Error:\"</span>+e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>0--&gt;中粮海景壹号新出大平层！总价4500W起\n1--&gt;中粮海景壹号新出大平层！总价4500W起\n1--&gt;满五唯一，黄金地段\n2--&gt;中粮海景壹号新出大平层！总价4500W起\n2--&gt;满五唯一，黄金地段\n2--&gt;一楼自带小花园\n3--&gt;一楼自带小花园\n3--&gt;毗邻汤臣一品\n4--&gt;毗邻汤臣一品\n4--&gt;顶级住宅，给您总统般尊贵体验\n5--&gt;顶级住宅，给您总统般尊贵体验\n5--&gt;顶层户型，两室一厅\n6--&gt;顶层户型，两室一厅\n6--&gt;南北通透，豪华五房\n7--&gt;南北通透，豪华五房\n</code></pre><p>通过<a href=\"http://www.jianshu.com/p/5970280703b9\" target=\"_blank\" rel=\"external\">转换操作符</a>、<a href=\"http://www.jianshu.com/p/3a188b995daa\" target=\"_blank\" rel=\"external\">过滤操作符</a>、<a href=\"http://www.jianshu.com/p/546fe44a6e22\" target=\"_blank\" rel=\"external\">组合操作符</a>三个篇幅将RxJava主要的操作符也介绍的七七八八了。更多操作符的介绍建议大家去查阅官方文档，并自己动手实践一下。这一系列的文章也会持续更新，欢迎大家保持关注！:)</p>\n<p>Demo源码地址：<a href=\"https://github.com/BaronZ88/HelloRxJava\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88/HelloRxJava</a></p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>   </li>\n</ul>\n<hr>\n<p>这一章我们接着介绍组合操作符，这类operators可以同时处理多个Observable来创建我们所需要的Observable。组合操作符主要包含： <strong><code>Merge</code></strong> <strong><code>StartWith</code></strong> <strong><code>Concat</code></strong> <strong><code>Zip</code></strong> <strong><code>CombineLatest</code></strong>  <strong><code>SwitchOnNext</code></strong> <strong><code>Join</code></strong>等等。</p>\n<h3 id=\"Merge\"><a href=\"#Merge\" class=\"headerlink\" title=\"Merge\"></a>Merge</h3><p><strong><code>merge(Observable, Observable)</code></strong>将两个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。你可以简单的将它理解为两个Obsrvable合并成了一个Observable，合并后的数据是无序的。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeOperator.png\" alt=\"merge(Observable, Observable)\"></p>\n<p>我们看下面的例子，一共有两个Observable：一个用来发送字母，另一个用来发送数字；现在我们需要两连个Observable发射的数据合并。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">String[] letters = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"F\"</span>, <span class=\"string\">\"G\"</span>, <span class=\"string\">\"H\"</span>&#125;;</div><div class=\"line\">Observable&lt;String&gt; letterSequence = Observable.interval(<span class=\"number\">300</span>, TimeUnit.MILLISECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> letters[position.intValue()];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(letters.length);</div><div class=\"line\"></div><div class=\"line\">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class=\"number\">500</span>, TimeUnit.MILLISECONDS).take(<span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">Observable.merge(letterSequence, numberSequence)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"Error:\"</span> + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Serializable serializable)</span> </span>&#123;</div><div class=\"line\">                System.out.print(serializable.toString()+<span class=\"string\">\" \"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>A 0 B C 1 D E 2 F 3 G H 4 \n</code></pre><p><strong><code>merge(Observable[])</code></strong>将多个Observable发射的事件序列组合并成一个事件序列，就像是一个Observable发射的一样。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/MergeIOOperator.png\" alt=\"merge(Observable[])\"></p>\n<h3 id=\"StartWith\"><a href=\"#StartWith\" class=\"headerlink\" title=\"StartWith\"></a>StartWith</h3><p><strong><code>startWith(T)</code></strong>用于在源Observable发射的数据前插入数据。使用<strong><code>startWith(Iterable&lt;T&gt;)</code></strong>我们还可以在源Observable发射的数据前插入Iterable。官方示意图：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOperator.png\" alt=\"startWith(T) startWith(Iterable&lt;T&gt;)\"></p>\n<p><strong><code>startWith(Observable&lt;T&gt;)</code></strong>用于在源Observable发射的数据前插入另一个Observable发射的数据（这些数据会被插入到<br>源Observable发射数据的前面）。官方示意图：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/StartWithOOperator.png\" alt=\"startWith(Observable&lt;T&gt;)\"></p>\n<h3 id=\"Concat\"><a href=\"#Concat\" class=\"headerlink\" title=\"Concat\"></a>Concat</h3><p><strong><code>concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)</code></strong> <strong><code>concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;</code>)</strong>用于将多个obserbavle发射的的数据进行合并发射，concat严格按照顺序发射数据，前一个Observable没发射玩是不会发射后一个Observable的数据的。它和merge、startWitch和相似，不同之处在于：</p>\n<ol>\n<li>merge:合并后发射的数据是无序的；</li>\n<li>startWitch:只能在源Observable发射的数据前插入数据。</li>\n</ol>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ConcatOperator.png\" alt=\"concat(Observable&lt;? extends T&gt;, Observable&lt;? extends T&gt;)、concat(Observable&lt;？ extends Observable&lt;T&gt;&gt;)\"></p>\n<p>这里我们将前面Merge操作符的例子拿过来，并将操作符换成<code>Concat</code>，然后我们看看执行结果：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\">String[] letters = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"F\"</span>, <span class=\"string\">\"G\"</span>, <span class=\"string\">\"H\"</span>&#125;;</div><div class=\"line\">Observable&lt;String&gt; letterSequence = Observable.interval(<span class=\"number\">300</span>, TimeUnit.MILLISECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> letters[position.intValue()];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(letters.length);</div><div class=\"line\"></div><div class=\"line\">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class=\"number\">500</span>, TimeUnit.MILLISECONDS).take(<span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">Observable.concat(letterSequence, numberSequence)</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Observer&lt;Serializable&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"Error:\"</span> + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(Serializable serializable)</span> </span>&#123;</div><div class=\"line\">                System.out.print(serializable.toString() + <span class=\"string\">\" \"</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>A B C D E F G H 0 1 2 3 4 \n</code></pre><h3 id=\"Zip\"><a href=\"#Zip\" class=\"headerlink\" title=\"Zip\"></a>Zip</h3><p><strong><code>zip(Observable, Observable, Func2)</code></strong>用来合并两个Observable发射的数据项，根据Func2函数生成一个新的值并发射出去。当其中一个Observable发送数据结束或者出现异常后，另一个Observable也将停在发射数据。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/ZipOperator.png\" alt=\"zip(Observable, Observable, Func2)\"></p>\n<p>和前面的例子一样，我们将操作符换成了<code>zip</code>:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">String[] letters = <span class=\"keyword\">new</span> String[]&#123;<span class=\"string\">\"A\"</span>, <span class=\"string\">\"B\"</span>, <span class=\"string\">\"C\"</span>, <span class=\"string\">\"D\"</span>, <span class=\"string\">\"E\"</span>, <span class=\"string\">\"F\"</span>, <span class=\"string\">\"G\"</span>, <span class=\"string\">\"H\"</span>&#125;;</div><div class=\"line\">Observable&lt;String&gt; letterSequence = Observable.interval(<span class=\"number\">120</span>, TimeUnit.MILLISECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> letters[position.intValue()];</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(letters.length);</div><div class=\"line\"></div><div class=\"line\">Observable&lt;Long&gt; numberSequence = Observable.interval(<span class=\"number\">200</span>, TimeUnit.MILLISECONDS).take(<span class=\"number\">5</span>);</div><div class=\"line\"></div><div class=\"line\">Observable.zip(letterSequence, numberSequence, <span class=\"keyword\">new</span> Func2&lt;String, Long, String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(String letter, Long number)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> letter + number;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Error:\"</span> + e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String result)</span> </span>&#123;</div><div class=\"line\">        System.out.print(result + <span class=\"string\">\" \"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>A0 B1 C2 D3 E4\n</code></pre><h3 id=\"CombineLatest\"><a href=\"#CombineLatest\" class=\"headerlink\" title=\"CombineLatest\"></a>CombineLatest</h3><p><strong><code>comnineLatest(Observable, Observable, Func2)</code></strong>用于将两个Observale最近发射的数据已经Func2函数的规则进展组合。下面是官方提供的原理图：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatestOperator.png\" alt=\"comnineLatest(Observable, Observable, Func2)\"></p>\n<p>下面这张图应该更容易理解：<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/CombineLatest.png\" alt=\"comnineLatest(Observable, Observable, Func2)\"></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div></pre></td><td class=\"code\"><pre><div class=\"line\">List&lt;String&gt; communityNames = DataSimulator.getCommunityNames();</div><div class=\"line\">List&lt;Location&gt; locations = DataSimulator.getLocations();</div><div class=\"line\"></div><div class=\"line\">Observable&lt;String&gt; communityNameSequence = Observable.interval(<span class=\"number\">1</span>, TimeUnit.SECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> communityNames.get(position.intValue());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(communityNames.size());</div><div class=\"line\">Observable&lt;Location&gt; locationSequence = Observable.interval(<span class=\"number\">1</span>, TimeUnit.SECONDS)</div><div class=\"line\">        .map(<span class=\"keyword\">new</span> Func1&lt;Long, Location&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Location <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> locations.get(position.intValue());</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).take(locations.size());</div><div class=\"line\"></div><div class=\"line\">Observable.combineLatest(</div><div class=\"line\">        communityNameSequence,</div><div class=\"line\">        locationSequence,</div><div class=\"line\">        <span class=\"keyword\">new</span> Func2&lt;String, Location, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(String communityName, Location location)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> <span class=\"string\">\"小区名:\"</span> + communityName + <span class=\"string\">\", 经纬度:\"</span> + location.toString();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;).subscribe(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                System.out.println(<span class=\"string\">\"Error:\"</span> + e.getMessage());</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">                System.out.println(s);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>小区名:竹园新村, 经纬度:(21.827, 23.323)\n小区名:康桥半岛, 经纬度:(21.827, 23.323)\n小区名:康桥半岛, 经纬度:(11.923, 16.309)\n小区名:中粮·海景壹号, 经纬度:(11.923, 16.309)\n小区名:中粮·海景壹号, 经纬度:(22.273, 53.623)\n小区名:浦江名苑, 经纬度:(22.273, 53.623)\n小区名:南辉小区, 经纬度:(22.273, 53.623)\n</code></pre><h3 id=\"SwitchOnNext\"><a href=\"#SwitchOnNext\" class=\"headerlink\" title=\"SwitchOnNext\"></a>SwitchOnNext</h3><p><strong><code>switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;</code></strong>用来将一个发射多个小Observable的源Observable转化为一个Observable，然后发射这多个小Observable所发射的数据。如果一个小的Observable正在发射数据的时候，源Observable又发射出一个新的小Observable，则前一个Observable发射的数据会被抛弃，直接发射新<br>的小Observable所发射的数据。</p>\n<p>结合下面的原理图大家应该很容易理解，我们可以看到下图中的黄色圆圈就被丢弃了。<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/SwitchOnNextOperator.png\" alt=\"switchOnNext(Observable&lt;? extends Observable&lt;? extends T&gt;&gt;)\"></p>\n<h3 id=\"Join\"><a href=\"#Join\" class=\"headerlink\" title=\"Join\"></a>Join</h3><p><strong><code>join(Observable, Func1, Func1, Func2)</code></strong>我们先介绍下join操作符的4个参数：</p>\n<ul>\n<li>Observable：源Observable需要组合的Observable,这里我们姑且称之为目标Observable；</li>\n<li>Func1：接收从源Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了源Obsrvable发射出来的数据的有效期；</li>\n<li>Func1：接收目标Observable发射来的数据，并返回一个Observable，这个Observable的声明周期决定了目标Obsrvable发射出来的数据的有效期；</li>\n<li>Func2：接收从源Observable和目标Observable发射出来的数据，并将这两个数据组合后返回。</li>\n</ul>\n<p>所以Join操作符的语法结构大致是这样的：<strong><code>onservableA.join(observableB, 控制observableA发射数据有效期的函数， 控制observableB发射数据有效期的函数，两个observable发射数据的合并规则)</code></strong></p>\n<p>join操作符的效果类似于排列组合，把第一个数据源A作为基座窗口，他根据自己的节奏不断发射数据元素，第二个数据源B，每发射一个数据，我们都把它和第一个数据源A中已经发射的数据进行一对一匹配；举例来说，如果某一时刻B发射了一个数据“B”,此时A已经发射了0，1，2，3共四个数据，那么我们的合并操作就会把“B”依次与0,1,2,3配对，得到四组数据： <code>[0, B]</code> <code>[1, B]</code> <code>[2, B]</code> <code>[3, B]</code></p>\n<p>再看看下面的图是不是好理解了呢？！<br><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/operator/merge/JoinOperator.png\" alt=\"join(Observable, Func1, Func1, Func2)\"></p>\n<p>读懂了上面的文字，我们再来写段代码加深理解。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">final</span> List&lt;House&gt; houses = DataSimulator.getHouses();<span class=\"comment\">//模拟的房源数据，用于测试</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用来每秒从houses总取出一套房源并发射出去</span></div><div class=\"line\">Observable&lt;House&gt; houseSequence =</div><div class=\"line\">        Observable.interval(<span class=\"number\">1</span>, TimeUnit.SECONDS)</div><div class=\"line\">                .map(<span class=\"keyword\">new</span> Func1&lt;Long, House&gt;() &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> House <span class=\"title\">call</span><span class=\"params\">(Long position)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">return</span> houses.get(position.intValue());</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;).take(houses.size());<span class=\"comment\">//这里的take是为了防止houses.get(position.intValue())数组越界</span></div><div class=\"line\"></div><div class=\"line\"><span class=\"comment\">//用来实现每秒发送一个新的Long型数据</span></div><div class=\"line\">Observable&lt;Long&gt; tictoc = Observable.interval(<span class=\"number\">1</span>, TimeUnit.SECONDS);</div><div class=\"line\"></div><div class=\"line\">houseSequence.join(tictoc,</div><div class=\"line\">        <span class=\"keyword\">new</span> Func1&lt;House, Observable&lt;Long&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Long&gt; <span class=\"title\">call</span><span class=\"params\">(House house)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> Observable.timer(<span class=\"number\">2</span>, TimeUnit.SECONDS);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"keyword\">new</span> Func1&lt;Long, Observable&lt;Long&gt;&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Observable&lt;Long&gt; <span class=\"title\">call</span><span class=\"params\">(Long aLong)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> Observable.timer(<span class=\"number\">0</span>, TimeUnit.SECONDS);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;,</div><div class=\"line\">        <span class=\"keyword\">new</span> Func2&lt;House, Long, String&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(House house, Long aLong)</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">return</span> aLong + <span class=\"string\">\"--&gt;\"</span> + house.getDesc();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">).subscribe(<span class=\"keyword\">new</span> Observer&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.exit(<span class=\"number\">0</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"Error:\"</span>+e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>程序输出：</p>\n<pre><code>0--&gt;中粮海景壹号新出大平层！总价4500W起\n1--&gt;中粮海景壹号新出大平层！总价4500W起\n1--&gt;满五唯一，黄金地段\n2--&gt;中粮海景壹号新出大平层！总价4500W起\n2--&gt;满五唯一，黄金地段\n2--&gt;一楼自带小花园\n3--&gt;一楼自带小花园\n3--&gt;毗邻汤臣一品\n4--&gt;毗邻汤臣一品\n4--&gt;顶级住宅，给您总统般尊贵体验\n5--&gt;顶级住宅，给您总统般尊贵体验\n5--&gt;顶层户型，两室一厅\n6--&gt;顶层户型，两室一厅\n6--&gt;南北通透，豪华五房\n7--&gt;南北通透，豪华五房\n</code></pre><p>通过<a href=\"http://www.jianshu.com/p/5970280703b9\">转换操作符</a>、<a href=\"http://www.jianshu.com/p/3a188b995daa\">过滤操作符</a>、<a href=\"http://www.jianshu.com/p/546fe44a6e22\">组合操作符</a>三个篇幅将RxJava主要的操作符也介绍的七七八八了。更多操作符的介绍建议大家去查阅官方文档，并自己动手实践一下。这一系列的文章也会持续更新，欢迎大家保持关注！:)</p>\n<p>Demo源码地址：<a href=\"https://github.com/BaronZ88/HelloRxJava\">https://github.com/BaronZ88/HelloRxJava</a></p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"RxJava系列6(从微观角度解读RxJava源码)","date":"2017-02-05T16:21:05.000Z","_content":"\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)  \n\n***\n\n## 前言\n通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：\n\n* RxJava基本流程分析\n* 操作符原理分析\n* 线程调度原理分析\n\n> 本章节基于**RxJava1.1.9**版本的源码\n\n## 一、RxJava执行流程分析\n\n在[RxJava系列2(基本概念及使用介绍)](http://www.jianshu.com/p/ba61c047c230)中我们介绍过，一个最基本的RxJava调用是这样的：\n\n**示例A**\n\n```java\nObservable.create(new Observable.OnSubscribe<String>() {\n    @Override\n    public void call(Subscriber<? super String> subscriber) {\n        subscriber.onNext(\"Hello RxJava!\");\n        subscriber.onCompleted();\n    }\n}).subscribe(new Subscriber<String>() {\n    @Override\n    public void onCompleted() {\n        System.out.println(\"completed!\");\n    }\n    @Override\n    public void onError(Throwable e) {\n    }\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n});\n```\n\n首先调用`Observable.create()`创建一个被观察者`Observable`，同时创建一个`OnSubscribe`作为`create()`方法的入参；接着创建一个观察者`Subscriber`，然后通过`subseribe()`实现二者的订阅关系。这里涉及到三个关键对象和一个核心的方法：\n\n* **Observable**（被观察者）\n* **OnSubscribe** (从纯设计模式的角度来理解，`OnSubscribe.call()`可以看做是[观察者模式](https://github.com/BaronZ88/Blog/blob/master/DesignPatterns/ObserverPattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md)中被观察者用来通知观察者的`notifyObservers()`方法)\n* **Subscriber** （观察者）\n* **subscribe()** （实现观察者与被观察者订阅关系的方法）\n\n### 1、Observable.create()源码分析\n\n首先我们来看看`Observable.create()`的实现:\n\n```java\npublic static <T> Observable<T> create(OnSubscribe<T> f) {\n\treturn new Observable<T>(RxJavaHooks.onCreate(f));\n}\n```\n这里创建了一个被观察者`Observable`，同时将`RxJavaHooks.onCreate(f)`作为构造函数的参数，源码如下：\n\n```java\nprotected Observable(OnSubscribe<T> f) {\n\tthis.onSubscribe = f;\n}\n```\n\n我们看到源码中直接将参数`RxJavaHooks.onCreate(f)`赋值给了当前我们构造的被观察者`Observable`的成员变量`onSubscribe`。那么`RxJavaHooks.onCreate(f)`返回的又是什么呢？我们接着往下看：\n\n```java\npublic static <T> Observable.OnSubscribe<T> onCreate(Observable.OnSubscribe<T> onSubscribe) {\n    Func1<OnSubscribe, OnSubscribe> f = onObservableCreate;\n    if (f != null) {\n        return f.call(onSubscribe);\n    }\n    return onSubscribe;\n}\n```\n\n由于我们并没调用`RxJavaHooks.initCreate()`，所以上面代码中的`onObservableCreate`为null；因此`RxJavaHooks.onCreate(f)`最终返回的就是`f`，也就是我们在`Observable.create()`的时候new出来的`OnSubscribe`。（*由于对RxJavaHooks的理解并不影响我们对RxJava执行流程的分析，因此在这里我们不做进一步的探讨。为了方便理解我们只需要知道RxJavaHooks一系列方法的返回值就是入参本身就OK了，例如这里的`RxJavaHooks.onCreate(f)`返回的就是`f`*）。\n\n至此我们做下逻辑梳理：**`Observable.create()`方法构造了一个被观察者`Observable`对象，同时将new出来的`OnSubscribe`赋值给了该`Observable`的成员变量`onSubscribe`。**\n\n### 2、Subscriber源码分析\n\n接着我们看下观察者`Subscriber`的源码，为了增加可读性，我去掉了源码中的注释和部分代码。\n\n```java\npublic abstract class Subscriber<T> implements Observer<T>, Subscription {\n    \n    private final SubscriptionList subscriptions;//订阅事件集，所有发送给当前Subscriber的事件都会保存在这里\n    \n    ...\n\n    protected Subscriber(Subscriber<?> subscriber, boolean shareSubscriptions) {\n        this.subscriber = subscriber;\n        this.subscriptions = shareSubscriptions && subscriber != null ? subscriber.subscriptions : new SubscriptionList();\n    }\n\n    ...\n\n    @Override\n    public final void unsubscribe() {\n        subscriptions.unsubscribe();\n    }\n\n    @Override\n    public final boolean isUnsubscribed() {\n        return subscriptions.isUnsubscribed();\n    }\n\n    public void onStart() {\n    }\n    \n    ...\n}\n```\n\n```java\npublic interface Subscription {\n    void unsubscribe();\n    boolean isUnsubscribed();\n}\n```\n\n`Subscriber`实现了`Subscription`接口，从而对外提供`isUnsubscribed()`和`unsubscribe()`方法。前者用于判断是否已经取消订阅；后者用于将订阅事件列表(*也就是当前观察者的成员变量`subscriptions`*)中的所有`Subscription`取消订阅，并且不再接受观察者`Observable`发送的后续事件。\n\n### 3、subscribe()源码分析\n前面我们分析了观察者和被观察者相关的源码，那么接下来便是整个订阅流程中最最关键的环节了。\n\n```java\npublic final Subscription subscribe(Subscriber<? super T> subscriber) {\n    return Observable.subscribe(subscriber, this);\n}\n```\n\n```java\nstatic <T> Subscription subscribe(Subscriber<? super T> subscriber, Observable<T> observable) {\n\n\t...\n\n    subscriber.onStart();\n    \n    if (!(subscriber instanceof SafeSubscriber)) {\n        subscriber = new SafeSubscriber<T>(subscriber);\n    }\n\n    try {\n        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);\n\n        return RxJavaHooks.onObservableReturn(subscriber);\n    } catch (Throwable e) {\n        ...\n        return Subscriptions.unsubscribed();\n    }\n}\n```\n\n`subscribe()`方法中将传进来的`subscriber`包装成了`SafeSubscriber`，`SafeSubscriber`其实是`subscriber`的一个代理，对`subscriber`的一系列方法做了更加严格的安全校验。保证了`onCompleted()`和`onError()`只会有一个被执行且只执行一次，一旦它们其中方法被执行过后`onNext()`就不在执行了。\n\n上述代码中最关键的就是`RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber)`。这里的RxJavaHooks和之前提到的一样，`RxJavaHooks.onObservableStart(observable, observable.onSubscribe)`返回的正是他的第二个入参`observable.onSubscribe`，也就是当前`observable`的成员变量`onSubscribe`。而这个成员变量我们前面提到过，它是我们在`Observable.create()`的时候new出来的。所以这段代码可以简化为`onSubscribe.call(subscriber)`。这也印证了我在[RxJava系列2(基本概念及使用介绍)](http://www.jianshu.com/p/ba61c047c230)中说的，`onSubscribe.call(subscriber)`中的`subscriber`正是我们在`subscribe()`方法中new出来的观察者。\n\n到这里，我们对RxJava的执行流程做个总结：首先我们调用`crate()`创建一个观察者，同时创建一个`OnSubscribe`作为该方法的入参；接着调用`subscribe()`来订阅我们自己创建的观察者`Subscriber`。\n一旦调用`subscribe()`方法后就会触发执行`OnSubscribe.call()`。然后我们就可以在call方法调用观察者`subscriber`的`onNext()`,`onCompleted()`,`onError()`。\n\n最后我用张图来总结下之前的分析结果：\n\n![RxJava基本流程分析](http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess1.jpg)\n\n## 二、操作符原理分析\n之前我们介绍过几十个操作符，要一一分析它们的源码显然不太现实。在这里我抛砖引玉，选取一个相对简单且常用的`map`操作符来分析。\n\n我们先来看一个`map`操作符的简单应用：\n\n**示例B**\n\n```java\nObservable.create(new Observable.OnSubscribe<Integer>() {\n    @Override\n    public void call(Subscriber<? super Integer> subscriber) {\n        subscriber.onNext(1);\n        subscriber.onCompleted();\n    }\n}).map(new Func1<Integer, String>() {\n    @Override\n    public String call(Integer integer) {\n        return \"This is \" + integer;\n    }\n}).subscribe(new Subscriber<String>() {\n    @Override\n    public void onCompleted() {\n        System.out.println(\"onCompleted!\");\n    }\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(e.getMessage());\n    }\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n});\n```\n\n为了便于表述，我将上面的代码做了如下拆解：\n\n```java\nObservable<Integer> observableA = Observable.create(new Observable.OnSubscribe<Integer>() {\n    @Override\n    public void call(Subscriber<? super Integer> subscriber) {\n        subscriber.onNext(1);\n        subscriber.onCompleted();\n    }\n});\n\nSubscriber<String> subscriberOne = new Subscriber<String>() {\n    @Override\n    public void onCompleted() {\n        System.out.println(\"onCompleted!\");\n    }\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(e.getMessage());\n    }\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n};\n\nObservable<String> observableB = \n        observableA.map(new Func1<Integer, String>() {\n                @Override\n                public String call(Integer integer) {\n                    return \"This is \" + integer;;\n                }\n            });\n\nobservableB.subscribe(subscriberOne);\n```\n\n`map()`的源码和上一小节介绍的`create()`一样位于`Observable`这个类中。\n\n```java\npublic final <R> Observable<R> map(Func1<? super T, ? extends R> func) {\n    return create(new OnSubscribeMap<T, R>(this, func));\n}\n```\n\n通过查看源码我们发现调用`map()`的时候实际上是创建了一个新的被观察者`Observable`，我们姑且称它为`ObservableB`；一开始通过`Observable.create()`创建的`Observable`我们称之为`ObservableA`。在创建`ObservableB`的时候同时创建了一个`OnSubscribeMap`，而`ObservableA`和变换函数`Func1`则作为构造`OnSubscribeMap`的参数。\n\n\n```java\npublic final class OnSubscribeMap<T, R> implements OnSubscribe<R> {\n\n    final Observable<T> source;//ObservableA\n    \n    final Func1<? super T, ? extends R> transformer;//map操作符中的转换函数Func1。T为转换前的数据类型，在上面的例子中为Integer；R为转换后的数据类型，在该例中为String。\n\n    public OnSubscribeMap(Observable<T> source, Func1<? super T, ? extends R> transformer) {\n        this.source = source;\n        this.transformer = transformer;\n    }\n    \n    @Override\n    public void call(final Subscriber<? super R> o) {//结合第一小节的分析结果，我们知道这里的入参o其实就是我们自己new的观察者subscriberOne。\n        MapSubscriber<T, R> parent = new MapSubscriber<T, R>(o, transformer);\n        o.add(parent);\n        source.unsafeSubscribe(parent);\n    }\n    \n    static final class MapSubscriber<T, R> extends Subscriber<T> {\n        \n        final Subscriber<? super R> actual;//这里的actual就是我们在调用subscribe()时创建的观察者mSubscriber\n        final Func1<? super T, ? extends R> mapper;//变换函数\n        boolean done;\n        \n        public MapSubscriber(Subscriber<? super R> actual, Func1<? super T, ? extends R> mapper) {\n            this.actual = actual;\n            this.mapper = mapper;\n        }\n        \n        @Override\n        public void onNext(T t) {\n            R result;\n            try {\n                result = mapper.call(t);\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                unsubscribe();\n                onError(OnErrorThrowable.addValueAsLastCause(ex, t));\n                return;\n            }\n            actual.onNext(result);\n        }\n        \n        @Override\n        public void onError(Throwable e) {\n            ...\n            actual.onError(e);\n        }\n        \n        @Override\n        public void onCompleted() {\n            ...\n            actual.onCompleted();\n        }\n        \n        @Override\n        public void setProducer(Producer p) {\n            actual.setProducer(p);\n        }\n    }\n}\n```\n\n`OnSubscribeMap`实现了`OnSubscribe`接口，因此`OnSubscribeMap`就是一个`OnSubscribe`。在调用`map()`的时候创建了一个新的被观察者`ObservableB`，然后我们用`ObservableB.subscribe(subscriberOne)`订阅了观察者`subscriberOne`。结合我们在第一小节的分析结果，所以`OnSubscribeMap.call(o)`中的`o`就是`subscribe(subscriberOne)`中的`subscriberOne`；一旦调用了`ObservableB.subscribe(subscriberOne)`就会执行`OnSubscribeMap.call()`。\n\n在`call()`方法中，首先通过我们的观察者`o`和转换函数`transformer`构造了一个`MapSubscriber`，最后调用了`source`也就是`observableA`的`unsafeSubscribe()`方法。即`observableA`订阅了一个观察者`MapSubscriber`。\n\n```java\npublic final Subscription unsafeSubscribe(Subscriber<? super T> subscriber) {\n    try {\n        ...\n        RxJavaHooks.onObservableStart(this, onSubscribe).call(subscriber);\n        return RxJavaHooks.onObservableReturn(subscriber);\n    } catch (Throwable e) {\n        ...\n        return Subscriptions.unsubscribed();\n    }\n}\n```\n上面这段代码最终执行了`onSubscribe`也就是`OnSubscribeMap`的`call()`方法，`call()`方法中的参数就是之前在`OnSubscribeMap.call()`中new出来的`MapSubscriber`。最后在`call()`方法中执行了我们自己的业务代码：\n\n```java\nsubscriber.onNext(1);\nsubscriber.onCompleted();\n```\n\n其实也就是执行了`MapSubscriber`的`onNext()`和`onCompleted()`。\n\n```java\n@Override\npublic void onNext(T t) {\n    R result;\n    try {\n        result = mapper.call(t);\n    } catch (Throwable ex) {\n        ...\n        return;\n    }\n    actual.onNext(result);\n}\n```\n\n`onNext(T t)`方法中的的`mapper`就是变换函数，`actual`就是我们在调用`subscribe()`时创建的观察者`subscriberOne`。这个`T`就是我们例子中的`Integer`，`R`就是`String`。在`onNext()`中首先调用变换函数`mapper.call()`将`T`转换成`R`(在我们的例子中就是将`Integer`类型的**1**转换成了`String`类型的**“This is 1”**)；接着调用`subscriberOne.onNext(String result)`。同样在调用`MapSubscriber.onCompleted()`时会执行`subscriberOne.onCompleted()`。这样就完成了一直完成的调用流程。\n\n我承认太啰嗦了，花费了这么大的篇幅才将`map()`的转换原理解释清楚。我也是希望尽量的将每个细节都呈现出来方便大家理解，如果看我啰嗦了这么久还是没能理解，请看下面我画的这张执行流程图。\n\n![加入Map操作符后的执行流程](http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess3.jpg)\n\n## 三、线程调度原理分析\n在前面的文章中我介绍过RxJava可以很方便的通过`subscribeOn()`和`observeOn()`来指定数据流的每一部分运行在哪个线程。其中`subscribeOn()`指定了处理`Observable`的全部的过程(包括发射数据和通知)的线程；`observeOn()`指定了观察者的`onNext()`, `onError()`和`onCompleted()`执行的线程。接下来我们就分析分析源码，看看线程调度是如何实现的。\n\n在分析源码前我们先看看一段常见的通过RxJava实现的线程调度代码：\n\n**示例C**\n\n```java\nObservable.create(new Observable.OnSubscribe<String>() {\n    @Override\n    public void call(Subscriber<? super String> subscriber) {\n        subscriber.onNext(\"Hello RxJava!\");\n        subscriber.onCompleted();\n    }\n}).subscribeOn(Schedulers.io())\n.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Subscriber<String>() {\n    @Override\n    public void onCompleted() {\n        System.out.println(\"completed!\");\n    }\n    @Override\n    public void onError(Throwable e) {\n    }\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n});\n```\n\n### 1、subscribeOn()源码分析\n\n```java\npublic final Observable<T> subscribeOn(Scheduler scheduler) {\n    ...\n    return create(new OperatorSubscribeOn<T>(this, scheduler));\n}\n```\n\n通过上面的代码我们可以看到，`subscribeOn()`和`map()`一样是创建了一个新的被观察者`Observable`。因此我大致就能猜到`subscribeOn()`的执行流程应该和`map()`差不多，`OperatorSubscribeOn`肯定也是一个`OnSubscribe`。那我们接下来就看看`OperatorSubscribeOn`的源码：\n\n```java\npublic final class OperatorSubscribeOn<T> implements OnSubscribe<T> {\n\n    final Scheduler scheduler;//线程调度器，用来指定订阅事件发送、处理等所在的线程\n    final Observable<T> source;\n\n    public OperatorSubscribeOn(Observable<T> source, Scheduler scheduler) {\n        this.scheduler = scheduler;\n        this.source = source;\n    }\n\n    @Override\n    public void call(final Subscriber<? super T> subscriber) {\n        final Worker inner = scheduler.createWorker();\n        subscriber.add(inner);\n        \n        inner.schedule(new Action0() {\n            @Override\n            public void call() {\n                final Thread t = Thread.currentThread();\n                \n                Subscriber<T> s = new Subscriber<T>(subscriber) {\n                    @Override\n                    public void onNext(T t) {\n                        subscriber.onNext(t);\n                    }\n                    \n                    @Override\n                    public void onError(Throwable e) {\n                        try {\n                            subscriber.onError(e);\n                        } finally {\n                            inner.unsubscribe();\n                        }\n                    }\n                    \n                    @Override\n                    public void onCompleted() {\n                        try {\n                            subscriber.onCompleted();\n                        } finally {\n                            inner.unsubscribe();\n                        }\n                    }\n                    \n                    @Override\n                    public void setProducer(final Producer p) {\n                        subscriber.setProducer(new Producer() {\n                            @Override\n                            public void request(final long n) {\n                                if (t == Thread.currentThread()) {\n                                    p.request(n);\n                                } else {\n                                    inner.schedule(new Action0() {\n                                        @Override\n                                        public void call() {\n                                            p.request(n);\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                };\n                source.unsafeSubscribe(s);\n            }\n        });\n    }\n}\n```\n\n`OperatorSubscribeOn`实现了`OnSubscribe`接口，`call()`中对`Subscriber`的处理也和`OperatorMap`对`Subscriber`的处理类似。首先通过`scheduler`构建了一个`Worker`；然后用传进来的`subscriber`构造了一个新的`Subscriber s`，并将`s`丢到`Worker.schedule()`中来处理；最后用原`Observable`去订阅观察者`s`。而这个`Worker`就是线程调度的关键！前面的例子中我们通过`subscribeOn(Schedulers.io())`指定了`Observable`发射处理事件以及通知观察者的一系列操作的执行线程，正是通过这个`Schedulers.io()`创建了我们前面提到的`Worker`。所以我们来看看`Schedulers.io()`的实现。\n\n首先通过`Schedulers.io()`获得了`ioScheduler`并返回，上面的`OperatorSubscribeOn`通过这个的`Scheduler`的`createWorker()`方法创建了我们前面提到的`Worker`。\n\n```java\npublic static Scheduler io() {\n    return RxJavaHooks.onIOScheduler(getInstance().ioScheduler);\n}\n```\n\n接着我们看看这个`ioScheduler`是怎么来的，下面的代码向我们展现了是如何在`Schedulers`的构造函数中通过`RxJavaSchedulersHook.createIoScheduler()`来初始化`ioScheduler`的。\n\n```java\nprivate Schedulers() {\n\n    ...\n\n    Scheduler io = hook.getIOScheduler();\n    if (io != null) {\n        ioScheduler = io;\n    } else {\n        ioScheduler = RxJavaSchedulersHook.createIoScheduler();\n    }\n\n    ...\n}\n```\n\n最终`RxJavaSchedulersHook.createIoScheduler()`返回了一个`CachedThreadScheduler`，并赋值给了`ioScheduler`。\n\n```java\npublic static Scheduler createIoScheduler() {\n    return createIoScheduler(new RxThreadFactory(\"RxIoScheduler-\"));\n}\n```\n\n```java\npublic static Scheduler createIoScheduler(ThreadFactory threadFactory) {\n    ...\n    return new CachedThreadScheduler(threadFactory);\n}\n```\n\n到这一步既然我们知道了`ioScheduler`就是一个`CachedThreadScheduler`，那我们就来看看它的`createWorker()`的实现。\n\n```java\npublic Worker createWorker() {\n    return new EventLoopWorker(pool.get());\n}\n```\n\n上面的代码向我们赤裸裸的呈现了前面`OperatorSubscribeOn`中的`Worker`其实就是`EventLoopWorker`。我们重点要关注的是他的`scheduleActual()`。\n\n```java\nstatic final class EventLoopWorker extends Scheduler.Worker implements Action0 {\n    private final CompositeSubscription innerSubscription = new CompositeSubscription();\n    private final CachedWorkerPool pool;\n    private final ThreadWorker threadWorker;\n    final AtomicBoolean once;\n\n    EventLoopWorker(CachedWorkerPool pool) {\n        this.pool = pool;\n        this.once = new AtomicBoolean();\n        this.threadWorker = pool.get();\n    }\n\n    ...\n\n    @Override\n    public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {\n        ...\n        ScheduledAction s = threadWorker.scheduleActual(new Action0() {\n            @Override\n            public void call() {\n                if (isUnsubscribed()) {\n                    return;\n                }\n                action.call();\n            }\n        }, delayTime, unit);\n        innerSubscription.add(s);\n        s.addParent(innerSubscription);\n        return s;\n    }\n}\n```\n\n通过对源码的一步步追踪，我们知道了前面`OperatorSubscribeOn.call()`中的`inner.schedule()`最终会执行到`ThreadWorker`的`scheduleActual()`方法。\n\n```java\npublic ScheduledAction scheduleActual(final Action0 action, long delayTime, TimeUnit unit) {\n    Action0 decoratedAction = RxJavaHooks.onScheduledAction(action);\n    ScheduledAction run = new ScheduledAction(decoratedAction);\n    Future<?> f;\n    if (delayTime <= 0) {\n        f = executor.submit(run);\n    } else {\n        f = executor.schedule(run, delayTime, unit);\n    }\n    run.add(f);\n    return run;\n}\n```\n`scheduleActual()`中的`ScheduledAction`实现了`Runnable`接口，通过线程池`executor`最终实现了线程切换。上面便是`subscribeOn(Schedulers.io())`实现线程切换的全部过程。\n\n### 2、observeOn()源码分析\n\n`observeOn()`切换线程是通过`lift`来实现的，相比`subscribeOn()`在实现原理上相对复杂些。不过本质上最终还是创建了一个新的`Observable`。\n\n```java\npublic final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {\n    ...\n    return lift(new OperatorObserveOn<T>(scheduler, delayError, bufferSize));\n}\n\npublic final <R> Observable<R> lift(final Operator<? extends R, ? super T> operator) {\n    return create(new OnSubscribeLift<T, R>(onSubscribe, operator));\n}\n```\n\n`OperatorObserveOn`作为`OnSubscribeLift`构造函数的参数用来创建了一个新的`OnSubscribeLift`对象，接下来我们看看`OnSubscribeLift`的实现：\n\n```java\npublic final class OnSubscribeLift<T, R> implements OnSubscribe<R> {\n    \n    final OnSubscribe<T> parent;\n\n    final Operator<? extends R, ? super T> operator;\n\n    public OnSubscribeLift(OnSubscribe<T> parent, Operator<? extends R, ? super T> operator) {\n        this.parent = parent;\n        this.operator = operator;\n    }\n\n    @Override\n    public void call(Subscriber<? super R> o) {\n        try {\n            Subscriber<? super T> st = RxJavaHooks.onObservableLift(operator).call(o);\n            try {\n                st.onStart();\n                parent.call(st);\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                st.onError(e);\n            }\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            o.onError(e);\n        }\n    }\n}\n```\n\n`OnSubscribeLift`继承自`OnSubscribe`，通过前面的分析我们知道一旦调用了`subscribe()`将观察者与被观察绑定后就会触发被观察者所对应的`OnSubscribe`的`call()`方法，所以这里会触发`OnSubscribeLift.call()`。在`call()`中调用了`OperatorObserveOn.call()`并返回了一个新的观察者`Subscriber st`，接着调用了前一级`Observable`对应`OnSubscriber.call(st)`。\n\n我们再看看`OperatorObserveOn.call()`的实现：\n\n```java\npublic Subscriber<? super T> call(Subscriber<? super T> child) {\n    ...\n    ObserveOnSubscriber<T> parent = new ObserveOnSubscriber<T>(scheduler, child, delayError, bufferSize);\n    parent.init();\n    return parent;\n}\n```\n\n`OperatorObserveOn.call()`中创建了一个`ObserveOnSubscriber`并调用`init()`进行了初始化。\n\n```java\nstatic final class ObserveOnSubscriber<T> extends Subscriber<T> implements Action0 {\n\n    ...\n\n    @Override\n    public void onNext(final T t) {\n        ...\n        schedule();\n    }\n\n    @Override\n    public void onCompleted() {\n        ...\n        schedule();\n    }\n\n    @Override\n    public void onError(final Throwable e) {\n        ...\n        schedule();\n    }\n\n    protected void schedule() {\n        if (counter.getAndIncrement() == 0) {\n            recursiveScheduler.schedule(this);\n        }\n    }\n\n    @Override\n    public void call() {\n        long missed = 1L;\n        long currentEmission = emitted;\n\n        final Queue<Object> q = this.queue;\n        final Subscriber<? super T> localChild = this.child;\n        final NotificationLite<T> localOn = this.on;\n        \n        for (;;) {\n            long requestAmount = requested.get();\n            \n            while (requestAmount != currentEmission) {\n                boolean done = finished;\n                Object v = q.poll();\n                boolean empty = v == null;\n                \n                if (checkTerminated(done, empty, localChild, q)) {\n                    return;\n                }\n                \n                if (empty) {\n                    break;\n                }\n                \n                localChild.onNext(localOn.getValue(v));\n\n                currentEmission++;\n                if (currentEmission == limit) {\n                    requestAmount = BackpressureUtils.produced(requested, currentEmission);\n                    request(currentEmission);\n                    currentEmission = 0L;\n                }\n            }\n            \n            if (requestAmount == currentEmission) {\n                if (checkTerminated(finished, q.isEmpty(), localChild, q)) {\n                    return;\n                }\n            }\n\n            emitted = currentEmission;\n            missed = counter.addAndGet(-missed);\n            if (missed == 0L) {\n                break;\n            }\n        }\n    }\n    \n    ...\n}\n```\n\n`ObserveOnSubscriber`继承自`Subscriber`，并实现了`Action0`接口。我们看到`ObserveOnSubscriber`的`onNext()`、`onCompleted()`、`onError()`都有个`schedule()`，这个方法就是我们线程调度的关键；通过`schedule()`将新观察者`ObserveOnSubscriber`发送给`subscriberOne`的所有事件都切换到了`recursiveScheduler`所对应的线程，简单的说就是把`subscriberOne`的`onNext()`、`onCompleted()`、`onError()`方法丢到了`recursiveScheduler`对应的线程中来执行。\n\n那么`schedule()`又是如何做到这一点的呢？他内部调用了`recursiveScheduler.schedule(this)`，`recursiveScheduler`其实就是一个`Worker`，和我们在介绍`subscribeOn()`时提到的`worker`一样，执行`schedule()`实际上最终是创建了一个`runable`，然后把这个`runnable`丢到了特定的线程池中去执行。在`runnable`的`run()`方法中调用了`ObserveOnSubscriber.call()`，看上面的代码大家就会发现在`call()`方法中最终调用了`subscriberOne`的`onNext()`、`onCompleted()`、`onError()`方法。这便是它实现线程切换的原理。\n\n好了，我们最后再看看**示例C**对应的执行流程图，帮助大家加深理解。\n\n![RxJava执行流程](http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess.jpg)\n\n\n## 总结\n这一章以**执行流程**、**操作符实现**以及**线程调度**三个方面为切入点剖析了RxJava源码。下一章将站在更宏观的角度来分析整个RxJava的框架结构、设计思想等等。敬请期待~~ :)\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)","source":"_posts/2017-02-06-RxJava系列6-从微观角度解读RxJava源码.md","raw":"---\ntitle: RxJava系列6(从微观角度解读RxJava源码)\ndate: 2017-02-06 00:21:05\ncategories: rxjava\ntags: \n- RxJava\n- Android\n---\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/)  \n\n***\n\n## 前言\n通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：\n\n* RxJava基本流程分析\n* 操作符原理分析\n* 线程调度原理分析\n\n> 本章节基于**RxJava1.1.9**版本的源码\n\n## 一、RxJava执行流程分析\n\n在[RxJava系列2(基本概念及使用介绍)](http://www.jianshu.com/p/ba61c047c230)中我们介绍过，一个最基本的RxJava调用是这样的：\n\n**示例A**\n\n```java\nObservable.create(new Observable.OnSubscribe<String>() {\n    @Override\n    public void call(Subscriber<? super String> subscriber) {\n        subscriber.onNext(\"Hello RxJava!\");\n        subscriber.onCompleted();\n    }\n}).subscribe(new Subscriber<String>() {\n    @Override\n    public void onCompleted() {\n        System.out.println(\"completed!\");\n    }\n    @Override\n    public void onError(Throwable e) {\n    }\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n});\n```\n\n首先调用`Observable.create()`创建一个被观察者`Observable`，同时创建一个`OnSubscribe`作为`create()`方法的入参；接着创建一个观察者`Subscriber`，然后通过`subseribe()`实现二者的订阅关系。这里涉及到三个关键对象和一个核心的方法：\n\n* **Observable**（被观察者）\n* **OnSubscribe** (从纯设计模式的角度来理解，`OnSubscribe.call()`可以看做是[观察者模式](https://github.com/BaronZ88/Blog/blob/master/DesignPatterns/ObserverPattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md)中被观察者用来通知观察者的`notifyObservers()`方法)\n* **Subscriber** （观察者）\n* **subscribe()** （实现观察者与被观察者订阅关系的方法）\n\n### 1、Observable.create()源码分析\n\n首先我们来看看`Observable.create()`的实现:\n\n```java\npublic static <T> Observable<T> create(OnSubscribe<T> f) {\n\treturn new Observable<T>(RxJavaHooks.onCreate(f));\n}\n```\n这里创建了一个被观察者`Observable`，同时将`RxJavaHooks.onCreate(f)`作为构造函数的参数，源码如下：\n\n```java\nprotected Observable(OnSubscribe<T> f) {\n\tthis.onSubscribe = f;\n}\n```\n\n我们看到源码中直接将参数`RxJavaHooks.onCreate(f)`赋值给了当前我们构造的被观察者`Observable`的成员变量`onSubscribe`。那么`RxJavaHooks.onCreate(f)`返回的又是什么呢？我们接着往下看：\n\n```java\npublic static <T> Observable.OnSubscribe<T> onCreate(Observable.OnSubscribe<T> onSubscribe) {\n    Func1<OnSubscribe, OnSubscribe> f = onObservableCreate;\n    if (f != null) {\n        return f.call(onSubscribe);\n    }\n    return onSubscribe;\n}\n```\n\n由于我们并没调用`RxJavaHooks.initCreate()`，所以上面代码中的`onObservableCreate`为null；因此`RxJavaHooks.onCreate(f)`最终返回的就是`f`，也就是我们在`Observable.create()`的时候new出来的`OnSubscribe`。（*由于对RxJavaHooks的理解并不影响我们对RxJava执行流程的分析，因此在这里我们不做进一步的探讨。为了方便理解我们只需要知道RxJavaHooks一系列方法的返回值就是入参本身就OK了，例如这里的`RxJavaHooks.onCreate(f)`返回的就是`f`*）。\n\n至此我们做下逻辑梳理：**`Observable.create()`方法构造了一个被观察者`Observable`对象，同时将new出来的`OnSubscribe`赋值给了该`Observable`的成员变量`onSubscribe`。**\n\n### 2、Subscriber源码分析\n\n接着我们看下观察者`Subscriber`的源码，为了增加可读性，我去掉了源码中的注释和部分代码。\n\n```java\npublic abstract class Subscriber<T> implements Observer<T>, Subscription {\n    \n    private final SubscriptionList subscriptions;//订阅事件集，所有发送给当前Subscriber的事件都会保存在这里\n    \n    ...\n\n    protected Subscriber(Subscriber<?> subscriber, boolean shareSubscriptions) {\n        this.subscriber = subscriber;\n        this.subscriptions = shareSubscriptions && subscriber != null ? subscriber.subscriptions : new SubscriptionList();\n    }\n\n    ...\n\n    @Override\n    public final void unsubscribe() {\n        subscriptions.unsubscribe();\n    }\n\n    @Override\n    public final boolean isUnsubscribed() {\n        return subscriptions.isUnsubscribed();\n    }\n\n    public void onStart() {\n    }\n    \n    ...\n}\n```\n\n```java\npublic interface Subscription {\n    void unsubscribe();\n    boolean isUnsubscribed();\n}\n```\n\n`Subscriber`实现了`Subscription`接口，从而对外提供`isUnsubscribed()`和`unsubscribe()`方法。前者用于判断是否已经取消订阅；后者用于将订阅事件列表(*也就是当前观察者的成员变量`subscriptions`*)中的所有`Subscription`取消订阅，并且不再接受观察者`Observable`发送的后续事件。\n\n### 3、subscribe()源码分析\n前面我们分析了观察者和被观察者相关的源码，那么接下来便是整个订阅流程中最最关键的环节了。\n\n```java\npublic final Subscription subscribe(Subscriber<? super T> subscriber) {\n    return Observable.subscribe(subscriber, this);\n}\n```\n\n```java\nstatic <T> Subscription subscribe(Subscriber<? super T> subscriber, Observable<T> observable) {\n\n\t...\n\n    subscriber.onStart();\n    \n    if (!(subscriber instanceof SafeSubscriber)) {\n        subscriber = new SafeSubscriber<T>(subscriber);\n    }\n\n    try {\n        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);\n\n        return RxJavaHooks.onObservableReturn(subscriber);\n    } catch (Throwable e) {\n        ...\n        return Subscriptions.unsubscribed();\n    }\n}\n```\n\n`subscribe()`方法中将传进来的`subscriber`包装成了`SafeSubscriber`，`SafeSubscriber`其实是`subscriber`的一个代理，对`subscriber`的一系列方法做了更加严格的安全校验。保证了`onCompleted()`和`onError()`只会有一个被执行且只执行一次，一旦它们其中方法被执行过后`onNext()`就不在执行了。\n\n上述代码中最关键的就是`RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber)`。这里的RxJavaHooks和之前提到的一样，`RxJavaHooks.onObservableStart(observable, observable.onSubscribe)`返回的正是他的第二个入参`observable.onSubscribe`，也就是当前`observable`的成员变量`onSubscribe`。而这个成员变量我们前面提到过，它是我们在`Observable.create()`的时候new出来的。所以这段代码可以简化为`onSubscribe.call(subscriber)`。这也印证了我在[RxJava系列2(基本概念及使用介绍)](http://www.jianshu.com/p/ba61c047c230)中说的，`onSubscribe.call(subscriber)`中的`subscriber`正是我们在`subscribe()`方法中new出来的观察者。\n\n到这里，我们对RxJava的执行流程做个总结：首先我们调用`crate()`创建一个观察者，同时创建一个`OnSubscribe`作为该方法的入参；接着调用`subscribe()`来订阅我们自己创建的观察者`Subscriber`。\n一旦调用`subscribe()`方法后就会触发执行`OnSubscribe.call()`。然后我们就可以在call方法调用观察者`subscriber`的`onNext()`,`onCompleted()`,`onError()`。\n\n最后我用张图来总结下之前的分析结果：\n\n![RxJava基本流程分析](http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess1.jpg)\n\n## 二、操作符原理分析\n之前我们介绍过几十个操作符，要一一分析它们的源码显然不太现实。在这里我抛砖引玉，选取一个相对简单且常用的`map`操作符来分析。\n\n我们先来看一个`map`操作符的简单应用：\n\n**示例B**\n\n```java\nObservable.create(new Observable.OnSubscribe<Integer>() {\n    @Override\n    public void call(Subscriber<? super Integer> subscriber) {\n        subscriber.onNext(1);\n        subscriber.onCompleted();\n    }\n}).map(new Func1<Integer, String>() {\n    @Override\n    public String call(Integer integer) {\n        return \"This is \" + integer;\n    }\n}).subscribe(new Subscriber<String>() {\n    @Override\n    public void onCompleted() {\n        System.out.println(\"onCompleted!\");\n    }\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(e.getMessage());\n    }\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n});\n```\n\n为了便于表述，我将上面的代码做了如下拆解：\n\n```java\nObservable<Integer> observableA = Observable.create(new Observable.OnSubscribe<Integer>() {\n    @Override\n    public void call(Subscriber<? super Integer> subscriber) {\n        subscriber.onNext(1);\n        subscriber.onCompleted();\n    }\n});\n\nSubscriber<String> subscriberOne = new Subscriber<String>() {\n    @Override\n    public void onCompleted() {\n        System.out.println(\"onCompleted!\");\n    }\n    @Override\n    public void onError(Throwable e) {\n        System.out.println(e.getMessage());\n    }\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n};\n\nObservable<String> observableB = \n        observableA.map(new Func1<Integer, String>() {\n                @Override\n                public String call(Integer integer) {\n                    return \"This is \" + integer;;\n                }\n            });\n\nobservableB.subscribe(subscriberOne);\n```\n\n`map()`的源码和上一小节介绍的`create()`一样位于`Observable`这个类中。\n\n```java\npublic final <R> Observable<R> map(Func1<? super T, ? extends R> func) {\n    return create(new OnSubscribeMap<T, R>(this, func));\n}\n```\n\n通过查看源码我们发现调用`map()`的时候实际上是创建了一个新的被观察者`Observable`，我们姑且称它为`ObservableB`；一开始通过`Observable.create()`创建的`Observable`我们称之为`ObservableA`。在创建`ObservableB`的时候同时创建了一个`OnSubscribeMap`，而`ObservableA`和变换函数`Func1`则作为构造`OnSubscribeMap`的参数。\n\n\n```java\npublic final class OnSubscribeMap<T, R> implements OnSubscribe<R> {\n\n    final Observable<T> source;//ObservableA\n    \n    final Func1<? super T, ? extends R> transformer;//map操作符中的转换函数Func1。T为转换前的数据类型，在上面的例子中为Integer；R为转换后的数据类型，在该例中为String。\n\n    public OnSubscribeMap(Observable<T> source, Func1<? super T, ? extends R> transformer) {\n        this.source = source;\n        this.transformer = transformer;\n    }\n    \n    @Override\n    public void call(final Subscriber<? super R> o) {//结合第一小节的分析结果，我们知道这里的入参o其实就是我们自己new的观察者subscriberOne。\n        MapSubscriber<T, R> parent = new MapSubscriber<T, R>(o, transformer);\n        o.add(parent);\n        source.unsafeSubscribe(parent);\n    }\n    \n    static final class MapSubscriber<T, R> extends Subscriber<T> {\n        \n        final Subscriber<? super R> actual;//这里的actual就是我们在调用subscribe()时创建的观察者mSubscriber\n        final Func1<? super T, ? extends R> mapper;//变换函数\n        boolean done;\n        \n        public MapSubscriber(Subscriber<? super R> actual, Func1<? super T, ? extends R> mapper) {\n            this.actual = actual;\n            this.mapper = mapper;\n        }\n        \n        @Override\n        public void onNext(T t) {\n            R result;\n            try {\n                result = mapper.call(t);\n            } catch (Throwable ex) {\n                Exceptions.throwIfFatal(ex);\n                unsubscribe();\n                onError(OnErrorThrowable.addValueAsLastCause(ex, t));\n                return;\n            }\n            actual.onNext(result);\n        }\n        \n        @Override\n        public void onError(Throwable e) {\n            ...\n            actual.onError(e);\n        }\n        \n        @Override\n        public void onCompleted() {\n            ...\n            actual.onCompleted();\n        }\n        \n        @Override\n        public void setProducer(Producer p) {\n            actual.setProducer(p);\n        }\n    }\n}\n```\n\n`OnSubscribeMap`实现了`OnSubscribe`接口，因此`OnSubscribeMap`就是一个`OnSubscribe`。在调用`map()`的时候创建了一个新的被观察者`ObservableB`，然后我们用`ObservableB.subscribe(subscriberOne)`订阅了观察者`subscriberOne`。结合我们在第一小节的分析结果，所以`OnSubscribeMap.call(o)`中的`o`就是`subscribe(subscriberOne)`中的`subscriberOne`；一旦调用了`ObservableB.subscribe(subscriberOne)`就会执行`OnSubscribeMap.call()`。\n\n在`call()`方法中，首先通过我们的观察者`o`和转换函数`transformer`构造了一个`MapSubscriber`，最后调用了`source`也就是`observableA`的`unsafeSubscribe()`方法。即`observableA`订阅了一个观察者`MapSubscriber`。\n\n```java\npublic final Subscription unsafeSubscribe(Subscriber<? super T> subscriber) {\n    try {\n        ...\n        RxJavaHooks.onObservableStart(this, onSubscribe).call(subscriber);\n        return RxJavaHooks.onObservableReturn(subscriber);\n    } catch (Throwable e) {\n        ...\n        return Subscriptions.unsubscribed();\n    }\n}\n```\n上面这段代码最终执行了`onSubscribe`也就是`OnSubscribeMap`的`call()`方法，`call()`方法中的参数就是之前在`OnSubscribeMap.call()`中new出来的`MapSubscriber`。最后在`call()`方法中执行了我们自己的业务代码：\n\n```java\nsubscriber.onNext(1);\nsubscriber.onCompleted();\n```\n\n其实也就是执行了`MapSubscriber`的`onNext()`和`onCompleted()`。\n\n```java\n@Override\npublic void onNext(T t) {\n    R result;\n    try {\n        result = mapper.call(t);\n    } catch (Throwable ex) {\n        ...\n        return;\n    }\n    actual.onNext(result);\n}\n```\n\n`onNext(T t)`方法中的的`mapper`就是变换函数，`actual`就是我们在调用`subscribe()`时创建的观察者`subscriberOne`。这个`T`就是我们例子中的`Integer`，`R`就是`String`。在`onNext()`中首先调用变换函数`mapper.call()`将`T`转换成`R`(在我们的例子中就是将`Integer`类型的**1**转换成了`String`类型的**“This is 1”**)；接着调用`subscriberOne.onNext(String result)`。同样在调用`MapSubscriber.onCompleted()`时会执行`subscriberOne.onCompleted()`。这样就完成了一直完成的调用流程。\n\n我承认太啰嗦了，花费了这么大的篇幅才将`map()`的转换原理解释清楚。我也是希望尽量的将每个细节都呈现出来方便大家理解，如果看我啰嗦了这么久还是没能理解，请看下面我画的这张执行流程图。\n\n![加入Map操作符后的执行流程](http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess3.jpg)\n\n## 三、线程调度原理分析\n在前面的文章中我介绍过RxJava可以很方便的通过`subscribeOn()`和`observeOn()`来指定数据流的每一部分运行在哪个线程。其中`subscribeOn()`指定了处理`Observable`的全部的过程(包括发射数据和通知)的线程；`observeOn()`指定了观察者的`onNext()`, `onError()`和`onCompleted()`执行的线程。接下来我们就分析分析源码，看看线程调度是如何实现的。\n\n在分析源码前我们先看看一段常见的通过RxJava实现的线程调度代码：\n\n**示例C**\n\n```java\nObservable.create(new Observable.OnSubscribe<String>() {\n    @Override\n    public void call(Subscriber<? super String> subscriber) {\n        subscriber.onNext(\"Hello RxJava!\");\n        subscriber.onCompleted();\n    }\n}).subscribeOn(Schedulers.io())\n.observeOn(AndroidSchedulers.mainThread())\n.subscribe(new Subscriber<String>() {\n    @Override\n    public void onCompleted() {\n        System.out.println(\"completed!\");\n    }\n    @Override\n    public void onError(Throwable e) {\n    }\n    @Override\n    public void onNext(String s) {\n        System.out.println(s);\n    }\n});\n```\n\n### 1、subscribeOn()源码分析\n\n```java\npublic final Observable<T> subscribeOn(Scheduler scheduler) {\n    ...\n    return create(new OperatorSubscribeOn<T>(this, scheduler));\n}\n```\n\n通过上面的代码我们可以看到，`subscribeOn()`和`map()`一样是创建了一个新的被观察者`Observable`。因此我大致就能猜到`subscribeOn()`的执行流程应该和`map()`差不多，`OperatorSubscribeOn`肯定也是一个`OnSubscribe`。那我们接下来就看看`OperatorSubscribeOn`的源码：\n\n```java\npublic final class OperatorSubscribeOn<T> implements OnSubscribe<T> {\n\n    final Scheduler scheduler;//线程调度器，用来指定订阅事件发送、处理等所在的线程\n    final Observable<T> source;\n\n    public OperatorSubscribeOn(Observable<T> source, Scheduler scheduler) {\n        this.scheduler = scheduler;\n        this.source = source;\n    }\n\n    @Override\n    public void call(final Subscriber<? super T> subscriber) {\n        final Worker inner = scheduler.createWorker();\n        subscriber.add(inner);\n        \n        inner.schedule(new Action0() {\n            @Override\n            public void call() {\n                final Thread t = Thread.currentThread();\n                \n                Subscriber<T> s = new Subscriber<T>(subscriber) {\n                    @Override\n                    public void onNext(T t) {\n                        subscriber.onNext(t);\n                    }\n                    \n                    @Override\n                    public void onError(Throwable e) {\n                        try {\n                            subscriber.onError(e);\n                        } finally {\n                            inner.unsubscribe();\n                        }\n                    }\n                    \n                    @Override\n                    public void onCompleted() {\n                        try {\n                            subscriber.onCompleted();\n                        } finally {\n                            inner.unsubscribe();\n                        }\n                    }\n                    \n                    @Override\n                    public void setProducer(final Producer p) {\n                        subscriber.setProducer(new Producer() {\n                            @Override\n                            public void request(final long n) {\n                                if (t == Thread.currentThread()) {\n                                    p.request(n);\n                                } else {\n                                    inner.schedule(new Action0() {\n                                        @Override\n                                        public void call() {\n                                            p.request(n);\n                                        }\n                                    });\n                                }\n                            }\n                        });\n                    }\n                };\n                source.unsafeSubscribe(s);\n            }\n        });\n    }\n}\n```\n\n`OperatorSubscribeOn`实现了`OnSubscribe`接口，`call()`中对`Subscriber`的处理也和`OperatorMap`对`Subscriber`的处理类似。首先通过`scheduler`构建了一个`Worker`；然后用传进来的`subscriber`构造了一个新的`Subscriber s`，并将`s`丢到`Worker.schedule()`中来处理；最后用原`Observable`去订阅观察者`s`。而这个`Worker`就是线程调度的关键！前面的例子中我们通过`subscribeOn(Schedulers.io())`指定了`Observable`发射处理事件以及通知观察者的一系列操作的执行线程，正是通过这个`Schedulers.io()`创建了我们前面提到的`Worker`。所以我们来看看`Schedulers.io()`的实现。\n\n首先通过`Schedulers.io()`获得了`ioScheduler`并返回，上面的`OperatorSubscribeOn`通过这个的`Scheduler`的`createWorker()`方法创建了我们前面提到的`Worker`。\n\n```java\npublic static Scheduler io() {\n    return RxJavaHooks.onIOScheduler(getInstance().ioScheduler);\n}\n```\n\n接着我们看看这个`ioScheduler`是怎么来的，下面的代码向我们展现了是如何在`Schedulers`的构造函数中通过`RxJavaSchedulersHook.createIoScheduler()`来初始化`ioScheduler`的。\n\n```java\nprivate Schedulers() {\n\n    ...\n\n    Scheduler io = hook.getIOScheduler();\n    if (io != null) {\n        ioScheduler = io;\n    } else {\n        ioScheduler = RxJavaSchedulersHook.createIoScheduler();\n    }\n\n    ...\n}\n```\n\n最终`RxJavaSchedulersHook.createIoScheduler()`返回了一个`CachedThreadScheduler`，并赋值给了`ioScheduler`。\n\n```java\npublic static Scheduler createIoScheduler() {\n    return createIoScheduler(new RxThreadFactory(\"RxIoScheduler-\"));\n}\n```\n\n```java\npublic static Scheduler createIoScheduler(ThreadFactory threadFactory) {\n    ...\n    return new CachedThreadScheduler(threadFactory);\n}\n```\n\n到这一步既然我们知道了`ioScheduler`就是一个`CachedThreadScheduler`，那我们就来看看它的`createWorker()`的实现。\n\n```java\npublic Worker createWorker() {\n    return new EventLoopWorker(pool.get());\n}\n```\n\n上面的代码向我们赤裸裸的呈现了前面`OperatorSubscribeOn`中的`Worker`其实就是`EventLoopWorker`。我们重点要关注的是他的`scheduleActual()`。\n\n```java\nstatic final class EventLoopWorker extends Scheduler.Worker implements Action0 {\n    private final CompositeSubscription innerSubscription = new CompositeSubscription();\n    private final CachedWorkerPool pool;\n    private final ThreadWorker threadWorker;\n    final AtomicBoolean once;\n\n    EventLoopWorker(CachedWorkerPool pool) {\n        this.pool = pool;\n        this.once = new AtomicBoolean();\n        this.threadWorker = pool.get();\n    }\n\n    ...\n\n    @Override\n    public Subscription schedule(final Action0 action, long delayTime, TimeUnit unit) {\n        ...\n        ScheduledAction s = threadWorker.scheduleActual(new Action0() {\n            @Override\n            public void call() {\n                if (isUnsubscribed()) {\n                    return;\n                }\n                action.call();\n            }\n        }, delayTime, unit);\n        innerSubscription.add(s);\n        s.addParent(innerSubscription);\n        return s;\n    }\n}\n```\n\n通过对源码的一步步追踪，我们知道了前面`OperatorSubscribeOn.call()`中的`inner.schedule()`最终会执行到`ThreadWorker`的`scheduleActual()`方法。\n\n```java\npublic ScheduledAction scheduleActual(final Action0 action, long delayTime, TimeUnit unit) {\n    Action0 decoratedAction = RxJavaHooks.onScheduledAction(action);\n    ScheduledAction run = new ScheduledAction(decoratedAction);\n    Future<?> f;\n    if (delayTime <= 0) {\n        f = executor.submit(run);\n    } else {\n        f = executor.schedule(run, delayTime, unit);\n    }\n    run.add(f);\n    return run;\n}\n```\n`scheduleActual()`中的`ScheduledAction`实现了`Runnable`接口，通过线程池`executor`最终实现了线程切换。上面便是`subscribeOn(Schedulers.io())`实现线程切换的全部过程。\n\n### 2、observeOn()源码分析\n\n`observeOn()`切换线程是通过`lift`来实现的，相比`subscribeOn()`在实现原理上相对复杂些。不过本质上最终还是创建了一个新的`Observable`。\n\n```java\npublic final Observable<T> observeOn(Scheduler scheduler, boolean delayError, int bufferSize) {\n    ...\n    return lift(new OperatorObserveOn<T>(scheduler, delayError, bufferSize));\n}\n\npublic final <R> Observable<R> lift(final Operator<? extends R, ? super T> operator) {\n    return create(new OnSubscribeLift<T, R>(onSubscribe, operator));\n}\n```\n\n`OperatorObserveOn`作为`OnSubscribeLift`构造函数的参数用来创建了一个新的`OnSubscribeLift`对象，接下来我们看看`OnSubscribeLift`的实现：\n\n```java\npublic final class OnSubscribeLift<T, R> implements OnSubscribe<R> {\n    \n    final OnSubscribe<T> parent;\n\n    final Operator<? extends R, ? super T> operator;\n\n    public OnSubscribeLift(OnSubscribe<T> parent, Operator<? extends R, ? super T> operator) {\n        this.parent = parent;\n        this.operator = operator;\n    }\n\n    @Override\n    public void call(Subscriber<? super R> o) {\n        try {\n            Subscriber<? super T> st = RxJavaHooks.onObservableLift(operator).call(o);\n            try {\n                st.onStart();\n                parent.call(st);\n            } catch (Throwable e) {\n                Exceptions.throwIfFatal(e);\n                st.onError(e);\n            }\n        } catch (Throwable e) {\n            Exceptions.throwIfFatal(e);\n            o.onError(e);\n        }\n    }\n}\n```\n\n`OnSubscribeLift`继承自`OnSubscribe`，通过前面的分析我们知道一旦调用了`subscribe()`将观察者与被观察绑定后就会触发被观察者所对应的`OnSubscribe`的`call()`方法，所以这里会触发`OnSubscribeLift.call()`。在`call()`中调用了`OperatorObserveOn.call()`并返回了一个新的观察者`Subscriber st`，接着调用了前一级`Observable`对应`OnSubscriber.call(st)`。\n\n我们再看看`OperatorObserveOn.call()`的实现：\n\n```java\npublic Subscriber<? super T> call(Subscriber<? super T> child) {\n    ...\n    ObserveOnSubscriber<T> parent = new ObserveOnSubscriber<T>(scheduler, child, delayError, bufferSize);\n    parent.init();\n    return parent;\n}\n```\n\n`OperatorObserveOn.call()`中创建了一个`ObserveOnSubscriber`并调用`init()`进行了初始化。\n\n```java\nstatic final class ObserveOnSubscriber<T> extends Subscriber<T> implements Action0 {\n\n    ...\n\n    @Override\n    public void onNext(final T t) {\n        ...\n        schedule();\n    }\n\n    @Override\n    public void onCompleted() {\n        ...\n        schedule();\n    }\n\n    @Override\n    public void onError(final Throwable e) {\n        ...\n        schedule();\n    }\n\n    protected void schedule() {\n        if (counter.getAndIncrement() == 0) {\n            recursiveScheduler.schedule(this);\n        }\n    }\n\n    @Override\n    public void call() {\n        long missed = 1L;\n        long currentEmission = emitted;\n\n        final Queue<Object> q = this.queue;\n        final Subscriber<? super T> localChild = this.child;\n        final NotificationLite<T> localOn = this.on;\n        \n        for (;;) {\n            long requestAmount = requested.get();\n            \n            while (requestAmount != currentEmission) {\n                boolean done = finished;\n                Object v = q.poll();\n                boolean empty = v == null;\n                \n                if (checkTerminated(done, empty, localChild, q)) {\n                    return;\n                }\n                \n                if (empty) {\n                    break;\n                }\n                \n                localChild.onNext(localOn.getValue(v));\n\n                currentEmission++;\n                if (currentEmission == limit) {\n                    requestAmount = BackpressureUtils.produced(requested, currentEmission);\n                    request(currentEmission);\n                    currentEmission = 0L;\n                }\n            }\n            \n            if (requestAmount == currentEmission) {\n                if (checkTerminated(finished, q.isEmpty(), localChild, q)) {\n                    return;\n                }\n            }\n\n            emitted = currentEmission;\n            missed = counter.addAndGet(-missed);\n            if (missed == 0L) {\n                break;\n            }\n        }\n    }\n    \n    ...\n}\n```\n\n`ObserveOnSubscriber`继承自`Subscriber`，并实现了`Action0`接口。我们看到`ObserveOnSubscriber`的`onNext()`、`onCompleted()`、`onError()`都有个`schedule()`，这个方法就是我们线程调度的关键；通过`schedule()`将新观察者`ObserveOnSubscriber`发送给`subscriberOne`的所有事件都切换到了`recursiveScheduler`所对应的线程，简单的说就是把`subscriberOne`的`onNext()`、`onCompleted()`、`onError()`方法丢到了`recursiveScheduler`对应的线程中来执行。\n\n那么`schedule()`又是如何做到这一点的呢？他内部调用了`recursiveScheduler.schedule(this)`，`recursiveScheduler`其实就是一个`Worker`，和我们在介绍`subscribeOn()`时提到的`worker`一样，执行`schedule()`实际上最终是创建了一个`runable`，然后把这个`runnable`丢到了特定的线程池中去执行。在`runnable`的`run()`方法中调用了`ObserveOnSubscriber.call()`，看上面的代码大家就会发现在`call()`方法中最终调用了`subscriberOne`的`onNext()`、`onCompleted()`、`onError()`方法。这便是它实现线程切换的原理。\n\n好了，我们最后再看看**示例C**对应的执行流程图，帮助大家加深理解。\n\n![RxJava执行流程](http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess.jpg)\n\n\n## 总结\n这一章以**执行流程**、**操作符实现**以及**线程调度**三个方面为切入点剖析了RxJava源码。下一章将站在更宏观的角度来分析整个RxJava的框架结构、设计思想等等。敬请期待~~ :)\n\n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)","slug":"RxJava系列6-从微观角度解读RxJava源码","published":1,"updated":"2017-02-05T17:58:57.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26f8000s6st6akjvbezq","content":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>  </li>\n</ul>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：</p>\n<ul>\n<li>RxJava基本流程分析</li>\n<li>操作符原理分析</li>\n<li>线程调度原理分析</li>\n</ul>\n<blockquote>\n<p>本章节基于<strong>RxJava1.1.9</strong>版本的源码</p>\n</blockquote>\n<h2 id=\"一、RxJava执行流程分析\"><a href=\"#一、RxJava执行流程分析\" class=\"headerlink\" title=\"一、RxJava执行流程分析\"></a>一、RxJava执行流程分析</h2><p>在<a href=\"http://www.jianshu.com/p/ba61c047c230\" target=\"_blank\" rel=\"external\">RxJava系列2(基本概念及使用介绍)</a>中我们介绍过，一个最基本的RxJava调用是这样的：</p>\n<p><strong>示例A</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hello RxJava!\"</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>首先调用<code>Observable.create()</code>创建一个被观察者<code>Observable</code>，同时创建一个<code>OnSubscribe</code>作为<code>create()</code>方法的入参；接着创建一个观察者<code>Subscriber</code>，然后通过<code>subseribe()</code>实现二者的订阅关系。这里涉及到三个关键对象和一个核心的方法：</p>\n<ul>\n<li><strong>Observable</strong>（被观察者）</li>\n<li><strong>OnSubscribe</strong> (从纯设计模式的角度来理解，<code>OnSubscribe.call()</code>可以看做是<a href=\"https://github.com/BaronZ88/Blog/blob/master/DesignPatterns/ObserverPattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md\" target=\"_blank\" rel=\"external\">观察者模式</a>中被观察者用来通知观察者的<code>notifyObservers()</code>方法)</li>\n<li><strong>Subscriber</strong> （观察者）</li>\n<li><strong>subscribe()</strong> （实现观察者与被观察者订阅关系的方法）</li>\n</ul>\n<h3 id=\"1、Observable-create-源码分析\"><a href=\"#1、Observable-create-源码分析\" class=\"headerlink\" title=\"1、Observable.create()源码分析\"></a>1、Observable.create()源码分析</h3><p>首先我们来看看<code>Observable.create()</code>的实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里创建了一个被观察者<code>Observable</code>，同时将<code>RxJavaHooks.onCreate(f)</code>作为构造函数的参数，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">Observable</span><span class=\"params\">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.onSubscribe = f;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到源码中直接将参数<code>RxJavaHooks.onCreate(f)</code>赋值给了当前我们构造的被观察者<code>Observable</code>的成员变量<code>onSubscribe</code>。那么<code>RxJavaHooks.onCreate(f)</code>返回的又是什么呢？我们接着往下看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Observable.<span class=\"function\">OnSubscribe&lt;T&gt; <span class=\"title\">onCreate</span><span class=\"params\">(Observable.OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</div><div class=\"line\">    Func1&lt;OnSubscribe, OnSubscribe&gt; f = onObservableCreate;</div><div class=\"line\">    <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> f.call(onSubscribe);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onSubscribe;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于我们并没调用<code>RxJavaHooks.initCreate()</code>，所以上面代码中的<code>onObservableCreate</code>为null；因此<code>RxJavaHooks.onCreate(f)</code>最终返回的就是<code>f</code>，也就是我们在<code>Observable.create()</code>的时候new出来的<code>OnSubscribe</code>。（<em>由于对RxJavaHooks的理解并不影响我们对RxJava执行流程的分析，因此在这里我们不做进一步的探讨。为了方便理解我们只需要知道RxJavaHooks一系列方法的返回值就是入参本身就OK了，例如这里的<code>RxJavaHooks.onCreate(f)</code>返回的就是<code>f</code></em>）。</p>\n<p>至此我们做下逻辑梳理：<strong><code>Observable.create()</code>方法构造了一个被观察者<code>Observable</code>对象，同时将new出来的<code>OnSubscribe</code>赋值给了该<code>Observable</code>的成员变量<code>onSubscribe</code>。</strong></p>\n<h3 id=\"2、Subscriber源码分析\"><a href=\"#2、Subscriber源码分析\" class=\"headerlink\" title=\"2、Subscriber源码分析\"></a>2、Subscriber源码分析</h3><p>接着我们看下观察者<code>Subscriber</code>的源码，为了增加可读性，我去掉了源码中的注释和部分代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Subscription</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SubscriptionList subscriptions;<span class=\"comment\">//订阅事件集，所有发送给当前Subscriber的事件都会保存在这里</span></div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">Subscriber</span><span class=\"params\">(Subscriber&lt;?&gt; subscriber, <span class=\"keyword\">boolean</span> shareSubscriptions)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subscriber = subscriber;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subscriptions = shareSubscriptions &amp;&amp; subscriber != <span class=\"keyword\">null</span> ? subscriber.subscriptions : <span class=\"keyword\">new</span> SubscriptionList();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">unsubscribe</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        subscriptions.unsubscribe();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isUnsubscribed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> subscriptions.isUnsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscription</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unsubscribe</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isUnsubscribed</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Subscriber</code>实现了<code>Subscription</code>接口，从而对外提供<code>isUnsubscribed()</code>和<code>unsubscribe()</code>方法。前者用于判断是否已经取消订阅；后者用于将订阅事件列表(<em>也就是当前观察者的成员变量<code>subscriptions</code></em>)中的所有<code>Subscription</code>取消订阅，并且不再接受观察者<code>Observable</code>发送的后续事件。</p>\n<h3 id=\"3、subscribe-源码分析\"><a href=\"#3、subscribe-源码分析\" class=\"headerlink\" title=\"3、subscribe()源码分析\"></a>3、subscribe()源码分析</h3><p>前面我们分析了观察者和被观察者相关的源码，那么接下来便是整个订阅流程中最最关键的环节了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Observable.subscribe(subscriber, <span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t...</div><div class=\"line\"></div><div class=\"line\">    subscriber.onStart();</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!(subscriber <span class=\"keyword\">instanceof</span> SafeSubscriber)) &#123;</div><div class=\"line\">        subscriber = <span class=\"keyword\">new</span> SafeSubscriber&lt;T&gt;(subscriber);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">return</span> Subscriptions.unsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>subscribe()</code>方法中将传进来的<code>subscriber</code>包装成了<code>SafeSubscriber</code>，<code>SafeSubscriber</code>其实是<code>subscriber</code>的一个代理，对<code>subscriber</code>的一系列方法做了更加严格的安全校验。保证了<code>onCompleted()</code>和<code>onError()</code>只会有一个被执行且只执行一次，一旦它们其中方法被执行过后<code>onNext()</code>就不在执行了。</p>\n<p>上述代码中最关键的就是<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber)</code>。这里的RxJavaHooks和之前提到的一样，<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe)</code>返回的正是他的第二个入参<code>observable.onSubscribe</code>，也就是当前<code>observable</code>的成员变量<code>onSubscribe</code>。而这个成员变量我们前面提到过，它是我们在<code>Observable.create()</code>的时候new出来的。所以这段代码可以简化为<code>onSubscribe.call(subscriber)</code>。这也印证了我在<a href=\"http://www.jianshu.com/p/ba61c047c230\" target=\"_blank\" rel=\"external\">RxJava系列2(基本概念及使用介绍)</a>中说的，<code>onSubscribe.call(subscriber)</code>中的<code>subscriber</code>正是我们在<code>subscribe()</code>方法中new出来的观察者。</p>\n<p>到这里，我们对RxJava的执行流程做个总结：首先我们调用<code>crate()</code>创建一个观察者，同时创建一个<code>OnSubscribe</code>作为该方法的入参；接着调用<code>subscribe()</code>来订阅我们自己创建的观察者<code>Subscriber</code>。<br>一旦调用<code>subscribe()</code>方法后就会触发执行<code>OnSubscribe.call()</code>。然后我们就可以在call方法调用观察者<code>subscriber</code>的<code>onNext()</code>,<code>onCompleted()</code>,<code>onError()</code>。</p>\n<p>最后我用张图来总结下之前的分析结果：</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess1.jpg\" alt=\"RxJava基本流程分析\"></p>\n<h2 id=\"二、操作符原理分析\"><a href=\"#二、操作符原理分析\" class=\"headerlink\" title=\"二、操作符原理分析\"></a>二、操作符原理分析</h2><p>之前我们介绍过几十个操作符，要一一分析它们的源码显然不太现实。在这里我抛砖引玉，选取一个相对简单且常用的<code>map</code>操作符来分析。</p>\n<p>我们先来看一个<code>map</code>操作符的简单应用：</p>\n<p><strong>示例B</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"number\">1</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).map(<span class=\"keyword\">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"This is \"</span> + integer;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"onCompleted!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>为了便于表述，我将上面的代码做了如下拆解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Integer&gt; observableA = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"number\">1</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">Subscriber&lt;String&gt; subscriberOne = <span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"onCompleted!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Observable&lt;String&gt; observableB = </div><div class=\"line\">        observableA.map(<span class=\"keyword\">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">\"This is \"</span> + integer;;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">observableB.subscribe(subscriberOne);</div></pre></td></tr></table></figure>\n<p><code>map()</code>的源码和上一小节介绍的<code>create()</code>一样位于<code>Observable</code>这个类中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; func)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> OnSubscribeMap&lt;T, R&gt;(<span class=\"keyword\">this</span>, func));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过查看源码我们发现调用<code>map()</code>的时候实际上是创建了一个新的被观察者<code>Observable</code>，我们姑且称它为<code>ObservableB</code>；一开始通过<code>Observable.create()</code>创建的<code>Observable</code>我们称之为<code>ObservableA</code>。在创建<code>ObservableB</code>的时候同时创建了一个<code>OnSubscribeMap</code>，而<code>ObservableA</code>和变换函数<code>Func1</code>则作为构造<code>OnSubscribeMap</code>的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnSubscribeMap</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">OnSubscribe</span>&lt;<span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Observable&lt;T&gt; source;<span class=\"comment\">//ObservableA</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">final</span> Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; transformer;<span class=\"comment\">//map操作符中的转换函数Func1。T为转换前的数据类型，在上面的例子中为Integer；R为转换后的数据类型，在该例中为String。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OnSubscribeMap</span><span class=\"params\">(Observable&lt;T&gt; source, Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.source = source;</div><div class=\"line\">        <span class=\"keyword\">this</span>.transformer = transformer;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(<span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; o)</span> </span>&#123;<span class=\"comment\">//结合第一小节的分析结果，我们知道这里的入参o其实就是我们自己new的观察者subscriberOne。</span></div><div class=\"line\">        MapSubscriber&lt;T, R&gt; parent = <span class=\"keyword\">new</span> MapSubscriber&lt;T, R&gt;(o, transformer);</div><div class=\"line\">        o.add(parent);</div><div class=\"line\">        source.unsafeSubscribe(parent);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapSubscriber</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; actual;<span class=\"comment\">//这里的actual就是我们在调用subscribe()时创建的观察者mSubscriber</span></div><div class=\"line\">        <span class=\"keyword\">final</span> Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper;<span class=\"comment\">//变换函数</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> done;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapSubscriber</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; actual, Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.actual = actual;</div><div class=\"line\">            <span class=\"keyword\">this</span>.mapper = mapper;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">            R result;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                result = mapper.call(t);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">                Exceptions.throwIfFatal(ex);</div><div class=\"line\">                unsubscribe();</div><div class=\"line\">                onError(OnErrorThrowable.addValueAsLastCause(ex, t));</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            actual.onNext(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            ...</div><div class=\"line\">            actual.onError(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            ...</div><div class=\"line\">            actual.onCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setProducer</span><span class=\"params\">(Producer p)</span> </span>&#123;</div><div class=\"line\">            actual.setProducer(p);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OnSubscribeMap</code>实现了<code>OnSubscribe</code>接口，因此<code>OnSubscribeMap</code>就是一个<code>OnSubscribe</code>。在调用<code>map()</code>的时候创建了一个新的被观察者<code>ObservableB</code>，然后我们用<code>ObservableB.subscribe(subscriberOne)</code>订阅了观察者<code>subscriberOne</code>。结合我们在第一小节的分析结果，所以<code>OnSubscribeMap.call(o)</code>中的<code>o</code>就是<code>subscribe(subscriberOne)</code>中的<code>subscriberOne</code>；一旦调用了<code>ObservableB.subscribe(subscriberOne)</code>就会执行<code>OnSubscribeMap.call()</code>。</p>\n<p>在<code>call()</code>方法中，首先通过我们的观察者<code>o</code>和转换函数<code>transformer</code>构造了一个<code>MapSubscriber</code>，最后调用了<code>source</code>也就是<code>observableA</code>的<code>unsafeSubscribe()</code>方法。即<code>observableA</code>订阅了一个观察者<code>MapSubscriber</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">unsafeSubscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        RxJavaHooks.onObservableStart(<span class=\"keyword\">this</span>, onSubscribe).call(subscriber);</div><div class=\"line\">        <span class=\"keyword\">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">return</span> Subscriptions.unsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这段代码最终执行了<code>onSubscribe</code>也就是<code>OnSubscribeMap</code>的<code>call()</code>方法，<code>call()</code>方法中的参数就是之前在<code>OnSubscribeMap.call()</code>中new出来的<code>MapSubscriber</code>。最后在<code>call()</code>方法中执行了我们自己的业务代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">subscriber.onNext(<span class=\"number\">1</span>);</div><div class=\"line\">subscriber.onCompleted();</div></pre></td></tr></table></figure>\n<p>其实也就是执行了<code>MapSubscriber</code>的<code>onNext()</code>和<code>onCompleted()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">    R result;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        result = mapper.call(t);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    actual.onNext(result);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>onNext(T t)</code>方法中的的<code>mapper</code>就是变换函数，<code>actual</code>就是我们在调用<code>subscribe()</code>时创建的观察者<code>subscriberOne</code>。这个<code>T</code>就是我们例子中的<code>Integer</code>，<code>R</code>就是<code>String</code>。在<code>onNext()</code>中首先调用变换函数<code>mapper.call()</code>将<code>T</code>转换成<code>R</code>(在我们的例子中就是将<code>Integer</code>类型的<strong>1</strong>转换成了<code>String</code>类型的<strong>“This is 1”</strong>)；接着调用<code>subscriberOne.onNext(String result)</code>。同样在调用<code>MapSubscriber.onCompleted()</code>时会执行<code>subscriberOne.onCompleted()</code>。这样就完成了一直完成的调用流程。</p>\n<p>我承认太啰嗦了，花费了这么大的篇幅才将<code>map()</code>的转换原理解释清楚。我也是希望尽量的将每个细节都呈现出来方便大家理解，如果看我啰嗦了这么久还是没能理解，请看下面我画的这张执行流程图。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess3.jpg\" alt=\"加入Map操作符后的执行流程\"></p>\n<h2 id=\"三、线程调度原理分析\"><a href=\"#三、线程调度原理分析\" class=\"headerlink\" title=\"三、线程调度原理分析\"></a>三、线程调度原理分析</h2><p>在前面的文章中我介绍过RxJava可以很方便的通过<code>subscribeOn()</code>和<code>observeOn()</code>来指定数据流的每一部分运行在哪个线程。其中<code>subscribeOn()</code>指定了处理<code>Observable</code>的全部的过程(包括发射数据和通知)的线程；<code>observeOn()</code>指定了观察者的<code>onNext()</code>, <code>onError()</code>和<code>onCompleted()</code>执行的线程。接下来我们就分析分析源码，看看线程调度是如何实现的。</p>\n<p>在分析源码前我们先看看一段常见的通过RxJava实现的线程调度代码：</p>\n<p><strong>示例C</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hello RxJava!\"</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribeOn(Schedulers.io())</div><div class=\"line\">.observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">.subscribe(<span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"1、subscribeOn-源码分析\"><a href=\"#1、subscribeOn-源码分析\" class=\"headerlink\" title=\"1、subscribeOn()源码分析\"></a>1、subscribeOn()源码分析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Observable&lt;T&gt; <span class=\"title\">subscribeOn</span><span class=\"params\">(Scheduler scheduler)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> OperatorSubscribeOn&lt;T&gt;(<span class=\"keyword\">this</span>, scheduler));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的代码我们可以看到，<code>subscribeOn()</code>和<code>map()</code>一样是创建了一个新的被观察者<code>Observable</code>。因此我大致就能猜到<code>subscribeOn()</code>的执行流程应该和<code>map()</code>差不多，<code>OperatorSubscribeOn</code>肯定也是一个<code>OnSubscribe</code>。那我们接下来就看看<code>OperatorSubscribeOn</code>的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OperatorSubscribeOn</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">OnSubscribe</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Scheduler scheduler;<span class=\"comment\">//线程调度器，用来指定订阅事件发送、处理等所在的线程</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Observable&lt;T&gt; source;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OperatorSubscribeOn</span><span class=\"params\">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.scheduler = scheduler;</div><div class=\"line\">        <span class=\"keyword\">this</span>.source = source;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(<span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> Worker inner = scheduler.createWorker();</div><div class=\"line\">        subscriber.add(inner);</div><div class=\"line\">        </div><div class=\"line\">        inner.schedule(<span class=\"keyword\">new</span> Action0() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">final</span> Thread t = Thread.currentThread();</div><div class=\"line\">                </div><div class=\"line\">                Subscriber&lt;T&gt; s = <span class=\"keyword\">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">                        subscriber.onNext(t);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    </div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                            subscriber.onError(e);</div><div class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                            inner.unsubscribe();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    </div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                            subscriber.onCompleted();</div><div class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                            inner.unsubscribe();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    </div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setProducer</span><span class=\"params\">(<span class=\"keyword\">final</span> Producer p)</span> </span>&#123;</div><div class=\"line\">                        subscriber.setProducer(<span class=\"keyword\">new</span> Producer() &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> n)</span> </span>&#123;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (t == Thread.currentThread()) &#123;</div><div class=\"line\">                                    p.request(n);</div><div class=\"line\">                                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                                    inner.schedule(<span class=\"keyword\">new</span> Action0() &#123;</div><div class=\"line\">                                        <span class=\"meta\">@Override</span></div><div class=\"line\">                                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                                            p.request(n);</div><div class=\"line\">                                        &#125;</div><div class=\"line\">                                    &#125;);</div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">                source.unsafeSubscribe(s);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OperatorSubscribeOn</code>实现了<code>OnSubscribe</code>接口，<code>call()</code>中对<code>Subscriber</code>的处理也和<code>OperatorMap</code>对<code>Subscriber</code>的处理类似。首先通过<code>scheduler</code>构建了一个<code>Worker</code>；然后用传进来的<code>subscriber</code>构造了一个新的<code>Subscriber s</code>，并将<code>s</code>丢到<code>Worker.schedule()</code>中来处理；最后用原<code>Observable</code>去订阅观察者<code>s</code>。而这个<code>Worker</code>就是线程调度的关键！前面的例子中我们通过<code>subscribeOn(Schedulers.io())</code>指定了<code>Observable</code>发射处理事件以及通知观察者的一系列操作的执行线程，正是通过这个<code>Schedulers.io()</code>创建了我们前面提到的<code>Worker</code>。所以我们来看看<code>Schedulers.io()</code>的实现。</p>\n<p>首先通过<code>Schedulers.io()</code>获得了<code>ioScheduler</code>并返回，上面的<code>OperatorSubscribeOn</code>通过这个的<code>Scheduler</code>的<code>createWorker()</code>方法创建了我们前面提到的<code>Worker</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Scheduler <span class=\"title\">io</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> RxJavaHooks.onIOScheduler(getInstance().ioScheduler);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着我们看看这个<code>ioScheduler</code>是怎么来的，下面的代码向我们展现了是如何在<code>Schedulers</code>的构造函数中通过<code>RxJavaSchedulersHook.createIoScheduler()</code>来初始化<code>ioScheduler</code>的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Schedulers</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    Scheduler io = hook.getIOScheduler();</div><div class=\"line\">    <span class=\"keyword\">if</span> (io != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ioScheduler = io;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        ioScheduler = RxJavaSchedulersHook.createIoScheduler();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最终<code>RxJavaSchedulersHook.createIoScheduler()</code>返回了一个<code>CachedThreadScheduler</code>，并赋值给了<code>ioScheduler</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Scheduler <span class=\"title\">createIoScheduler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> createIoScheduler(<span class=\"keyword\">new</span> RxThreadFactory(<span class=\"string\">\"RxIoScheduler-\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Scheduler <span class=\"title\">createIoScheduler</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CachedThreadScheduler(threadFactory);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这一步既然我们知道了<code>ioScheduler</code>就是一个<code>CachedThreadScheduler</code>，那我们就来看看它的<code>createWorker()</code>的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Worker <span class=\"title\">createWorker</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EventLoopWorker(pool.get());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码向我们赤裸裸的呈现了前面<code>OperatorSubscribeOn</code>中的<code>Worker</code>其实就是<code>EventLoopWorker</code>。我们重点要关注的是他的<code>scheduleActual()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventLoopWorker</span> <span class=\"keyword\">extends</span> <span class=\"title\">Scheduler</span>.<span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Action0</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CompositeSubscription innerSubscription = <span class=\"keyword\">new</span> CompositeSubscription();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CachedWorkerPool pool;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadWorker threadWorker;</div><div class=\"line\">    <span class=\"keyword\">final</span> AtomicBoolean once;</div><div class=\"line\"></div><div class=\"line\">    EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.pool = pool;</div><div class=\"line\">        <span class=\"keyword\">this</span>.once = <span class=\"keyword\">new</span> AtomicBoolean();</div><div class=\"line\">        <span class=\"keyword\">this</span>.threadWorker = pool.get();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Subscription <span class=\"title\">schedule</span><span class=\"params\">(<span class=\"keyword\">final</span> Action0 action, <span class=\"keyword\">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        ScheduledAction s = threadWorker.scheduleActual(<span class=\"keyword\">new</span> Action0() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (isUnsubscribed()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                action.call();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, delayTime, unit);</div><div class=\"line\">        innerSubscription.add(s);</div><div class=\"line\">        s.addParent(innerSubscription);</div><div class=\"line\">        <span class=\"keyword\">return</span> s;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过对源码的一步步追踪，我们知道了前面<code>OperatorSubscribeOn.call()</code>中的<code>inner.schedule()</code>最终会执行到<code>ThreadWorker</code>的<code>scheduleActual()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ScheduledAction <span class=\"title\">scheduleActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Action0 action, <span class=\"keyword\">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">    Action0 decoratedAction = RxJavaHooks.onScheduledAction(action);</div><div class=\"line\">    ScheduledAction run = <span class=\"keyword\">new</span> ScheduledAction(decoratedAction);</div><div class=\"line\">    Future&lt;?&gt; f;</div><div class=\"line\">    <span class=\"keyword\">if</span> (delayTime &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        f = executor.submit(run);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        f = executor.schedule(run, delayTime, unit);</div><div class=\"line\">    &#125;</div><div class=\"line\">    run.add(f);</div><div class=\"line\">    <span class=\"keyword\">return</span> run;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>scheduleActual()</code>中的<code>ScheduledAction</code>实现了<code>Runnable</code>接口，通过线程池<code>executor</code>最终实现了线程切换。上面便是<code>subscribeOn(Schedulers.io())</code>实现线程切换的全部过程。</p>\n<h3 id=\"2、observeOn-源码分析\"><a href=\"#2、observeOn-源码分析\" class=\"headerlink\" title=\"2、observeOn()源码分析\"></a>2、observeOn()源码分析</h3><p><code>observeOn()</code>切换线程是通过<code>lift</code>来实现的，相比<code>subscribeOn()</code>在实现原理上相对复杂些。不过本质上最终还是创建了一个新的<code>Observable</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Observable&lt;T&gt; <span class=\"title\">observeOn</span><span class=\"params\">(Scheduler scheduler, <span class=\"keyword\">boolean</span> delayError, <span class=\"keyword\">int</span> bufferSize)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">return</span> lift(<span class=\"keyword\">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">lift</span><span class=\"params\">(<span class=\"keyword\">final</span> Operator&lt;? extends R, ? <span class=\"keyword\">super</span> T&gt; operator)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OperatorObserveOn</code>作为<code>OnSubscribeLift</code>构造函数的参数用来创建了一个新的<code>OnSubscribeLift</code>对象，接下来我们看看<code>OnSubscribeLift</code>的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnSubscribeLift</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">OnSubscribe</span>&lt;<span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">final</span> OnSubscribe&lt;T&gt; parent;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Operator&lt;? extends R, ? <span class=\"keyword\">super</span> T&gt; operator;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OnSubscribeLift</span><span class=\"params\">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class=\"keyword\">super</span> T&gt; operator)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.parent = parent;</div><div class=\"line\">        <span class=\"keyword\">this</span>.operator = operator;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; st = RxJavaHooks.onObservableLift(operator).call(o);</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                st.onStart();</div><div class=\"line\">                parent.call(st);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">                Exceptions.throwIfFatal(e);</div><div class=\"line\">                st.onError(e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">            Exceptions.throwIfFatal(e);</div><div class=\"line\">            o.onError(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OnSubscribeLift</code>继承自<code>OnSubscribe</code>，通过前面的分析我们知道一旦调用了<code>subscribe()</code>将观察者与被观察绑定后就会触发被观察者所对应的<code>OnSubscribe</code>的<code>call()</code>方法，所以这里会触发<code>OnSubscribeLift.call()</code>。在<code>call()</code>中调用了<code>OperatorObserveOn.call()</code>并返回了一个新的观察者<code>Subscriber st</code>，接着调用了前一级<code>Observable</code>对应<code>OnSubscriber.call(st)</code>。</p>\n<p>我们再看看<code>OperatorObserveOn.call()</code>的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; call(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; child) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    ObserveOnSubscriber&lt;T&gt; parent = <span class=\"keyword\">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class=\"line\">    parent.init();</div><div class=\"line\">    <span class=\"keyword\">return</span> parent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OperatorObserveOn.call()</code>中创建了一个<code>ObserveOnSubscriber</code>并调用<code>init()</code>进行了初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserveOnSubscriber</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Action0</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(<span class=\"keyword\">final</span> T t)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        schedule();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        schedule();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(<span class=\"keyword\">final</span> Throwable e)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        schedule();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (counter.getAndIncrement() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            recursiveScheduler.schedule(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> missed = <span class=\"number\">1L</span>;</div><div class=\"line\">        <span class=\"keyword\">long</span> currentEmission = emitted;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">final</span> Queue&lt;Object&gt; q = <span class=\"keyword\">this</span>.queue;</div><div class=\"line\">        <span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; localChild = <span class=\"keyword\">this</span>.child;</div><div class=\"line\">        <span class=\"keyword\">final</span> NotificationLite&lt;T&gt; localOn = <span class=\"keyword\">this</span>.on;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> requestAmount = requested.get();</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">while</span> (requestAmount != currentEmission) &#123;</div><div class=\"line\">                <span class=\"keyword\">boolean</span> done = finished;</div><div class=\"line\">                Object v = q.poll();</div><div class=\"line\">                <span class=\"keyword\">boolean</span> empty = v == <span class=\"keyword\">null</span>;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"keyword\">if</span> (checkTerminated(done, empty, localChild, q)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"keyword\">if</span> (empty) &#123;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">                localChild.onNext(localOn.getValue(v));</div><div class=\"line\"></div><div class=\"line\">                currentEmission++;</div><div class=\"line\">                <span class=\"keyword\">if</span> (currentEmission == limit) &#123;</div><div class=\"line\">                    requestAmount = BackpressureUtils.produced(requested, currentEmission);</div><div class=\"line\">                    request(currentEmission);</div><div class=\"line\">                    currentEmission = <span class=\"number\">0L</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> (requestAmount == currentEmission) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            emitted = currentEmission;</div><div class=\"line\">            missed = counter.addAndGet(-missed);</div><div class=\"line\">            <span class=\"keyword\">if</span> (missed == <span class=\"number\">0L</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>ObserveOnSubscriber</code>继承自<code>Subscriber</code>，并实现了<code>Action0</code>接口。我们看到<code>ObserveOnSubscriber</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>都有个<code>schedule()</code>，这个方法就是我们线程调度的关键；通过<code>schedule()</code>将新观察者<code>ObserveOnSubscriber</code>发送给<code>subscriberOne</code>的所有事件都切换到了<code>recursiveScheduler</code>所对应的线程，简单的说就是把<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法丢到了<code>recursiveScheduler</code>对应的线程中来执行。</p>\n<p>那么<code>schedule()</code>又是如何做到这一点的呢？他内部调用了<code>recursiveScheduler.schedule(this)</code>，<code>recursiveScheduler</code>其实就是一个<code>Worker</code>，和我们在介绍<code>subscribeOn()</code>时提到的<code>worker</code>一样，执行<code>schedule()</code>实际上最终是创建了一个<code>runable</code>，然后把这个<code>runnable</code>丢到了特定的线程池中去执行。在<code>runnable</code>的<code>run()</code>方法中调用了<code>ObserveOnSubscriber.call()</code>，看上面的代码大家就会发现在<code>call()</code>方法中最终调用了<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法。这便是它实现线程切换的原理。</p>\n<p>好了，我们最后再看看<strong>示例C</strong>对应的执行流程图，帮助大家加深理解。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess.jpg\" alt=\"RxJava执行流程\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这一章以<strong>执行流程</strong>、<strong>操作符实现</strong>以及<strong>线程调度</strong>三个方面为切入点剖析了RxJava源码。下一章将站在更宏观的角度来分析整个RxJava的框架结构、设计思想等等。敬请期待~~ :)</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a>  </li>\n</ul>\n<hr>\n<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>通过前面五个篇幅的介绍，相信大家对RxJava的基本使用以及操作符应该有了一定的认识。但是知其然还要知其所以然；所以从这一章开始我们聊聊源码，分析RxJava的实现原理。本文我们主要从三个方面来分析RxJava的实现：</p>\n<ul>\n<li>RxJava基本流程分析</li>\n<li>操作符原理分析</li>\n<li>线程调度原理分析</li>\n</ul>\n<blockquote>\n<p>本章节基于<strong>RxJava1.1.9</strong>版本的源码</p>\n</blockquote>\n<h2 id=\"一、RxJava执行流程分析\"><a href=\"#一、RxJava执行流程分析\" class=\"headerlink\" title=\"一、RxJava执行流程分析\"></a>一、RxJava执行流程分析</h2><p>在<a href=\"http://www.jianshu.com/p/ba61c047c230\">RxJava系列2(基本概念及使用介绍)</a>中我们介绍过，一个最基本的RxJava调用是这样的：</p>\n<p><strong>示例A</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hello RxJava!\"</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>首先调用<code>Observable.create()</code>创建一个被观察者<code>Observable</code>，同时创建一个<code>OnSubscribe</code>作为<code>create()</code>方法的入参；接着创建一个观察者<code>Subscriber</code>，然后通过<code>subseribe()</code>实现二者的订阅关系。这里涉及到三个关键对象和一个核心的方法：</p>\n<ul>\n<li><strong>Observable</strong>（被观察者）</li>\n<li><strong>OnSubscribe</strong> (从纯设计模式的角度来理解，<code>OnSubscribe.call()</code>可以看做是<a href=\"https://github.com/BaronZ88/Blog/blob/master/DesignPatterns/ObserverPattern/%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F.md\">观察者模式</a>中被观察者用来通知观察者的<code>notifyObservers()</code>方法)</li>\n<li><strong>Subscriber</strong> （观察者）</li>\n<li><strong>subscribe()</strong> （实现观察者与被观察者订阅关系的方法）</li>\n</ul>\n<h3 id=\"1、Observable-create-源码分析\"><a href=\"#1、Observable-create-源码分析\" class=\"headerlink\" title=\"1、Observable.create()源码分析\"></a>1、Observable.create()源码分析</h3><p>首先我们来看看<code>Observable.create()</code>的实现:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Observable&lt;T&gt; <span class=\"title\">create</span><span class=\"params\">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>这里创建了一个被观察者<code>Observable</code>，同时将<code>RxJavaHooks.onCreate(f)</code>作为构造函数的参数，源码如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">Observable</span><span class=\"params\">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</div><div class=\"line\">\t<span class=\"keyword\">this</span>.onSubscribe = f;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>我们看到源码中直接将参数<code>RxJavaHooks.onCreate(f)</code>赋值给了当前我们构造的被观察者<code>Observable</code>的成员变量<code>onSubscribe</code>。那么<code>RxJavaHooks.onCreate(f)</code>返回的又是什么呢？我们接着往下看：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; Observable.<span class=\"function\">OnSubscribe&lt;T&gt; <span class=\"title\">onCreate</span><span class=\"params\">(Observable.OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</div><div class=\"line\">    Func1&lt;OnSubscribe, OnSubscribe&gt; f = onObservableCreate;</div><div class=\"line\">    <span class=\"keyword\">if</span> (f != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> f.call(onSubscribe);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">return</span> onSubscribe;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>由于我们并没调用<code>RxJavaHooks.initCreate()</code>，所以上面代码中的<code>onObservableCreate</code>为null；因此<code>RxJavaHooks.onCreate(f)</code>最终返回的就是<code>f</code>，也就是我们在<code>Observable.create()</code>的时候new出来的<code>OnSubscribe</code>。（<em>由于对RxJavaHooks的理解并不影响我们对RxJava执行流程的分析，因此在这里我们不做进一步的探讨。为了方便理解我们只需要知道RxJavaHooks一系列方法的返回值就是入参本身就OK了，例如这里的<code>RxJavaHooks.onCreate(f)</code>返回的就是<code>f</code></em>）。</p>\n<p>至此我们做下逻辑梳理：<strong><code>Observable.create()</code>方法构造了一个被观察者<code>Observable</code>对象，同时将new出来的<code>OnSubscribe</code>赋值给了该<code>Observable</code>的成员变量<code>onSubscribe</code>。</strong></p>\n<h3 id=\"2、Subscriber源码分析\"><a href=\"#2、Subscriber源码分析\" class=\"headerlink\" title=\"2、Subscriber源码分析\"></a>2、Subscriber源码分析</h3><p>接着我们看下观察者<code>Subscriber</code>的源码，为了增加可读性，我去掉了源码中的注释和部分代码。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Observer</span>&lt;<span class=\"title\">T</span>&gt;, <span class=\"title\">Subscription</span> </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> SubscriptionList subscriptions;<span class=\"comment\">//订阅事件集，所有发送给当前Subscriber的事件都会保存在这里</span></div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"title\">Subscriber</span><span class=\"params\">(Subscriber&lt;?&gt; subscriber, <span class=\"keyword\">boolean</span> shareSubscriptions)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subscriber = subscriber;</div><div class=\"line\">        <span class=\"keyword\">this</span>.subscriptions = shareSubscriptions &amp;&amp; subscriber != <span class=\"keyword\">null</span> ? subscriber.subscriptions : <span class=\"keyword\">new</span> SubscriptionList();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">unsubscribe</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        subscriptions.unsubscribe();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isUnsubscribed</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> subscriptions.isUnsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onStart</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Subscription</span> </span>&#123;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">unsubscribe</span><span class=\"params\">()</span></span>;</div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isUnsubscribed</span><span class=\"params\">()</span></span>;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>Subscriber</code>实现了<code>Subscription</code>接口，从而对外提供<code>isUnsubscribed()</code>和<code>unsubscribe()</code>方法。前者用于判断是否已经取消订阅；后者用于将订阅事件列表(<em>也就是当前观察者的成员变量<code>subscriptions</code></em>)中的所有<code>Subscription</code>取消订阅，并且不再接受观察者<code>Observable</code>发送的后续事件。</p>\n<h3 id=\"3、subscribe-源码分析\"><a href=\"#3、subscribe-源码分析\" class=\"headerlink\" title=\"3、subscribe()源码分析\"></a>3、subscribe()源码分析</h3><p>前面我们分析了观察者和被观察者相关的源码，那么接下来便是整个订阅流程中最最关键的环节了。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> Observable.subscribe(subscriber, <span class=\"keyword\">this</span>);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\">Subscription <span class=\"title\">subscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">\t...</div><div class=\"line\"></div><div class=\"line\">    subscriber.onStart();</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">if</span> (!(subscriber <span class=\"keyword\">instanceof</span> SafeSubscriber)) &#123;</div><div class=\"line\">        subscriber = <span class=\"keyword\">new</span> SafeSubscriber&lt;T&gt;(subscriber);</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">return</span> Subscriptions.unsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>subscribe()</code>方法中将传进来的<code>subscriber</code>包装成了<code>SafeSubscriber</code>，<code>SafeSubscriber</code>其实是<code>subscriber</code>的一个代理，对<code>subscriber</code>的一系列方法做了更加严格的安全校验。保证了<code>onCompleted()</code>和<code>onError()</code>只会有一个被执行且只执行一次，一旦它们其中方法被执行过后<code>onNext()</code>就不在执行了。</p>\n<p>上述代码中最关键的就是<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber)</code>。这里的RxJavaHooks和之前提到的一样，<code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe)</code>返回的正是他的第二个入参<code>observable.onSubscribe</code>，也就是当前<code>observable</code>的成员变量<code>onSubscribe</code>。而这个成员变量我们前面提到过，它是我们在<code>Observable.create()</code>的时候new出来的。所以这段代码可以简化为<code>onSubscribe.call(subscriber)</code>。这也印证了我在<a href=\"http://www.jianshu.com/p/ba61c047c230\">RxJava系列2(基本概念及使用介绍)</a>中说的，<code>onSubscribe.call(subscriber)</code>中的<code>subscriber</code>正是我们在<code>subscribe()</code>方法中new出来的观察者。</p>\n<p>到这里，我们对RxJava的执行流程做个总结：首先我们调用<code>crate()</code>创建一个观察者，同时创建一个<code>OnSubscribe</code>作为该方法的入参；接着调用<code>subscribe()</code>来订阅我们自己创建的观察者<code>Subscriber</code>。<br>一旦调用<code>subscribe()</code>方法后就会触发执行<code>OnSubscribe.call()</code>。然后我们就可以在call方法调用观察者<code>subscriber</code>的<code>onNext()</code>,<code>onCompleted()</code>,<code>onError()</code>。</p>\n<p>最后我用张图来总结下之前的分析结果：</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess1.jpg\" alt=\"RxJava基本流程分析\"></p>\n<h2 id=\"二、操作符原理分析\"><a href=\"#二、操作符原理分析\" class=\"headerlink\" title=\"二、操作符原理分析\"></a>二、操作符原理分析</h2><p>之前我们介绍过几十个操作符，要一一分析它们的源码显然不太现实。在这里我抛砖引玉，选取一个相对简单且常用的<code>map</code>操作符来分析。</p>\n<p>我们先来看一个<code>map</code>操作符的简单应用：</p>\n<p><strong>示例B</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"number\">1</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).map(<span class=\"keyword\">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">\"This is \"</span> + integer;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribe(<span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"onCompleted!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<p>为了便于表述，我将上面的代码做了如下拆解：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Integer&gt; observableA = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Integer&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Integer&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"number\">1</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\">Subscriber&lt;String&gt; subscriberOne = <span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"onCompleted!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">        System.out.println(e.getMessage());</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;;</div><div class=\"line\"></div><div class=\"line\">Observable&lt;String&gt; observableB = </div><div class=\"line\">        observableA.map(<span class=\"keyword\">new</span> Func1&lt;Integer, String&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">call</span><span class=\"params\">(Integer integer)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> <span class=\"string\">\"This is \"</span> + integer;;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">observableB.subscribe(subscriberOne);</div></pre></td></tr></table></figure>\n<p><code>map()</code>的源码和上一小节介绍的<code>create()</code>一样位于<code>Observable</code>这个类中。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">map</span><span class=\"params\">(Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; func)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> OnSubscribeMap&lt;T, R&gt;(<span class=\"keyword\">this</span>, func));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过查看源码我们发现调用<code>map()</code>的时候实际上是创建了一个新的被观察者<code>Observable</code>，我们姑且称它为<code>ObservableB</code>；一开始通过<code>Observable.create()</code>创建的<code>Observable</code>我们称之为<code>ObservableA</code>。在创建<code>ObservableB</code>的时候同时创建了一个<code>OnSubscribeMap</code>，而<code>ObservableA</code>和变换函数<code>Func1</code>则作为构造<code>OnSubscribeMap</code>的参数。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnSubscribeMap</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">OnSubscribe</span>&lt;<span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Observable&lt;T&gt; source;<span class=\"comment\">//ObservableA</span></div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">final</span> Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; transformer;<span class=\"comment\">//map操作符中的转换函数Func1。T为转换前的数据类型，在上面的例子中为Integer；R为转换后的数据类型，在该例中为String。</span></div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OnSubscribeMap</span><span class=\"params\">(Observable&lt;T&gt; source, Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.source = source;</div><div class=\"line\">        <span class=\"keyword\">this</span>.transformer = transformer;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(<span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; o)</span> </span>&#123;<span class=\"comment\">//结合第一小节的分析结果，我们知道这里的入参o其实就是我们自己new的观察者subscriberOne。</span></div><div class=\"line\">        MapSubscriber&lt;T, R&gt; parent = <span class=\"keyword\">new</span> MapSubscriber&lt;T, R&gt;(o, transformer);</div><div class=\"line\">        o.add(parent);</div><div class=\"line\">        source.unsafeSubscribe(parent);</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MapSubscriber</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; actual;<span class=\"comment\">//这里的actual就是我们在调用subscribe()时创建的观察者mSubscriber</span></div><div class=\"line\">        <span class=\"keyword\">final</span> Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper;<span class=\"comment\">//变换函数</span></div><div class=\"line\">        <span class=\"keyword\">boolean</span> done;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MapSubscriber</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; actual, Func1&lt;? <span class=\"keyword\">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</div><div class=\"line\">            <span class=\"keyword\">this</span>.actual = actual;</div><div class=\"line\">            <span class=\"keyword\">this</span>.mapper = mapper;</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">            R result;</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                result = mapper.call(t);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">                Exceptions.throwIfFatal(ex);</div><div class=\"line\">                unsubscribe();</div><div class=\"line\">                onError(OnErrorThrowable.addValueAsLastCause(ex, t));</div><div class=\"line\">                <span class=\"keyword\">return</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">            actual.onNext(result);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">            ...</div><div class=\"line\">            actual.onError(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">            ...</div><div class=\"line\">            actual.onCompleted();</div><div class=\"line\">        &#125;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"meta\">@Override</span></div><div class=\"line\">        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setProducer</span><span class=\"params\">(Producer p)</span> </span>&#123;</div><div class=\"line\">            actual.setProducer(p);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OnSubscribeMap</code>实现了<code>OnSubscribe</code>接口，因此<code>OnSubscribeMap</code>就是一个<code>OnSubscribe</code>。在调用<code>map()</code>的时候创建了一个新的被观察者<code>ObservableB</code>，然后我们用<code>ObservableB.subscribe(subscriberOne)</code>订阅了观察者<code>subscriberOne</code>。结合我们在第一小节的分析结果，所以<code>OnSubscribeMap.call(o)</code>中的<code>o</code>就是<code>subscribe(subscriberOne)</code>中的<code>subscriberOne</code>；一旦调用了<code>ObservableB.subscribe(subscriberOne)</code>就会执行<code>OnSubscribeMap.call()</code>。</p>\n<p>在<code>call()</code>方法中，首先通过我们的观察者<code>o</code>和转换函数<code>transformer</code>构造了一个<code>MapSubscriber</code>，最后调用了<code>source</code>也就是<code>observableA</code>的<code>unsafeSubscribe()</code>方法。即<code>observableA</code>订阅了一个观察者<code>MapSubscriber</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Subscription <span class=\"title\">unsafeSubscribe</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        RxJavaHooks.onObservableStart(<span class=\"keyword\">this</span>, onSubscribe).call(subscriber);</div><div class=\"line\">        <span class=\"keyword\">return</span> RxJavaHooks.onObservableReturn(subscriber);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">return</span> Subscriptions.unsubscribed();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面这段代码最终执行了<code>onSubscribe</code>也就是<code>OnSubscribeMap</code>的<code>call()</code>方法，<code>call()</code>方法中的参数就是之前在<code>OnSubscribeMap.call()</code>中new出来的<code>MapSubscriber</code>。最后在<code>call()</code>方法中执行了我们自己的业务代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div></pre></td><td class=\"code\"><pre><div class=\"line\">subscriber.onNext(<span class=\"number\">1</span>);</div><div class=\"line\">subscriber.onCompleted();</div></pre></td></tr></table></figure>\n<p>其实也就是执行了<code>MapSubscriber</code>的<code>onNext()</code>和<code>onCompleted()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"meta\">@Override</span></div><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">    R result;</div><div class=\"line\">    <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">        result = mapper.call(t);</div><div class=\"line\">    &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</div><div class=\"line\">        ...</div><div class=\"line\">        <span class=\"keyword\">return</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    actual.onNext(result);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>onNext(T t)</code>方法中的的<code>mapper</code>就是变换函数，<code>actual</code>就是我们在调用<code>subscribe()</code>时创建的观察者<code>subscriberOne</code>。这个<code>T</code>就是我们例子中的<code>Integer</code>，<code>R</code>就是<code>String</code>。在<code>onNext()</code>中首先调用变换函数<code>mapper.call()</code>将<code>T</code>转换成<code>R</code>(在我们的例子中就是将<code>Integer</code>类型的<strong>1</strong>转换成了<code>String</code>类型的<strong>“This is 1”</strong>)；接着调用<code>subscriberOne.onNext(String result)</code>。同样在调用<code>MapSubscriber.onCompleted()</code>时会执行<code>subscriberOne.onCompleted()</code>。这样就完成了一直完成的调用流程。</p>\n<p>我承认太啰嗦了，花费了这么大的篇幅才将<code>map()</code>的转换原理解释清楚。我也是希望尽量的将每个细节都呈现出来方便大家理解，如果看我啰嗦了这么久还是没能理解，请看下面我画的这张执行流程图。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess3.jpg\" alt=\"加入Map操作符后的执行流程\"></p>\n<h2 id=\"三、线程调度原理分析\"><a href=\"#三、线程调度原理分析\" class=\"headerlink\" title=\"三、线程调度原理分析\"></a>三、线程调度原理分析</h2><p>在前面的文章中我介绍过RxJava可以很方便的通过<code>subscribeOn()</code>和<code>observeOn()</code>来指定数据流的每一部分运行在哪个线程。其中<code>subscribeOn()</code>指定了处理<code>Observable</code>的全部的过程(包括发射数据和通知)的线程；<code>observeOn()</code>指定了观察者的<code>onNext()</code>, <code>onError()</code>和<code>onCompleted()</code>执行的线程。接下来我们就分析分析源码，看看线程调度是如何实现的。</p>\n<p>在分析源码前我们先看看一段常见的通过RxJava实现的线程调度代码：</p>\n<p><strong>示例C</strong></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> String&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        subscriber.onNext(<span class=\"string\">\"Hello RxJava!\"</span>);</div><div class=\"line\">        subscriber.onCompleted();</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;).subscribeOn(Schedulers.io())</div><div class=\"line\">.observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">.subscribe(<span class=\"keyword\">new</span> Subscriber&lt;String&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        System.out.println(<span class=\"string\">\"completed!\"</span>);</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(String s)</span> </span>&#123;</div><div class=\"line\">        System.out.println(s);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div></pre></td></tr></table></figure>\n<h3 id=\"1、subscribeOn-源码分析\"><a href=\"#1、subscribeOn-源码分析\" class=\"headerlink\" title=\"1、subscribeOn()源码分析\"></a>1、subscribeOn()源码分析</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Observable&lt;T&gt; <span class=\"title\">subscribeOn</span><span class=\"params\">(Scheduler scheduler)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> OperatorSubscribeOn&lt;T&gt;(<span class=\"keyword\">this</span>, scheduler));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过上面的代码我们可以看到，<code>subscribeOn()</code>和<code>map()</code>一样是创建了一个新的被观察者<code>Observable</code>。因此我大致就能猜到<code>subscribeOn()</code>的执行流程应该和<code>map()</code>差不多，<code>OperatorSubscribeOn</code>肯定也是一个<code>OnSubscribe</code>。那我们接下来就看看<code>OperatorSubscribeOn</code>的源码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OperatorSubscribeOn</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">OnSubscribe</span>&lt;<span class=\"title\">T</span>&gt; </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Scheduler scheduler;<span class=\"comment\">//线程调度器，用来指定订阅事件发送、处理等所在的线程</span></div><div class=\"line\">    <span class=\"keyword\">final</span> Observable&lt;T&gt; source;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OperatorSubscribeOn</span><span class=\"params\">(Observable&lt;T&gt; source, Scheduler scheduler)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.scheduler = scheduler;</div><div class=\"line\">        <span class=\"keyword\">this</span>.source = source;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(<span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">final</span> Worker inner = scheduler.createWorker();</div><div class=\"line\">        subscriber.add(inner);</div><div class=\"line\">        </div><div class=\"line\">        inner.schedule(<span class=\"keyword\">new</span> Action0() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">final</span> Thread t = Thread.currentThread();</div><div class=\"line\">                </div><div class=\"line\">                Subscriber&lt;T&gt; s = <span class=\"keyword\">new</span> Subscriber&lt;T&gt;(subscriber) &#123;</div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(T t)</span> </span>&#123;</div><div class=\"line\">                        subscriber.onNext(t);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    </div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(Throwable e)</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                            subscriber.onError(e);</div><div class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                            inner.unsubscribe();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    </div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                            subscriber.onCompleted();</div><div class=\"line\">                        &#125; <span class=\"keyword\">finally</span> &#123;</div><div class=\"line\">                            inner.unsubscribe();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;</div><div class=\"line\">                    </div><div class=\"line\">                    <span class=\"meta\">@Override</span></div><div class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setProducer</span><span class=\"params\">(<span class=\"keyword\">final</span> Producer p)</span> </span>&#123;</div><div class=\"line\">                        subscriber.setProducer(<span class=\"keyword\">new</span> Producer() &#123;</div><div class=\"line\">                            <span class=\"meta\">@Override</span></div><div class=\"line\">                            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">request</span><span class=\"params\">(<span class=\"keyword\">final</span> <span class=\"keyword\">long</span> n)</span> </span>&#123;</div><div class=\"line\">                                <span class=\"keyword\">if</span> (t == Thread.currentThread()) &#123;</div><div class=\"line\">                                    p.request(n);</div><div class=\"line\">                                &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">                                    inner.schedule(<span class=\"keyword\">new</span> Action0() &#123;</div><div class=\"line\">                                        <span class=\"meta\">@Override</span></div><div class=\"line\">                                        <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                                            p.request(n);</div><div class=\"line\">                                        &#125;</div><div class=\"line\">                                    &#125;);</div><div class=\"line\">                                &#125;</div><div class=\"line\">                            &#125;</div><div class=\"line\">                        &#125;);</div><div class=\"line\">                    &#125;</div><div class=\"line\">                &#125;;</div><div class=\"line\">                source.unsafeSubscribe(s);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OperatorSubscribeOn</code>实现了<code>OnSubscribe</code>接口，<code>call()</code>中对<code>Subscriber</code>的处理也和<code>OperatorMap</code>对<code>Subscriber</code>的处理类似。首先通过<code>scheduler</code>构建了一个<code>Worker</code>；然后用传进来的<code>subscriber</code>构造了一个新的<code>Subscriber s</code>，并将<code>s</code>丢到<code>Worker.schedule()</code>中来处理；最后用原<code>Observable</code>去订阅观察者<code>s</code>。而这个<code>Worker</code>就是线程调度的关键！前面的例子中我们通过<code>subscribeOn(Schedulers.io())</code>指定了<code>Observable</code>发射处理事件以及通知观察者的一系列操作的执行线程，正是通过这个<code>Schedulers.io()</code>创建了我们前面提到的<code>Worker</code>。所以我们来看看<code>Schedulers.io()</code>的实现。</p>\n<p>首先通过<code>Schedulers.io()</code>获得了<code>ioScheduler</code>并返回，上面的<code>OperatorSubscribeOn</code>通过这个的<code>Scheduler</code>的<code>createWorker()</code>方法创建了我们前面提到的<code>Worker</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Scheduler <span class=\"title\">io</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> RxJavaHooks.onIOScheduler(getInstance().ioScheduler);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>接着我们看看这个<code>ioScheduler</code>是怎么来的，下面的代码向我们展现了是如何在<code>Schedulers</code>的构造函数中通过<code>RxJavaSchedulersHook.createIoScheduler()</code>来初始化<code>ioScheduler</code>的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"title\">Schedulers</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    Scheduler io = hook.getIOScheduler();</div><div class=\"line\">    <span class=\"keyword\">if</span> (io != <span class=\"keyword\">null</span>) &#123;</div><div class=\"line\">        ioScheduler = io;</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        ioScheduler = RxJavaSchedulersHook.createIoScheduler();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>最终<code>RxJavaSchedulersHook.createIoScheduler()</code>返回了一个<code>CachedThreadScheduler</code>，并赋值给了<code>ioScheduler</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Scheduler <span class=\"title\">createIoScheduler</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> createIoScheduler(<span class=\"keyword\">new</span> RxThreadFactory(<span class=\"string\">\"RxIoScheduler-\"</span>));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> Scheduler <span class=\"title\">createIoScheduler</span><span class=\"params\">(ThreadFactory threadFactory)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> CachedThreadScheduler(threadFactory);</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>到这一步既然我们知道了<code>ioScheduler</code>就是一个<code>CachedThreadScheduler</code>，那我们就来看看它的<code>createWorker()</code>的实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Worker <span class=\"title\">createWorker</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> EventLoopWorker(pool.get());</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>上面的代码向我们赤裸裸的呈现了前面<code>OperatorSubscribeOn</code>中的<code>Worker</code>其实就是<code>EventLoopWorker</code>。我们重点要关注的是他的<code>scheduleActual()</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">EventLoopWorker</span> <span class=\"keyword\">extends</span> <span class=\"title\">Scheduler</span>.<span class=\"title\">Worker</span> <span class=\"keyword\">implements</span> <span class=\"title\">Action0</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CompositeSubscription innerSubscription = <span class=\"keyword\">new</span> CompositeSubscription();</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> CachedWorkerPool pool;</div><div class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> ThreadWorker threadWorker;</div><div class=\"line\">    <span class=\"keyword\">final</span> AtomicBoolean once;</div><div class=\"line\"></div><div class=\"line\">    EventLoopWorker(CachedWorkerPool pool) &#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.pool = pool;</div><div class=\"line\">        <span class=\"keyword\">this</span>.once = <span class=\"keyword\">new</span> AtomicBoolean();</div><div class=\"line\">        <span class=\"keyword\">this</span>.threadWorker = pool.get();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Subscription <span class=\"title\">schedule</span><span class=\"params\">(<span class=\"keyword\">final</span> Action0 action, <span class=\"keyword\">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        ScheduledAction s = threadWorker.scheduleActual(<span class=\"keyword\">new</span> Action0() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (isUnsubscribed()) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                action.call();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, delayTime, unit);</div><div class=\"line\">        innerSubscription.add(s);</div><div class=\"line\">        s.addParent(innerSubscription);</div><div class=\"line\">        <span class=\"keyword\">return</span> s;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p>通过对源码的一步步追踪，我们知道了前面<code>OperatorSubscribeOn.call()</code>中的<code>inner.schedule()</code>最终会执行到<code>ThreadWorker</code>的<code>scheduleActual()</code>方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> ScheduledAction <span class=\"title\">scheduleActual</span><span class=\"params\">(<span class=\"keyword\">final</span> Action0 action, <span class=\"keyword\">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</div><div class=\"line\">    Action0 decoratedAction = RxJavaHooks.onScheduledAction(action);</div><div class=\"line\">    ScheduledAction run = <span class=\"keyword\">new</span> ScheduledAction(decoratedAction);</div><div class=\"line\">    Future&lt;?&gt; f;</div><div class=\"line\">    <span class=\"keyword\">if</span> (delayTime &lt;= <span class=\"number\">0</span>) &#123;</div><div class=\"line\">        f = executor.submit(run);</div><div class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">        f = executor.schedule(run, delayTime, unit);</div><div class=\"line\">    &#125;</div><div class=\"line\">    run.add(f);</div><div class=\"line\">    <span class=\"keyword\">return</span> run;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>scheduleActual()</code>中的<code>ScheduledAction</code>实现了<code>Runnable</code>接口，通过线程池<code>executor</code>最终实现了线程切换。上面便是<code>subscribeOn(Schedulers.io())</code>实现线程切换的全部过程。</p>\n<h3 id=\"2、observeOn-源码分析\"><a href=\"#2、observeOn-源码分析\" class=\"headerlink\" title=\"2、observeOn()源码分析\"></a>2、observeOn()源码分析</h3><p><code>observeOn()</code>切换线程是通过<code>lift</code>来实现的，相比<code>subscribeOn()</code>在实现原理上相对复杂些。不过本质上最终还是创建了一个新的<code>Observable</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Observable&lt;T&gt; <span class=\"title\">observeOn</span><span class=\"params\">(Scheduler scheduler, <span class=\"keyword\">boolean</span> delayError, <span class=\"keyword\">int</span> bufferSize)</span> </span>&#123;</div><div class=\"line\">    ...</div><div class=\"line\">    <span class=\"keyword\">return</span> lift(<span class=\"keyword\">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> &lt;R&gt; <span class=\"function\">Observable&lt;R&gt; <span class=\"title\">lift</span><span class=\"params\">(<span class=\"keyword\">final</span> Operator&lt;? extends R, ? <span class=\"keyword\">super</span> T&gt; operator)</span> </span>&#123;</div><div class=\"line\">    <span class=\"keyword\">return</span> create(<span class=\"keyword\">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OperatorObserveOn</code>作为<code>OnSubscribeLift</code>构造函数的参数用来创建了一个新的<code>OnSubscribeLift</code>对象，接下来我们看看<code>OnSubscribeLift</code>的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">OnSubscribeLift</span>&lt;<span class=\"title\">T</span>, <span class=\"title\">R</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">OnSubscribe</span>&lt;<span class=\"title\">R</span>&gt; </span>&#123;</div><div class=\"line\">    </div><div class=\"line\">    <span class=\"keyword\">final</span> OnSubscribe&lt;T&gt; parent;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"keyword\">final</span> Operator&lt;? extends R, ? <span class=\"keyword\">super</span> T&gt; operator;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">OnSubscribeLift</span><span class=\"params\">(OnSubscribe&lt;T&gt; parent, Operator&lt;? extends R, ? <span class=\"keyword\">super</span> T&gt; operator)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">this</span>.parent = parent;</div><div class=\"line\">        <span class=\"keyword\">this</span>.operator = operator;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> R&gt; o)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; st = RxJavaHooks.onObservableLift(operator).call(o);</div><div class=\"line\">            <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                st.onStart();</div><div class=\"line\">                parent.call(st);</div><div class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">                Exceptions.throwIfFatal(e);</div><div class=\"line\">                st.onError(e);</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable e) &#123;</div><div class=\"line\">            Exceptions.throwIfFatal(e);</div><div class=\"line\">            o.onError(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OnSubscribeLift</code>继承自<code>OnSubscribe</code>，通过前面的分析我们知道一旦调用了<code>subscribe()</code>将观察者与被观察绑定后就会触发被观察者所对应的<code>OnSubscribe</code>的<code>call()</code>方法，所以这里会触发<code>OnSubscribeLift.call()</code>。在<code>call()</code>中调用了<code>OperatorObserveOn.call()</code>并返回了一个新的观察者<code>Subscriber st</code>，接着调用了前一级<code>Observable</code>对应<code>OnSubscriber.call(st)</code>。</p>\n<p>我们再看看<code>OperatorObserveOn.call()</code>的实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">public</span> Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; call(Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; child) &#123;</div><div class=\"line\">    ...</div><div class=\"line\">    ObserveOnSubscriber&lt;T&gt; parent = <span class=\"keyword\">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</div><div class=\"line\">    parent.init();</div><div class=\"line\">    <span class=\"keyword\">return</span> parent;</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>OperatorObserveOn.call()</code>中创建了一个<code>ObserveOnSubscriber</code>并调用<code>init()</code>进行了初始化。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div></pre></td><td class=\"code\"><pre><div class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ObserveOnSubscriber</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Subscriber</span>&lt;<span class=\"title\">T</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Action0</span> </span>&#123;</div><div class=\"line\"></div><div class=\"line\">    ...</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onNext</span><span class=\"params\">(<span class=\"keyword\">final</span> T t)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        schedule();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onCompleted</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        schedule();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">onError</span><span class=\"params\">(<span class=\"keyword\">final</span> Throwable e)</span> </span>&#123;</div><div class=\"line\">        ...</div><div class=\"line\">        schedule();</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">schedule</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">if</span> (counter.getAndIncrement() == <span class=\"number\">0</span>) &#123;</div><div class=\"line\">            recursiveScheduler.schedule(<span class=\"keyword\">this</span>);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\"></div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">()</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">long</span> missed = <span class=\"number\">1L</span>;</div><div class=\"line\">        <span class=\"keyword\">long</span> currentEmission = emitted;</div><div class=\"line\"></div><div class=\"line\">        <span class=\"keyword\">final</span> Queue&lt;Object&gt; q = <span class=\"keyword\">this</span>.queue;</div><div class=\"line\">        <span class=\"keyword\">final</span> Subscriber&lt;? <span class=\"keyword\">super</span> T&gt; localChild = <span class=\"keyword\">this</span>.child;</div><div class=\"line\">        <span class=\"keyword\">final</span> NotificationLite&lt;T&gt; localOn = <span class=\"keyword\">this</span>.on;</div><div class=\"line\">        </div><div class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</div><div class=\"line\">            <span class=\"keyword\">long</span> requestAmount = requested.get();</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">while</span> (requestAmount != currentEmission) &#123;</div><div class=\"line\">                <span class=\"keyword\">boolean</span> done = finished;</div><div class=\"line\">                Object v = q.poll();</div><div class=\"line\">                <span class=\"keyword\">boolean</span> empty = v == <span class=\"keyword\">null</span>;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"keyword\">if</span> (checkTerminated(done, empty, localChild, q)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">                <span class=\"keyword\">if</span> (empty) &#123;</div><div class=\"line\">                    <span class=\"keyword\">break</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">                </div><div class=\"line\">                localChild.onNext(localOn.getValue(v));</div><div class=\"line\"></div><div class=\"line\">                currentEmission++;</div><div class=\"line\">                <span class=\"keyword\">if</span> (currentEmission == limit) &#123;</div><div class=\"line\">                    requestAmount = BackpressureUtils.produced(requested, currentEmission);</div><div class=\"line\">                    request(currentEmission);</div><div class=\"line\">                    currentEmission = <span class=\"number\">0L</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\">            </div><div class=\"line\">            <span class=\"keyword\">if</span> (requestAmount == currentEmission) &#123;</div><div class=\"line\">                <span class=\"keyword\">if</span> (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span>;</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;</div><div class=\"line\"></div><div class=\"line\">            emitted = currentEmission;</div><div class=\"line\">            missed = counter.addAndGet(-missed);</div><div class=\"line\">            <span class=\"keyword\">if</span> (missed == <span class=\"number\">0L</span>) &#123;</div><div class=\"line\">                <span class=\"keyword\">break</span>;</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">    </div><div class=\"line\">    ...</div><div class=\"line\">&#125;</div></pre></td></tr></table></figure>\n<p><code>ObserveOnSubscriber</code>继承自<code>Subscriber</code>，并实现了<code>Action0</code>接口。我们看到<code>ObserveOnSubscriber</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>都有个<code>schedule()</code>，这个方法就是我们线程调度的关键；通过<code>schedule()</code>将新观察者<code>ObserveOnSubscriber</code>发送给<code>subscriberOne</code>的所有事件都切换到了<code>recursiveScheduler</code>所对应的线程，简单的说就是把<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法丢到了<code>recursiveScheduler</code>对应的线程中来执行。</p>\n<p>那么<code>schedule()</code>又是如何做到这一点的呢？他内部调用了<code>recursiveScheduler.schedule(this)</code>，<code>recursiveScheduler</code>其实就是一个<code>Worker</code>，和我们在介绍<code>subscribeOn()</code>时提到的<code>worker</code>一样，执行<code>schedule()</code>实际上最终是创建了一个<code>runable</code>，然后把这个<code>runnable</code>丢到了特定的线程池中去执行。在<code>runnable</code>的<code>run()</code>方法中调用了<code>ObserveOnSubscriber.call()</code>，看上面的代码大家就会发现在<code>call()</code>方法中最终调用了<code>subscriberOne</code>的<code>onNext()</code>、<code>onCompleted()</code>、<code>onError()</code>方法。这便是它实现线程切换的原理。</p>\n<p>好了，我们最后再看看<strong>示例C</strong>对应的执行流程图，帮助大家加深理解。</p>\n<p><img src=\"http://ocjtywvav.bkt.clouddn.com/rxjava/6/OperatorProcess.jpg\" alt=\"RxJava执行流程\"></p>\n<h2 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h2><p>这一章以<strong>执行流程</strong>、<strong>操作符实现</strong>以及<strong>线程调度</strong>三个方面为切入点剖析了RxJava源码。下一章将站在更宏观的角度来分析整个RxJava的框架结构、设计思想等等。敬请期待~~ :)</p>\n<blockquote>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例","date":"2017-02-05T16:30:27.000Z","_content":"\n之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/) \n\n## 业务场景\n\n拿[MinimalistWeather](https://github.com/BaronZ88/MinimalistWeather)这个开源的天气App来举例：\n\n进入App首页后，首先我们需要从数据库中获取当前城市的天气数据，如果数据库中存在天气数据则在UI页面上展示天气数据；如果数据库中未存储当前城市的天气数据，或者已存储的天气数据的发布时间相比现在已经超过了一小时，并且网络属于连接状态则调用API从服务端获取天气数据。如果获取到到的天气数据发布时间和当前数据库中的天气数据发布时间一致则丢弃掉从服务端获取到的天气数据，如果不一致则更新数据库并且在页面上展示最新的天气信息。（同时天气数据源是可配置的，可选择是小米天气数据源还是Know天气数据源）\n\n## 解决方案\n\n首先我们需要创建一个从数据库获取天气数据的Observable `observableForGetWeatherFromDB`，同时我们也需要创建一个从API获取天气数据的Observable `observableForGetWeatherFromNetWork`；为了在无网络状态下免于创建`observableForGetWeatherFromNetWork`我们在这之前需要首先判断下网络状态。最后使用`contact`操作符将两个Observable合并，同时使用`distinct`和`takeUntil`操作符来过滤筛选数据以符合业务需求，然后结合`subscribeOn`和`observeOn`做线程切换。上述这一套复杂的业务逻辑如果使用传统编码方式将是极其复杂的。下面我们来看看使用RxJava如何清晰简洁的来实现这个复杂的业务：\n\n```Java\nObservable<Weather> observableForGetWeatherData;\n//首先创建一个从数据库获取天气数据的Observable\nObservable<Weather> observableForGetWeatherFromDB = Observable.create(new Observable.OnSubscribe<Weather>() {\n    @Override\n    public void call(Subscriber<? super Weather> subscriber) {\n        try {\n            Weather weather = weatherDao.queryWeather(cityId);\n            subscriber.onNext(weather);\n            subscriber.onCompleted();\n        } catch (SQLException e) {\n            throw Exceptions.propagate(e);\n        }\n    }\n});\n\nif (!NetworkUtils.isNetworkConnected(context)) {\n    observableForGetWeatherData = observableForGetWeatherFromDB;\n} else {\n    //接着创建一个从网络获取天气数据的Observable\n    Observable<Weather> observableForGetWeatherFromNetWork = null;\n    switch (configuration.getDataSourceType()) {\n        case ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:\n            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)\n                    .map(new Func1<KnowWeather, Weather>() {\n                        @Override\n                        public Weather call(KnowWeather knowWeather) {\n                            return new KnowWeatherAdapter(knowWeather).getWeather();\n                        }\n                    });\n            break;\n        case ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:\n            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)\n                    .map(new Func1<MiWeather, Weather>() {\n                        @Override\n                        public Weather call(MiWeather miWeather) {\n                            return new MiWeatherAdapter(miWeather).getWeather();\n                        }\n                    });\n            break;\n    }\n    assert observableForGetWeatherFromNetWork != null;\n    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork\n            .doOnNext(new Action1<Weather>() {\n                @Override\n                public void call(Weather weather) {\n                    Schedulers.io().createWorker().schedule(() -> {\n                        try {\n                            weatherDao.insertOrUpdateWeather(weather);\n                        } catch (SQLException e) {\n                            throw Exceptions.propagate(e);\n                        }\n                    });\n                }\n            });\n\n    //使用concat操作符将两个Observable合并\n    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)\n            .filter(new Func1<Weather, Boolean>() {\n                @Override\n                public Boolean call(Weather weather) {\n                    return weather != null && !TextUtils.isEmpty(weather.getCityId());\n                }\n            })\n            .distinct(new Func1<Weather, Long>() {\n                @Override\n                public Long call(Weather weather) {\n                    return weather.getRealTime().getTime();//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉\n                }\n            })\n            .takeUntil(new Func1<Weather, Boolean>() {\n                @Override\n                public Boolean call(Weather weather) {\n                    return System.currentTimeMillis() - weather.getRealTime().getTime() <= 60 * 60 * 1000;//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流\n                }\n            });\n}\n\nobservableForGetWeatherData.subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Action1<Weather>() {\n            @Override\n            public void call(Weather weather) {\n                displayWeatherInformation();\n            }\n        }, new Action1<Throwable>() {\n            @Override\n            public void call(Throwable throwable) {\n                Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show();\n            }\n        });\n```\n\n上面的代码看起来比较复杂，我们采用Lambda表达式简化下代码：\n\n```Java\nObservable<Weather> observableForGetWeatherData;\n//首先创建一个从数据库获取天气数据的Observable\nObservable<Weather> observableForGetWeatherFromDB = Observable.create(new Observable.OnSubscribe<Weather>() {\n    @Override\n    public void call(Subscriber<? super Weather> subscriber) {\n        try {\n            Weather weather = weatherDao.queryWeather(cityId);\n            subscriber.onNext(weather);\n            subscriber.onCompleted();\n        } catch (SQLException e) {\n            throw Exceptions.propagate(e);\n        }\n    }\n});\n\nif (!NetworkUtils.isNetworkConnected(context)) {\n    observableForGetWeatherData = observableForGetWeatherFromDB;\n} else {\n    //接着创建一个从网络获取天气数据的Observable\n    Observable<Weather> observableForGetWeatherFromNetWork = null;\n    switch (configuration.getDataSourceType()) {\n        case ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:\n            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)\n                    .map(knowWeather -> new KnowWeatherAdapter(knowWeather).getWeather());\n            break;\n        case ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:\n            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)\n                    .map(miWeather -> new MiWeatherAdapter(miWeather).getWeather());\n            break;\n    }\n    assert observableForGetWeatherFromNetWork != null;\n    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork\n            .doOnNext(weather -> Schedulers.io().createWorker().schedule(() -> {\n                try {\n                    weatherDao.insertOrUpdateWeather(weather);\n                } catch (SQLException e) {\n                    throw Exceptions.propagate(e);\n                }\n            }));\n\n    //使用concat操作符将两个Observable合并\n    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)\n            .filter(weather -> weather != null && !TextUtils.isEmpty(weather.getCityId()))\n            .distinct(weather -> weather.getRealTime().getTime())//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉\n            .takeUntil(weather -> System.currentTimeMillis() - weather.getRealTime().getTime() <= 60 * 60 * 1000);//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流\n}\n\nobservableForGetWeatherData.subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(weather -> displayWeatherInformation(),\n                throwable -> Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show());\n```\n\n## 小技巧\n\n在上述的实现中有几点是我们需要注意的:\n\n1. 为什么我需要在判断网络那块整个if else？这样看起来很不优雅，我们通过RxJava符完全可以实现同样的操作啊！之所以这样做是为了在无网络状况下去创建不必要的Observable `observableForGetWeatherFromNetWork`;\n\n2. 更新数据库的操作不应该阻塞更新UI，因此我们在`observableForGetWeatherFromNetWork`的`doOnNext`中需要通过`Schedulers.io().createWorker()`去另起一条线程，以此保证更新数据库不会阻塞更新UI的操作。\n\n\t> 有同学可能会问为什么不在`doOnNext`之后再调用一次`observeOn`把更新数据库的操作切换到一条新的子线程去操作呢？其实一开始我也是这样做的，后来想想不对。整个Observable的事件传递处理就像是在一条流水线上完成的，虽然我们可以通过`observeOn`来指定子线程去处理更新数据库的操作，但是只有等这条子线程完成了更新数据库的任务后事件才会继续往后传递，这样就阻塞了更新UI的操作。对此有疑问的同学可以去看看我之前关于RxJava源码分析的文章或者自己动手debug看看。\n\n## 问题\n\n最后给大家留个两个问题：\n\n1. 上述代码是最佳实现方案吗？还有什么更加合理的做法？\n2. 我们在`observableForGetWeatherData`中使用`distinct`和`takeUntil`过滤筛选天气数据的时候网络请求会不会已经发出去了？这样做还有意义吗？\n\n欢迎大家留言讨论。\n\n> 本文中的代码在[MinimalistWeather](https://github.com/BaronZ88/MinimalistWeather)中的`WeatherDataRepository`类中有同样的实现，文章中为了更完整的将整个实现过程呈现出来，对代码做了部分改动。\n> \n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","source":"_posts/2017-02-06-RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例.md","raw":"---\ntitle: RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例\ndate: 2017-02-06 00:30:27\ncategories: rxjava\ntags: \n- RxJava\n- Android\n---\n\n之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：\n\n* [RxJava系列1(简介)](../RxJava系列1-简介/)\n* [RxJava系列2(基本概念及使用介绍)](../RxJava系列2-基本概念及使用介绍/)\n* [RxJava系列3(转换操作符)](../RxJava系列3-转换操作符/)\n* [RxJava系列4(过滤操作符)](../RxJava系列4-过滤操作符/)\n* [RxJava系列5(组合操作符)](../RxJava系列5-组合操作符/)\n* [RxJava系列6(从微观角度解读RxJava源码)](../RxJava系列6-从微观角度解读RxJava源码/)   \n* [RxJava系列7(最佳实践)](../RxJava系列7-最佳实践/) \n\n## 业务场景\n\n拿[MinimalistWeather](https://github.com/BaronZ88/MinimalistWeather)这个开源的天气App来举例：\n\n进入App首页后，首先我们需要从数据库中获取当前城市的天气数据，如果数据库中存在天气数据则在UI页面上展示天气数据；如果数据库中未存储当前城市的天气数据，或者已存储的天气数据的发布时间相比现在已经超过了一小时，并且网络属于连接状态则调用API从服务端获取天气数据。如果获取到到的天气数据发布时间和当前数据库中的天气数据发布时间一致则丢弃掉从服务端获取到的天气数据，如果不一致则更新数据库并且在页面上展示最新的天气信息。（同时天气数据源是可配置的，可选择是小米天气数据源还是Know天气数据源）\n\n## 解决方案\n\n首先我们需要创建一个从数据库获取天气数据的Observable `observableForGetWeatherFromDB`，同时我们也需要创建一个从API获取天气数据的Observable `observableForGetWeatherFromNetWork`；为了在无网络状态下免于创建`observableForGetWeatherFromNetWork`我们在这之前需要首先判断下网络状态。最后使用`contact`操作符将两个Observable合并，同时使用`distinct`和`takeUntil`操作符来过滤筛选数据以符合业务需求，然后结合`subscribeOn`和`observeOn`做线程切换。上述这一套复杂的业务逻辑如果使用传统编码方式将是极其复杂的。下面我们来看看使用RxJava如何清晰简洁的来实现这个复杂的业务：\n\n```Java\nObservable<Weather> observableForGetWeatherData;\n//首先创建一个从数据库获取天气数据的Observable\nObservable<Weather> observableForGetWeatherFromDB = Observable.create(new Observable.OnSubscribe<Weather>() {\n    @Override\n    public void call(Subscriber<? super Weather> subscriber) {\n        try {\n            Weather weather = weatherDao.queryWeather(cityId);\n            subscriber.onNext(weather);\n            subscriber.onCompleted();\n        } catch (SQLException e) {\n            throw Exceptions.propagate(e);\n        }\n    }\n});\n\nif (!NetworkUtils.isNetworkConnected(context)) {\n    observableForGetWeatherData = observableForGetWeatherFromDB;\n} else {\n    //接着创建一个从网络获取天气数据的Observable\n    Observable<Weather> observableForGetWeatherFromNetWork = null;\n    switch (configuration.getDataSourceType()) {\n        case ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:\n            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)\n                    .map(new Func1<KnowWeather, Weather>() {\n                        @Override\n                        public Weather call(KnowWeather knowWeather) {\n                            return new KnowWeatherAdapter(knowWeather).getWeather();\n                        }\n                    });\n            break;\n        case ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:\n            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)\n                    .map(new Func1<MiWeather, Weather>() {\n                        @Override\n                        public Weather call(MiWeather miWeather) {\n                            return new MiWeatherAdapter(miWeather).getWeather();\n                        }\n                    });\n            break;\n    }\n    assert observableForGetWeatherFromNetWork != null;\n    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork\n            .doOnNext(new Action1<Weather>() {\n                @Override\n                public void call(Weather weather) {\n                    Schedulers.io().createWorker().schedule(() -> {\n                        try {\n                            weatherDao.insertOrUpdateWeather(weather);\n                        } catch (SQLException e) {\n                            throw Exceptions.propagate(e);\n                        }\n                    });\n                }\n            });\n\n    //使用concat操作符将两个Observable合并\n    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)\n            .filter(new Func1<Weather, Boolean>() {\n                @Override\n                public Boolean call(Weather weather) {\n                    return weather != null && !TextUtils.isEmpty(weather.getCityId());\n                }\n            })\n            .distinct(new Func1<Weather, Long>() {\n                @Override\n                public Long call(Weather weather) {\n                    return weather.getRealTime().getTime();//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉\n                }\n            })\n            .takeUntil(new Func1<Weather, Boolean>() {\n                @Override\n                public Boolean call(Weather weather) {\n                    return System.currentTimeMillis() - weather.getRealTime().getTime() <= 60 * 60 * 1000;//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流\n                }\n            });\n}\n\nobservableForGetWeatherData.subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(new Action1<Weather>() {\n            @Override\n            public void call(Weather weather) {\n                displayWeatherInformation();\n            }\n        }, new Action1<Throwable>() {\n            @Override\n            public void call(Throwable throwable) {\n                Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show();\n            }\n        });\n```\n\n上面的代码看起来比较复杂，我们采用Lambda表达式简化下代码：\n\n```Java\nObservable<Weather> observableForGetWeatherData;\n//首先创建一个从数据库获取天气数据的Observable\nObservable<Weather> observableForGetWeatherFromDB = Observable.create(new Observable.OnSubscribe<Weather>() {\n    @Override\n    public void call(Subscriber<? super Weather> subscriber) {\n        try {\n            Weather weather = weatherDao.queryWeather(cityId);\n            subscriber.onNext(weather);\n            subscriber.onCompleted();\n        } catch (SQLException e) {\n            throw Exceptions.propagate(e);\n        }\n    }\n});\n\nif (!NetworkUtils.isNetworkConnected(context)) {\n    observableForGetWeatherData = observableForGetWeatherFromDB;\n} else {\n    //接着创建一个从网络获取天气数据的Observable\n    Observable<Weather> observableForGetWeatherFromNetWork = null;\n    switch (configuration.getDataSourceType()) {\n        case ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:\n            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)\n                    .map(knowWeather -> new KnowWeatherAdapter(knowWeather).getWeather());\n            break;\n        case ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:\n            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)\n                    .map(miWeather -> new MiWeatherAdapter(miWeather).getWeather());\n            break;\n    }\n    assert observableForGetWeatherFromNetWork != null;\n    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork\n            .doOnNext(weather -> Schedulers.io().createWorker().schedule(() -> {\n                try {\n                    weatherDao.insertOrUpdateWeather(weather);\n                } catch (SQLException e) {\n                    throw Exceptions.propagate(e);\n                }\n            }));\n\n    //使用concat操作符将两个Observable合并\n    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)\n            .filter(weather -> weather != null && !TextUtils.isEmpty(weather.getCityId()))\n            .distinct(weather -> weather.getRealTime().getTime())//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉\n            .takeUntil(weather -> System.currentTimeMillis() - weather.getRealTime().getTime() <= 60 * 60 * 1000);//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流\n}\n\nobservableForGetWeatherData.subscribeOn(Schedulers.io())\n        .observeOn(AndroidSchedulers.mainThread())\n        .subscribe(weather -> displayWeatherInformation(),\n                throwable -> Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show());\n```\n\n## 小技巧\n\n在上述的实现中有几点是我们需要注意的:\n\n1. 为什么我需要在判断网络那块整个if else？这样看起来很不优雅，我们通过RxJava符完全可以实现同样的操作啊！之所以这样做是为了在无网络状况下去创建不必要的Observable `observableForGetWeatherFromNetWork`;\n\n2. 更新数据库的操作不应该阻塞更新UI，因此我们在`observableForGetWeatherFromNetWork`的`doOnNext`中需要通过`Schedulers.io().createWorker()`去另起一条线程，以此保证更新数据库不会阻塞更新UI的操作。\n\n\t> 有同学可能会问为什么不在`doOnNext`之后再调用一次`observeOn`把更新数据库的操作切换到一条新的子线程去操作呢？其实一开始我也是这样做的，后来想想不对。整个Observable的事件传递处理就像是在一条流水线上完成的，虽然我们可以通过`observeOn`来指定子线程去处理更新数据库的操作，但是只有等这条子线程完成了更新数据库的任务后事件才会继续往后传递，这样就阻塞了更新UI的操作。对此有疑问的同学可以去看看我之前关于RxJava源码分析的文章或者自己动手debug看看。\n\n## 问题\n\n最后给大家留个两个问题：\n\n1. 上述代码是最佳实现方案吗？还有什么更加合理的做法？\n2. 我们在`observableForGetWeatherData`中使用`distinct`和`takeUntil`过滤筛选天气数据的时候网络请求会不会已经发出去了？这样做还有意义吗？\n\n欢迎大家留言讨论。\n\n> 本文中的代码在[MinimalistWeather](https://github.com/BaronZ88/MinimalistWeather)中的`WeatherDataRepository`类中有同样的实现，文章中为了更完整的将整个实现过程呈现出来，对代码做了部分改动。\n> \n> 如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。\n>   \n> * 知乎专栏：[https://zhuanlan.zhihu.com/baron](https://zhuanlan.zhihu.com/baron)  \n> * GitHub：[https://github.com/BaronZ88](https://github.com/BaronZ88)\n","slug":"RxJava系列番外篇：一个RxJava解决复杂业务逻辑的案例","published":1,"updated":"2017-02-05T17:59:12.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26f9000v6st6a1mgwnhh","content":"<p>之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：</p>\n<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a> </li>\n</ul>\n<h2 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h2><p>拿<a href=\"https://github.com/BaronZ88/MinimalistWeather\" target=\"_blank\" rel=\"external\">MinimalistWeather</a>这个开源的天气App来举例：</p>\n<p>进入App首页后，首先我们需要从数据库中获取当前城市的天气数据，如果数据库中存在天气数据则在UI页面上展示天气数据；如果数据库中未存储当前城市的天气数据，或者已存储的天气数据的发布时间相比现在已经超过了一小时，并且网络属于连接状态则调用API从服务端获取天气数据。如果获取到到的天气数据发布时间和当前数据库中的天气数据发布时间一致则丢弃掉从服务端获取到的天气数据，如果不一致则更新数据库并且在页面上展示最新的天气信息。（同时天气数据源是可配置的，可选择是小米天气数据源还是Know天气数据源）</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>首先我们需要创建一个从数据库获取天气数据的Observable <code>observableForGetWeatherFromDB</code>，同时我们也需要创建一个从API获取天气数据的Observable <code>observableForGetWeatherFromNetWork</code>；为了在无网络状态下免于创建<code>observableForGetWeatherFromNetWork</code>我们在这之前需要首先判断下网络状态。最后使用<code>contact</code>操作符将两个Observable合并，同时使用<code>distinct</code>和<code>takeUntil</code>操作符来过滤筛选数据以符合业务需求，然后结合<code>subscribeOn</code>和<code>observeOn</code>做线程切换。上述这一套复杂的业务逻辑如果使用传统编码方式将是极其复杂的。下面我们来看看使用RxJava如何清晰简洁的来实现这个复杂的业务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class=\"line\"><span class=\"comment\">//首先创建一个从数据库获取天气数据的Observable</span></div><div class=\"line\">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Weather weather = weatherDao.queryWeather(cityId);</div><div class=\"line\">            subscriber.onNext(weather);</div><div class=\"line\">            subscriber.onCompleted();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> Exceptions.propagate(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class=\"line\">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//接着创建一个从网络获取天气数据的Observable</span></div><div class=\"line\">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (configuration.getDataSourceType()) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class=\"line\">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class=\"line\">                    .map(<span class=\"keyword\">new</span> Func1&lt;KnowWeather, Weather&gt;() &#123;</div><div class=\"line\">                        <span class=\"meta\">@Override</span></div><div class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> Weather <span class=\"title\">call</span><span class=\"params\">(KnowWeather knowWeather)</span> </span>&#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> KnowWeatherAdapter(knowWeather).getWeather();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class=\"line\">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class=\"line\">                    .map(<span class=\"keyword\">new</span> Func1&lt;MiWeather, Weather&gt;() &#123;</div><div class=\"line\">                        <span class=\"meta\">@Override</span></div><div class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> Weather <span class=\"title\">call</span><span class=\"params\">(MiWeather miWeather)</span> </span>&#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MiWeatherAdapter(miWeather).getWeather();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">assert</span> observableForGetWeatherFromNetWork != <span class=\"keyword\">null</span>;</div><div class=\"line\">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class=\"line\">            .doOnNext(<span class=\"keyword\">new</span> Action1&lt;Weather&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                    Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class=\"line\">                        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                            weatherDao.insertOrUpdateWeather(weather);</div><div class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</div><div class=\"line\">                            <span class=\"keyword\">throw</span> Exceptions.propagate(e);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//使用concat操作符将两个Observable合并</span></div><div class=\"line\">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class=\"line\">            .filter(<span class=\"keyword\">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> weather != <span class=\"keyword\">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .distinct(<span class=\"keyword\">new</span> Func1&lt;Weather, Long&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> weather.getRealTime().getTime();<span class=\"comment\">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .takeUntil(<span class=\"keyword\">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;<span class=\"comment\">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class=\"line\">        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;Weather&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                displayWeatherInformation();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, <span class=\"keyword\">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">                Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>上面的代码看起来比较复杂，我们采用Lambda表达式简化下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class=\"line\"><span class=\"comment\">//首先创建一个从数据库获取天气数据的Observable</span></div><div class=\"line\">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Weather weather = weatherDao.queryWeather(cityId);</div><div class=\"line\">            subscriber.onNext(weather);</div><div class=\"line\">            subscriber.onCompleted();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> Exceptions.propagate(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class=\"line\">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//接着创建一个从网络获取天气数据的Observable</span></div><div class=\"line\">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (configuration.getDataSourceType()) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class=\"line\">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class=\"line\">                    .map(knowWeather -&gt; <span class=\"keyword\">new</span> KnowWeatherAdapter(knowWeather).getWeather());</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class=\"line\">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class=\"line\">                    .map(miWeather -&gt; <span class=\"keyword\">new</span> MiWeatherAdapter(miWeather).getWeather());</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">assert</span> observableForGetWeatherFromNetWork != <span class=\"keyword\">null</span>;</div><div class=\"line\">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class=\"line\">            .doOnNext(weather -&gt; Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    weatherDao.insertOrUpdateWeather(weather);</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</div><div class=\"line\">                    <span class=\"keyword\">throw</span> Exceptions.propagate(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//使用concat操作符将两个Observable合并</span></div><div class=\"line\">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class=\"line\">            .filter(weather -&gt; weather != <span class=\"keyword\">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId()))</div><div class=\"line\">            .distinct(weather -&gt; weather.getRealTime().getTime())<span class=\"comment\">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class=\"line\">            .takeUntil(weather -&gt; System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>);<span class=\"comment\">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class=\"line\">        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">        .subscribe(weather -&gt; displayWeatherInformation(),</div><div class=\"line\">                throwable -&gt; Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show());</div></pre></td></tr></table></figure>\n<h2 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h2><p>在上述的实现中有几点是我们需要注意的:</p>\n<ol>\n<li><p>为什么我需要在判断网络那块整个if else？这样看起来很不优雅，我们通过RxJava符完全可以实现同样的操作啊！之所以这样做是为了在无网络状况下去创建不必要的Observable <code>observableForGetWeatherFromNetWork</code>;</p>\n</li>\n<li><p>更新数据库的操作不应该阻塞更新UI，因此我们在<code>observableForGetWeatherFromNetWork</code>的<code>doOnNext</code>中需要通过<code>Schedulers.io().createWorker()</code>去另起一条线程，以此保证更新数据库不会阻塞更新UI的操作。</p>\n<blockquote>\n<p>有同学可能会问为什么不在<code>doOnNext</code>之后再调用一次<code>observeOn</code>把更新数据库的操作切换到一条新的子线程去操作呢？其实一开始我也是这样做的，后来想想不对。整个Observable的事件传递处理就像是在一条流水线上完成的，虽然我们可以通过<code>observeOn</code>来指定子线程去处理更新数据库的操作，但是只有等这条子线程完成了更新数据库的任务后事件才会继续往后传递，这样就阻塞了更新UI的操作。对此有疑问的同学可以去看看我之前关于RxJava源码分析的文章或者自己动手debug看看。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>最后给大家留个两个问题：</p>\n<ol>\n<li>上述代码是最佳实现方案吗？还有什么更加合理的做法？</li>\n<li>我们在<code>observableForGetWeatherData</code>中使用<code>distinct</code>和<code>takeUntil</code>过滤筛选天气数据的时候网络请求会不会已经发出去了？这样做还有意义吗？</li>\n</ol>\n<p>欢迎大家留言讨论。</p>\n<blockquote>\n<p>本文中的代码在<a href=\"https://github.com/BaronZ88/MinimalistWeather\" target=\"_blank\" rel=\"external\">MinimalistWeather</a>中的<code>WeatherDataRepository</code>类中有同样的实现，文章中为了更完整的将整个实现过程呈现出来，对代码做了部分改动。</p>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\" target=\"_blank\" rel=\"external\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\" target=\"_blank\" rel=\"external\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n","excerpt":"","more":"<p>之前写过一系列RxJava1的文章，也承诺过会尽快有RxJava2的介绍。无奈实际项目中还未真正的使用RxJava2，不敢妄动笔墨。所以这次还是给大家分享一个使用RxJava1解决问题的案例，希望对大家在使用RxJava的时候有一点点启发。对RxJava还不了解的同学可以先去看看我之前的RxJava系列文章：</p>\n<ul>\n<li><a href=\"../RxJava系列1-简介/\">RxJava系列1(简介)</a></li>\n<li><a href=\"../RxJava系列2-基本概念及使用介绍/\">RxJava系列2(基本概念及使用介绍)</a></li>\n<li><a href=\"../RxJava系列3-转换操作符/\">RxJava系列3(转换操作符)</a></li>\n<li><a href=\"../RxJava系列4-过滤操作符/\">RxJava系列4(过滤操作符)</a></li>\n<li><a href=\"../RxJava系列5-组合操作符/\">RxJava系列5(组合操作符)</a></li>\n<li><a href=\"../RxJava系列6-从微观角度解读RxJava源码/\">RxJava系列6(从微观角度解读RxJava源码)</a>   </li>\n<li><a href=\"../RxJava系列7-最佳实践/\">RxJava系列7(最佳实践)</a> </li>\n</ul>\n<h2 id=\"业务场景\"><a href=\"#业务场景\" class=\"headerlink\" title=\"业务场景\"></a>业务场景</h2><p>拿<a href=\"https://github.com/BaronZ88/MinimalistWeather\">MinimalistWeather</a>这个开源的天气App来举例：</p>\n<p>进入App首页后，首先我们需要从数据库中获取当前城市的天气数据，如果数据库中存在天气数据则在UI页面上展示天气数据；如果数据库中未存储当前城市的天气数据，或者已存储的天气数据的发布时间相比现在已经超过了一小时，并且网络属于连接状态则调用API从服务端获取天气数据。如果获取到到的天气数据发布时间和当前数据库中的天气数据发布时间一致则丢弃掉从服务端获取到的天气数据，如果不一致则更新数据库并且在页面上展示最新的天气信息。（同时天气数据源是可配置的，可选择是小米天气数据源还是Know天气数据源）</p>\n<h2 id=\"解决方案\"><a href=\"#解决方案\" class=\"headerlink\" title=\"解决方案\"></a>解决方案</h2><p>首先我们需要创建一个从数据库获取天气数据的Observable <code>observableForGetWeatherFromDB</code>，同时我们也需要创建一个从API获取天气数据的Observable <code>observableForGetWeatherFromNetWork</code>；为了在无网络状态下免于创建<code>observableForGetWeatherFromNetWork</code>我们在这之前需要首先判断下网络状态。最后使用<code>contact</code>操作符将两个Observable合并，同时使用<code>distinct</code>和<code>takeUntil</code>操作符来过滤筛选数据以符合业务需求，然后结合<code>subscribeOn</code>和<code>observeOn</code>做线程切换。上述这一套复杂的业务逻辑如果使用传统编码方式将是极其复杂的。下面我们来看看使用RxJava如何清晰简洁的来实现这个复杂的业务：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div><div class=\"line\">52</div><div class=\"line\">53</div><div class=\"line\">54</div><div class=\"line\">55</div><div class=\"line\">56</div><div class=\"line\">57</div><div class=\"line\">58</div><div class=\"line\">59</div><div class=\"line\">60</div><div class=\"line\">61</div><div class=\"line\">62</div><div class=\"line\">63</div><div class=\"line\">64</div><div class=\"line\">65</div><div class=\"line\">66</div><div class=\"line\">67</div><div class=\"line\">68</div><div class=\"line\">69</div><div class=\"line\">70</div><div class=\"line\">71</div><div class=\"line\">72</div><div class=\"line\">73</div><div class=\"line\">74</div><div class=\"line\">75</div><div class=\"line\">76</div><div class=\"line\">77</div><div class=\"line\">78</div><div class=\"line\">79</div><div class=\"line\">80</div><div class=\"line\">81</div><div class=\"line\">82</div><div class=\"line\">83</div><div class=\"line\">84</div><div class=\"line\">85</div><div class=\"line\">86</div><div class=\"line\">87</div><div class=\"line\">88</div><div class=\"line\">89</div><div class=\"line\">90</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class=\"line\"><span class=\"comment\">//首先创建一个从数据库获取天气数据的Observable</span></div><div class=\"line\">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Weather weather = weatherDao.queryWeather(cityId);</div><div class=\"line\">            subscriber.onNext(weather);</div><div class=\"line\">            subscriber.onCompleted();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> Exceptions.propagate(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class=\"line\">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//接着创建一个从网络获取天气数据的Observable</span></div><div class=\"line\">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (configuration.getDataSourceType()) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class=\"line\">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class=\"line\">                    .map(<span class=\"keyword\">new</span> Func1&lt;KnowWeather, Weather&gt;() &#123;</div><div class=\"line\">                        <span class=\"meta\">@Override</span></div><div class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> Weather <span class=\"title\">call</span><span class=\"params\">(KnowWeather knowWeather)</span> </span>&#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> KnowWeatherAdapter(knowWeather).getWeather();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class=\"line\">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class=\"line\">                    .map(<span class=\"keyword\">new</span> Func1&lt;MiWeather, Weather&gt;() &#123;</div><div class=\"line\">                        <span class=\"meta\">@Override</span></div><div class=\"line\">                        <span class=\"function\"><span class=\"keyword\">public</span> Weather <span class=\"title\">call</span><span class=\"params\">(MiWeather miWeather)</span> </span>&#123;</div><div class=\"line\">                            <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> MiWeatherAdapter(miWeather).getWeather();</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">assert</span> observableForGetWeatherFromNetWork != <span class=\"keyword\">null</span>;</div><div class=\"line\">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class=\"line\">            .doOnNext(<span class=\"keyword\">new</span> Action1&lt;Weather&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                    Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class=\"line\">                        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                            weatherDao.insertOrUpdateWeather(weather);</div><div class=\"line\">                        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</div><div class=\"line\">                            <span class=\"keyword\">throw</span> Exceptions.propagate(e);</div><div class=\"line\">                        &#125;</div><div class=\"line\">                    &#125;);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//使用concat操作符将两个Observable合并</span></div><div class=\"line\">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class=\"line\">            .filter(<span class=\"keyword\">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> weather != <span class=\"keyword\">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId());</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .distinct(<span class=\"keyword\">new</span> Func1&lt;Weather, Long&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Long <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> weather.getRealTime().getTime();<span class=\"comment\">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;)</div><div class=\"line\">            .takeUntil(<span class=\"keyword\">new</span> Func1&lt;Weather, Boolean&gt;() &#123;</div><div class=\"line\">                <span class=\"meta\">@Override</span></div><div class=\"line\">                <span class=\"function\"><span class=\"keyword\">public</span> Boolean <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                    <span class=\"keyword\">return</span> System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>;<span class=\"comment\">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;);</div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class=\"line\">        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">        .subscribe(<span class=\"keyword\">new</span> Action1&lt;Weather&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Weather weather)</span> </span>&#123;</div><div class=\"line\">                displayWeatherInformation();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;, <span class=\"keyword\">new</span> Action1&lt;Throwable&gt;() &#123;</div><div class=\"line\">            <span class=\"meta\">@Override</span></div><div class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Throwable throwable)</span> </span>&#123;</div><div class=\"line\">                Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show();</div><div class=\"line\">            &#125;</div><div class=\"line\">        &#125;);</div></pre></td></tr></table></figure>\n<p>上面的代码看起来比较复杂，我们采用Lambda表达式简化下代码：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><div class=\"line\">1</div><div class=\"line\">2</div><div class=\"line\">3</div><div class=\"line\">4</div><div class=\"line\">5</div><div class=\"line\">6</div><div class=\"line\">7</div><div class=\"line\">8</div><div class=\"line\">9</div><div class=\"line\">10</div><div class=\"line\">11</div><div class=\"line\">12</div><div class=\"line\">13</div><div class=\"line\">14</div><div class=\"line\">15</div><div class=\"line\">16</div><div class=\"line\">17</div><div class=\"line\">18</div><div class=\"line\">19</div><div class=\"line\">20</div><div class=\"line\">21</div><div class=\"line\">22</div><div class=\"line\">23</div><div class=\"line\">24</div><div class=\"line\">25</div><div class=\"line\">26</div><div class=\"line\">27</div><div class=\"line\">28</div><div class=\"line\">29</div><div class=\"line\">30</div><div class=\"line\">31</div><div class=\"line\">32</div><div class=\"line\">33</div><div class=\"line\">34</div><div class=\"line\">35</div><div class=\"line\">36</div><div class=\"line\">37</div><div class=\"line\">38</div><div class=\"line\">39</div><div class=\"line\">40</div><div class=\"line\">41</div><div class=\"line\">42</div><div class=\"line\">43</div><div class=\"line\">44</div><div class=\"line\">45</div><div class=\"line\">46</div><div class=\"line\">47</div><div class=\"line\">48</div><div class=\"line\">49</div><div class=\"line\">50</div><div class=\"line\">51</div></pre></td><td class=\"code\"><pre><div class=\"line\">Observable&lt;Weather&gt; observableForGetWeatherData;</div><div class=\"line\"><span class=\"comment\">//首先创建一个从数据库获取天气数据的Observable</span></div><div class=\"line\">Observable&lt;Weather&gt; observableForGetWeatherFromDB = Observable.create(<span class=\"keyword\">new</span> Observable.OnSubscribe&lt;Weather&gt;() &#123;</div><div class=\"line\">    <span class=\"meta\">@Override</span></div><div class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">call</span><span class=\"params\">(Subscriber&lt;? <span class=\"keyword\">super</span> Weather&gt; subscriber)</span> </span>&#123;</div><div class=\"line\">        <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">            Weather weather = weatherDao.queryWeather(cityId);</div><div class=\"line\">            subscriber.onNext(weather);</div><div class=\"line\">            subscriber.onCompleted();</div><div class=\"line\">        &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</div><div class=\"line\">            <span class=\"keyword\">throw</span> Exceptions.propagate(e);</div><div class=\"line\">        &#125;</div><div class=\"line\">    &#125;</div><div class=\"line\">&#125;);</div><div class=\"line\"></div><div class=\"line\"><span class=\"keyword\">if</span> (!NetworkUtils.isNetworkConnected(context)) &#123;</div><div class=\"line\">    observableForGetWeatherData = observableForGetWeatherFromDB;</div><div class=\"line\">&#125; <span class=\"keyword\">else</span> &#123;</div><div class=\"line\">    <span class=\"comment\">//接着创建一个从网络获取天气数据的Observable</span></div><div class=\"line\">    Observable&lt;Weather&gt; observableForGetWeatherFromNetWork = <span class=\"keyword\">null</span>;</div><div class=\"line\">    <span class=\"keyword\">switch</span> (configuration.getDataSourceType()) &#123;</div><div class=\"line\">        <span class=\"keyword\">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_KNOW:</div><div class=\"line\">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getKnowWeather(cityId)</div><div class=\"line\">                    .map(knowWeather -&gt; <span class=\"keyword\">new</span> KnowWeatherAdapter(knowWeather).getWeather());</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">        <span class=\"keyword\">case</span> ApiConstants.WEATHER_DATA_SOURCE_TYPE_MI:</div><div class=\"line\">            observableForGetWeatherFromNetWork = ApiClient.weatherService.getMiWeather(cityId)</div><div class=\"line\">                    .map(miWeather -&gt; <span class=\"keyword\">new</span> MiWeatherAdapter(miWeather).getWeather());</div><div class=\"line\">            <span class=\"keyword\">break</span>;</div><div class=\"line\">    &#125;</div><div class=\"line\">    <span class=\"keyword\">assert</span> observableForGetWeatherFromNetWork != <span class=\"keyword\">null</span>;</div><div class=\"line\">    observableForGetWeatherFromNetWork = observableForGetWeatherFromNetWork</div><div class=\"line\">            .doOnNext(weather -&gt; Schedulers.io().createWorker().schedule(() -&gt; &#123;</div><div class=\"line\">                <span class=\"keyword\">try</span> &#123;</div><div class=\"line\">                    weatherDao.insertOrUpdateWeather(weather);</div><div class=\"line\">                &#125; <span class=\"keyword\">catch</span> (SQLException e) &#123;</div><div class=\"line\">                    <span class=\"keyword\">throw</span> Exceptions.propagate(e);</div><div class=\"line\">                &#125;</div><div class=\"line\">            &#125;));</div><div class=\"line\"></div><div class=\"line\">    <span class=\"comment\">//使用concat操作符将两个Observable合并</span></div><div class=\"line\">    observableForGetWeatherData = Observable.concat(observableForGetWeatherFromDB, observableForGetWeatherFromNetWork)</div><div class=\"line\">            .filter(weather -&gt; weather != <span class=\"keyword\">null</span> &amp;&amp; !TextUtils.isEmpty(weather.getCityId()))</div><div class=\"line\">            .distinct(weather -&gt; weather.getRealTime().getTime())<span class=\"comment\">//如果天气数据发布时间一致，我们再认为是相同的数据从丢弃掉</span></div><div class=\"line\">            .takeUntil(weather -&gt; System.currentTimeMillis() - weather.getRealTime().getTime() &lt;= <span class=\"number\">60</span> * <span class=\"number\">60</span> * <span class=\"number\">1000</span>);<span class=\"comment\">//如果天气数据发布的时间和当前时间差在一小时以内则终止事件流</span></div><div class=\"line\">&#125;</div><div class=\"line\"></div><div class=\"line\">observableForGetWeatherData.subscribeOn(Schedulers.io())</div><div class=\"line\">        .observeOn(AndroidSchedulers.mainThread())</div><div class=\"line\">        .subscribe(weather -&gt; displayWeatherInformation(),</div><div class=\"line\">                throwable -&gt; Toast.makeText(context, throwable.getMessage(), Toast.LENGTH_LONG).show());</div></pre></td></tr></table></figure>\n<h2 id=\"小技巧\"><a href=\"#小技巧\" class=\"headerlink\" title=\"小技巧\"></a>小技巧</h2><p>在上述的实现中有几点是我们需要注意的:</p>\n<ol>\n<li><p>为什么我需要在判断网络那块整个if else？这样看起来很不优雅，我们通过RxJava符完全可以实现同样的操作啊！之所以这样做是为了在无网络状况下去创建不必要的Observable <code>observableForGetWeatherFromNetWork</code>;</p>\n</li>\n<li><p>更新数据库的操作不应该阻塞更新UI，因此我们在<code>observableForGetWeatherFromNetWork</code>的<code>doOnNext</code>中需要通过<code>Schedulers.io().createWorker()</code>去另起一条线程，以此保证更新数据库不会阻塞更新UI的操作。</p>\n<blockquote>\n<p>有同学可能会问为什么不在<code>doOnNext</code>之后再调用一次<code>observeOn</code>把更新数据库的操作切换到一条新的子线程去操作呢？其实一开始我也是这样做的，后来想想不对。整个Observable的事件传递处理就像是在一条流水线上完成的，虽然我们可以通过<code>observeOn</code>来指定子线程去处理更新数据库的操作，但是只有等这条子线程完成了更新数据库的任务后事件才会继续往后传递，这样就阻塞了更新UI的操作。对此有疑问的同学可以去看看我之前关于RxJava源码分析的文章或者自己动手debug看看。</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"问题\"><a href=\"#问题\" class=\"headerlink\" title=\"问题\"></a>问题</h2><p>最后给大家留个两个问题：</p>\n<ol>\n<li>上述代码是最佳实现方案吗？还有什么更加合理的做法？</li>\n<li>我们在<code>observableForGetWeatherData</code>中使用<code>distinct</code>和<code>takeUntil</code>过滤筛选天气数据的时候网络请求会不会已经发出去了？这样做还有意义吗？</li>\n</ol>\n<p>欢迎大家留言讨论。</p>\n<blockquote>\n<p>本文中的代码在<a href=\"https://github.com/BaronZ88/MinimalistWeather\">MinimalistWeather</a>中的<code>WeatherDataRepository</code>类中有同样的实现，文章中为了更完整的将整个实现过程呈现出来，对代码做了部分改动。</p>\n<p>如果大家喜欢这一系列的文章，欢迎关注我的知乎专栏和GitHub。</p>\n<ul>\n<li>知乎专栏：<a href=\"https://zhuanlan.zhihu.com/baron\">https://zhuanlan.zhihu.com/baron</a>  </li>\n<li>GitHub：<a href=\"https://github.com/BaronZ88\">https://github.com/BaronZ88</a></li>\n</ul>\n</blockquote>\n"},{"title":"观察者模式(ObserverPattern)","date":"2017-02-05T16:16:14.000Z","_content":"","source":"_posts/2017-02-06-观察者模式-ObserverPattern.md","raw":"---\ntitle: 观察者模式(ObserverPattern)\ndate: 2017-02-06 00:16:14\ncategories:\ntags:\n---\n","slug":"观察者模式-ObserverPattern","published":1,"updated":"2017-02-05T16:16:14.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"ciytk26fb00106st6lm0ofn2u","content":"","excerpt":"","more":""}],"PostAsset":[],"PostCategory":[{"post_id":"ciytk26eb00056st6uevra1lh","category_id":"ciytk26e400026st6pnlss1ck","_id":"ciytk26eo000b6st6uxh58zyf"},{"post_id":"ciytk26dn00006st67g6ldh6h","category_id":"ciytk26e400026st6pnlss1ck","_id":"ciytk26er000g6st6ys0xjspa"},{"post_id":"ciytk26dv00016st66hlb0qs1","category_id":"ciytk26e400026st6pnlss1ck","_id":"ciytk26et000j6st6w7sx6b2v"},{"post_id":"ciytk26ea00046st6muzn2f69","category_id":"ciytk26e400026st6pnlss1ck","_id":"ciytk26ez000o6st6eeur3yei"},{"post_id":"ciytk26ex000n6st6g30u32fe","category_id":"ciytk26ev000l6st6adlom09m","_id":"ciytk26f9000u6st6cuq8p4of"},{"post_id":"ciytk26ej000a6st6hu9lbwpr","category_id":"ciytk26ev000l6st6adlom09m","_id":"ciytk26fb000z6st6tg7r44l5"},{"post_id":"ciytk26f1000p6st6e2nme8ve","category_id":"ciytk26ev000l6st6adlom09m","_id":"ciytk26fd00126st6q9fiba31"},{"post_id":"ciytk26f8000s6st6akjvbezq","category_id":"ciytk26ev000l6st6adlom09m","_id":"ciytk26fe00166st6kbv3s0h5"},{"post_id":"ciytk26eo000d6st639cz443z","category_id":"ciytk26ev000l6st6adlom09m","_id":"ciytk26ff00186st6c7g6emon"},{"post_id":"ciytk26f9000v6st6a1mgwnhh","category_id":"ciytk26ev000l6st6adlom09m","_id":"ciytk26fg001b6st6zw2w28qh"},{"post_id":"ciytk26er000i6st6n19yui71","category_id":"ciytk26ev000l6st6adlom09m","_id":"ciytk26fh001d6st61z1nhaq4"},{"post_id":"ciytk26et000k6st6xq04puwy","category_id":"ciytk26ev000l6st6adlom09m","_id":"ciytk26fi001g6st6guz7p0o2"}],"PostTag":[{"post_id":"ciytk26eb00056st6uevra1lh","tag_id":"ciytk26e700036st61qsbmxhi","_id":"ciytk26ej00096st66c29rh2n"},{"post_id":"ciytk26dn00006st67g6ldh6h","tag_id":"ciytk26e700036st61qsbmxhi","_id":"ciytk26eo000c6st6au4wpdr1"},{"post_id":"ciytk26dv00016st66hlb0qs1","tag_id":"ciytk26e700036st61qsbmxhi","_id":"ciytk26er000h6st6v5lrsbqy"},{"post_id":"ciytk26ea00046st6muzn2f69","tag_id":"ciytk26e700036st61qsbmxhi","_id":"ciytk26f9000t6st63yu3ocs3"},{"post_id":"ciytk26ea00046st6muzn2f69","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26fa000w6st67gs4wccc"},{"post_id":"ciytk26f8000s6st6akjvbezq","tag_id":"ciytk26f5000r6st6i02qxdp1","_id":"ciytk26fc00116st6qdf63s4c"},{"post_id":"ciytk26f8000s6st6akjvbezq","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26fd00136st6y96fhcik"},{"post_id":"ciytk26f9000v6st6a1mgwnhh","tag_id":"ciytk26f5000r6st6i02qxdp1","_id":"ciytk26ff00176st6uot7e2s7"},{"post_id":"ciytk26f9000v6st6a1mgwnhh","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26ff00196st6tgplwygd"},{"post_id":"ciytk26ej000a6st6hu9lbwpr","tag_id":"ciytk26f5000r6st6i02qxdp1","_id":"ciytk26fg001c6st6l1k9f3oh"},{"post_id":"ciytk26ej000a6st6hu9lbwpr","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26fh001e6st66c28ebie"},{"post_id":"ciytk26eo000d6st639cz443z","tag_id":"ciytk26f5000r6st6i02qxdp1","_id":"ciytk26fj001h6st6o004fiwc"},{"post_id":"ciytk26eo000d6st639cz443z","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26fj001i6st6almles3o"},{"post_id":"ciytk26er000i6st6n19yui71","tag_id":"ciytk26f5000r6st6i02qxdp1","_id":"ciytk26fl001l6st6z6wuj2hq"},{"post_id":"ciytk26er000i6st6n19yui71","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26fl001m6st6xou6pdqm"},{"post_id":"ciytk26et000k6st6xq04puwy","tag_id":"ciytk26f5000r6st6i02qxdp1","_id":"ciytk26fn001p6st6xvesjycp"},{"post_id":"ciytk26et000k6st6xq04puwy","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26fo001q6st6zfe2lv3w"},{"post_id":"ciytk26ex000n6st6g30u32fe","tag_id":"ciytk26f5000r6st6i02qxdp1","_id":"ciytk26fo001s6st6ksg7q34g"},{"post_id":"ciytk26ex000n6st6g30u32fe","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26fp001t6st6l8ewhvz0"},{"post_id":"ciytk26f1000p6st6e2nme8ve","tag_id":"ciytk26f5000r6st6i02qxdp1","_id":"ciytk26fp001u6st66ubk804x"},{"post_id":"ciytk26f1000p6st6e2nme8ve","tag_id":"ciytk26ev000m6st64rvt8uqu","_id":"ciytk26fp001v6st6titgykhe"}],"Tag":[{"name":"Java","_id":"ciytk26e700036st61qsbmxhi"},{"name":"Android","_id":"ciytk26ev000m6st64rvt8uqu"},{"name":"RxJava","_id":"ciytk26f5000r6st6i02qxdp1"}]}}